import {
  require_create
} from "./chunk-UGW2KGPM.js";
import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/@jscad/modeling/src/curves/bezier/valueAt.js
var require_valueAt = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/valueAt.js"(exports, module) {
    var valueAt = (t, bezier) => {
      if (t < 0 || t > 1) {
        throw new Error("Bezier valueAt() input must be between 0 and 1");
      }
      if (bezier.pointType === "float_single") {
        return bezierFunction(bezier, bezier.points, t);
      } else {
        const result = [];
        for (let i = 0; i < bezier.dimensions; i++) {
          const singleDimensionPoints = [];
          for (let j = 0; j < bezier.points.length; j++) {
            singleDimensionPoints.push(bezier.points[j][i]);
          }
          result.push(bezierFunction(bezier, singleDimensionPoints, t));
        }
        return result;
      }
    };
    var bezierFunction = function(bezier, p, t) {
      const n = p.length - 1;
      let result = 0;
      for (let i = 0; i <= n; i++) {
        result += bezier.permutations[i] * Math.pow(1 - t, n - i) * Math.pow(t, i) * p[i];
      }
      return result;
    };
    module.exports = valueAt;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/tangentAt.js
var require_tangentAt = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/tangentAt.js"(exports, module) {
    var tangentAt = (t, bezier) => {
      if (t < 0 || t > 1) {
        throw new Error("Bezier tangentAt() input must be between 0 and 1");
      }
      if (bezier.pointType === "float_single") {
        return bezierTangent(bezier, bezier.points, t);
      } else {
        const result = [];
        for (let i = 0; i < bezier.dimensions; i++) {
          const singleDimensionPoints = [];
          for (let j = 0; j < bezier.points.length; j++) {
            singleDimensionPoints.push(bezier.points[j][i]);
          }
          result.push(bezierTangent(bezier, singleDimensionPoints, t));
        }
        return result;
      }
    };
    var bezierTangent = function(bezier, p, t) {
      const n = p.length - 1;
      let result = 0;
      for (let i = 0; i < n; i++) {
        const q = n * (p[i + 1] - p[i]);
        result += bezier.tangentPermutations[i] * Math.pow(1 - t, n - 1 - i) * Math.pow(t, i) * q;
      }
      return result;
    };
    module.exports = tangentAt;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/lengths.js
var require_lengths = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/lengths.js"(exports, module) {
    var valueAt = require_valueAt();
    var lengths = (segments, bezier) => {
      let sum = 0;
      const lengths2 = [0];
      let previous = valueAt(0, bezier);
      for (let index = 1; index <= segments; index++) {
        const current = valueAt(index / segments, bezier);
        sum += distanceBetween(current, previous);
        lengths2.push(sum);
        previous = current;
      }
      return lengths2;
    };
    var distanceBetween = (a, b) => {
      if (Number.isFinite(a) && Number.isFinite(b)) {
        return Math.abs(a - b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
          throw new Error("The operands must have the same number of dimensions.");
        }
        let sum = 0;
        for (let i = 0; i < a.length; i++) {
          sum += (b[i] - a[i]) * (b[i] - a[i]);
        }
        return Math.sqrt(sum);
      } else {
        throw new Error("The operands must be of the same type, either number or array.");
      }
    };
    module.exports = lengths;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/length.js
var require_length = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/length.js"(exports, module) {
    var lengths = require_lengths();
    var length = (segments, bezier) => lengths(segments, bezier)[segments];
    module.exports = length;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/arcLengthToT.js
var require_arcLengthToT = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/arcLengthToT.js"(exports, module) {
    var lengths = require_lengths();
    var arcLengthToT = (options, bezier) => {
      const defaults = {
        distance: 0,
        segments: 100
      };
      const { distance, segments } = Object.assign({}, defaults, options);
      const arcLengths = lengths(segments, bezier);
      let startIndex = 0;
      let endIndex = segments;
      while (startIndex <= endIndex) {
        const middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
        const diff = arcLengths[middleIndex] - distance;
        if (diff < 0) {
          startIndex = middleIndex + 1;
        } else if (diff > 0) {
          endIndex = middleIndex - 1;
        } else {
          endIndex = middleIndex;
          break;
        }
      }
      const targetIndex = endIndex;
      if (arcLengths[targetIndex] === distance) {
        return targetIndex / segments;
      }
      const lengthBefore = arcLengths[targetIndex];
      const lengthAfter = arcLengths[targetIndex + 1];
      const segmentLength = lengthAfter - lengthBefore;
      const segmentFraction = (distance - lengthBefore) / segmentLength;
      return (targetIndex + segmentFraction) / segments;
    };
    module.exports = arcLengthToT;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/index.js
var require_bezier = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/index.js"(exports, module) {
    module.exports = {
      create: require_create(),
      valueAt: require_valueAt(),
      tangentAt: require_tangentAt(),
      lengths: require_lengths(),
      length: require_length(),
      arcLengthToT: require_arcLengthToT()
    };
  }
});

export {
  require_bezier
};
//# sourceMappingURL=chunk-QZYXOV4R.js.map
