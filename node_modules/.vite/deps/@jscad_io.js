import {
  require_src
} from "./chunk-ULC346GN.js";
import "./chunk-QZYXOV4R.js";
import "./chunk-UGW2KGPM.js";
import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/@jscad/io-utils/Blob.js
var require_Blob = __commonJS({
  "node_modules/@jscad/io-utils/Blob.js"(exports, module) {
    var Blob2 = class _Blob {
      /**
       * Returns a newly created Blob object which contains a concatenation of all of the data in the given contents.
       * @param {Array} contents - an array of ArrayBuffer, or String objects that will be put inside the Blob.
       */
      constructor(contents, options) {
        options = options || {};
        this.size = 0;
        this.type = "";
        this.isClosed = false;
        this.encoding = "utf8";
        this.buffer = null;
        this.length = 0;
        if (!contents)
          return;
        if (!Array.isArray(contents))
          return;
        contents.forEach((content) => {
          if (typeof content === "string") {
            this.length += content.length;
          } else if (content instanceof ArrayBuffer) {
            this.length += content.byteLength;
          }
        });
        if (options.type) {
          this.type = options.type.toLowerCase();
        }
        if (options.endings) {
        }
        if (options.encoding) {
          this.encoding = options.encoding.toLowerCase();
        }
        if (options.length) {
          this.length = options.length;
        }
        let wbytes;
        let object;
        this.buffer = Buffer.allocUnsafe(this.length);
        for (let index = 0; index < contents.length; index++) {
          switch (typeof contents[index]) {
            case "string":
              wbytes = this.buffer.write(contents[index], this.size, this.encoding);
              this.size = this.size + wbytes;
              break;
            case "object":
              object = contents[index];
              if (object instanceof ArrayBuffer) {
                const view = new DataView(object);
                for (let bindex = 0; bindex < object.byteLength; bindex++) {
                  const xbyte = view.getUint8(bindex);
                  wbytes = this.buffer.writeUInt8(xbyte, this.size, false);
                  this.size++;
                }
              }
              break;
            default:
              break;
          }
        }
      }
      asBuffer() {
        return this.buffer.slice(0, this.size);
      }
      arrayBuffer() {
        return this.buffer.slice(0, this.size);
      }
      slice(start, end, type) {
        start = start || 0;
        end = end || this.size;
        type = type || "";
        return new _Blob();
      }
      stream() {
        return null;
      }
      text() {
        return "";
      }
      close() {
        if (this.isClosed)
          return;
        this.isClosed = true;
      }
      toString() {
        return "";
      }
    };
    module.exports = Blob2;
  }
});

// node_modules/@jscad/io-utils/makeBlob.js
var require_makeBlob = __commonJS({
  "node_modules/@jscad/io-utils/makeBlob.js"(exports, module) {
    var nodeBlob = require_Blob();
    var makeBlob = () => {
      const blob = typeof window !== "undefined" ? window.Blob : nodeBlob;
      return blob;
    };
    module.exports = makeBlob;
  }
});

// node_modules/@jscad/io-utils/convertToBlob.js
var require_convertToBlob = __commonJS({
  "node_modules/@jscad/io-utils/convertToBlob.js"(exports, module) {
    var makeBlob = require_makeBlob();
    var Blob2 = makeBlob();
    var convertToBlob = (input) => {
      const { data, mimeType } = input;
      const blob = new Blob2(data, { type: mimeType });
      return blob;
    };
    module.exports = convertToBlob;
  }
});

// node_modules/@jscad/io-utils/BinaryReader.js
var require_BinaryReader = __commonJS({
  "node_modules/@jscad/io-utils/BinaryReader.js"(exports, module) {
    var BinaryReader = class {
      /*
       * Construct a BinaryReader from the given data.
       * The data is a string created from the specified sequence of UTF-16 code units.
       * See String.fromCharCode()
       * See _readByte() below
       */
      constructor(data) {
        this._buffer = data;
        this._pos = 0;
      }
      /* Public */
      readInt8() {
        return this._decodeInt(8, true);
      }
      readUInt8() {
        return this._decodeInt(8, false);
      }
      readInt16() {
        return this._decodeInt(16, true);
      }
      readUInt16() {
        return this._decodeInt(16, false);
      }
      readInt32() {
        return this._decodeInt(32, true);
      }
      readUInt32() {
        return this._decodeInt(32, false);
      }
      readFloat() {
        return this._decodeFloat(23, 8);
      }
      readDouble() {
        return this._decodeFloat(52, 11);
      }
      readChar() {
        return this.readString(1);
      }
      readString(length) {
        this._checkSize(length * 8);
        const result = this._buffer.substr(this._pos, length);
        this._pos += length;
        return result;
      }
      seek(pos) {
        this._pos = pos;
        this._checkSize(0);
      }
      getPosition() {
        return this._pos;
      }
      getSize() {
        return this._buffer.length;
      }
      /* Private */
      _decodeFloat(precisionBits, exponentBits) {
        const length = precisionBits + exponentBits + 1;
        const size = length >> 3;
        this._checkSize(length);
        const bias = Math.pow(2, exponentBits - 1) - 1;
        const signal = this._readBits(precisionBits + exponentBits, 1, size);
        const exponent = this._readBits(precisionBits, exponentBits, size);
        let significand = 0;
        let divisor = 2;
        let curByte = 0;
        let startBit = 0;
        do {
          const byteValue = this._readByte(++curByte, size);
          startBit = precisionBits % 8 || 8;
          let mask = 1 << startBit;
          while (mask >>= 1) {
            if (byteValue & mask) {
              significand += 1 / divisor;
            }
            divisor *= 2;
          }
        } while (precisionBits -= startBit);
        this._pos += size;
        return exponent === (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
      }
      _decodeInt(bits, signed) {
        const x = this._readBits(0, bits, bits / 8);
        const max = Math.pow(2, bits);
        const result = signed && x >= max / 2 ? x - max : x;
        this._pos += bits / 8;
        return result;
      }
      // shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
      _shl(a, b) {
        for (++b; --b; a = ((a %= 2147483647 + 1) & 1073741824) === 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1)
          ;
        return a;
      }
      _readByte(i, size) {
        return this._buffer.charCodeAt(this._pos + size - i - 1) & 255;
      }
      _readBits(start, length, size) {
        const offsetLeft = (start + length) % 8;
        const offsetRight = start % 8;
        const curByte = size - (start >> 3) - 1;
        let lastByte = size + (-(start + length) >> 3);
        let diff = curByte - lastByte;
        let sum = this._readByte(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
        if (diff && offsetLeft) {
          sum += (this._readByte(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight;
        }
        while (diff) {
          sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
        }
        return sum;
      }
      _checkSize(neededBits) {
        if (!(this._pos + Math.ceil(neededBits / 8) < this._buffer.length)) {
        }
      }
    };
    module.exports = BinaryReader;
  }
});

// node_modules/@jscad/io-utils/index.js
var require_io_utils = __commonJS({
  "node_modules/@jscad/io-utils/index.js"(exports, module) {
    module.exports = {
      convertToBlob: require_convertToBlob(),
      makeBlob: require_makeBlob(),
      BinaryReader: require_BinaryReader(),
      Blob: require_Blob()
    };
  }
});

// node_modules/@jscad/amf-serializer/node_modules/onml/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@jscad/amf-serializer/node_modules/onml/lib/stringify.js"(exports, module) {
    "use strict";
    var isObject = (o) => o && Object.prototype.toString.call(o) === "[object Object]";
    function indenter(indentation) {
      if (!(indentation > 0)) {
        return (txt) => txt;
      }
      var space = " ".repeat(indentation);
      return (txt) => {
        if (typeof txt !== "string") {
          return txt;
        }
        const arr = txt.split("\n");
        if (arr.length === 1) {
          return space + txt;
        }
        return arr.map((e) => e.trim() === "" ? e : space + e).join("\n");
      };
    }
    var clean = (txt) => txt.split("\n").filter((e) => e.trim() !== "").join("\n");
    function stringify(a, indentation) {
      const cr = indentation > 0 ? "\n" : "";
      const indent = indenter(indentation);
      function rec(a2) {
        let body = "";
        let isFlat = true;
        let res;
        const isEmpty = a2.some((e, i, arr) => {
          if (i === 0) {
            res = "<" + e;
            return arr.length === 1;
          }
          if (i === 1) {
            if (isObject(e)) {
              Object.keys(e).map((key) => {
                let val = e[key];
                if (Array.isArray(val)) {
                  val = val.join(" ");
                }
                res += " " + key + '="' + val + '"';
              });
              if (arr.length === 2) {
                return true;
              }
              res += ">";
              return;
            }
            res += ">";
          }
          switch (typeof e) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
              body += e + cr;
              return;
          }
          isFlat = false;
          body += rec(e);
        });
        if (isEmpty) {
          return res + "/>" + cr;
        }
        return isFlat ? res + clean(body) + "</" + a2[0] + ">" + cr : res + cr + indent(body) + "</" + a2[0] + ">" + cr;
      }
      return rec(a);
    }
    module.exports = stringify;
  }
});

// node_modules/@jscad/array-utils/src/flatten.js
var require_flatten = __commonJS({
  "node_modules/@jscad/array-utils/src/flatten.js"(exports, module) {
    var flatten = (arr) => arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);
    module.exports = flatten;
  }
});

// node_modules/@jscad/array-utils/src/fnNumberSort.js
var require_fnNumberSort = __commonJS({
  "node_modules/@jscad/array-utils/src/fnNumberSort.js"(exports, module) {
    var fnNumberSort = (a, b) => a - b;
    module.exports = fnNumberSort;
  }
});

// node_modules/@jscad/array-utils/src/head.js
var require_head = __commonJS({
  "node_modules/@jscad/array-utils/src/head.js"(exports, module) {
    var head = (array) => {
      if (!Array.isArray(array) || array.length === 0) {
        return void 0;
      }
      return array[0];
    };
    module.exports = head;
  }
});

// node_modules/@jscad/array-utils/src/insertSorted.js
var require_insertSorted = __commonJS({
  "node_modules/@jscad/array-utils/src/insertSorted.js"(exports, module) {
    var insertSorted = (array, element, compareFunction) => {
      let leftbound = 0;
      let rightbound = array.length;
      while (rightbound > leftbound) {
        const testindex = Math.floor((leftbound + rightbound) / 2);
        const testelement = array[testindex];
        const compareresult = compareFunction(element, testelement);
        if (compareresult > 0) {
          leftbound = testindex + 1;
        } else {
          rightbound = testindex;
        }
      }
      array.splice(leftbound, 0, element);
      return array;
    };
    module.exports = insertSorted;
  }
});

// node_modules/@jscad/array-utils/src/nth.js
var require_nth = __commonJS({
  "node_modules/@jscad/array-utils/src/nth.js"(exports, module) {
    var nth = (array, index) => {
      if (!Array.isArray(array) || array.length < index) {
        return void 0;
      }
      return array[index];
    };
    module.exports = nth;
  }
});

// node_modules/@jscad/array-utils/src/padToLength.js
var require_padToLength = __commonJS({
  "node_modules/@jscad/array-utils/src/padToLength.js"(exports, module) {
    var padToLength = (anArray, padding, targetLength) => {
      anArray = anArray.slice();
      while (anArray.length < targetLength) {
        anArray.push(padding);
      }
      return anArray;
    };
    module.exports = padToLength;
  }
});

// node_modules/@jscad/array-utils/src/toArray.js
var require_toArray = __commonJS({
  "node_modules/@jscad/array-utils/src/toArray.js"(exports, module) {
    var toArray = (array) => {
      if (Array.isArray(array))
        return array;
      if (array === void 0 || array === null)
        return [];
      return [array];
    };
    module.exports = toArray;
  }
});

// node_modules/@jscad/array-utils/src/index.js
var require_src2 = __commonJS({
  "node_modules/@jscad/array-utils/src/index.js"(exports, module) {
    module.exports = {
      flatten: require_flatten(),
      fnNumberSort: require_fnNumberSort(),
      head: require_head(),
      insertSorted: require_insertSorted(),
      nth: require_nth(),
      padToLength: require_padToLength(),
      toArray: require_toArray()
    };
  }
});

// node_modules/@jscad/amf-serializer/index.js
var require_amf_serializer = __commonJS({
  "node_modules/@jscad/amf-serializer/index.js"(exports, module) {
    var stringify = require_stringify();
    var { geometries, modifiers } = require_src();
    var { flatten, toArray } = require_src2();
    var mimeType = "application/amf+xml";
    var serialize = (options, ...objects) => {
      const defaults = {
        statusCallback: null,
        unit: "millimeter"
        // millimeter, inch, feet, meter or micrometer
      };
      options = Object.assign({}, defaults, options);
      objects = flatten(objects);
      let objects3d = objects.filter((object) => geometries.geom3.isA(object));
      if (objects3d.length === 0)
        throw new Error("only 3D geometries can be serialized to AMF");
      if (objects.length !== objects3d.length)
        console.warn("some objects could not be serialized to AMF");
      objects3d = toArray(modifiers.generalize({ snap: true, triangulate: true }, objects3d));
      options.statusCallback && options.statusCallback({ progress: 0 });
      let body = [
        "amf",
        {
          unit: options.unit,
          version: "1.1"
        },
        ["metadata", { type: "author" }, "Created by JSCAD"]
      ];
      body = body.concat(translateObjects(objects3d, options));
      const amf = `<?xml version="1.0" encoding="UTF-8"?>
${stringify(body, 2)}`;
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return [amf];
    };
    var translateObjects = (objects, options) => {
      const contents = [];
      objects.forEach((object, i) => {
        const polygons = geometries.geom3.toPolygons(object);
        if (polygons.length > 0) {
          options.id = i;
          contents.push(convertToObject(object, options));
        }
      });
      return contents;
    };
    var convertToObject = (object, options) => {
      const contents = ["object", { id: options.id }, convertToMesh(object, options)];
      return contents;
    };
    var convertToMesh = (object, options) => {
      let contents = ["mesh", {}, convertToVertices(object, options)];
      contents = contents.concat(convertToVolumes(object, options));
      return contents;
    };
    var convertToVertices = (object, options) => {
      const contents = ["vertices", {}];
      const vertices = [];
      const polygons = geometries.geom3.toPolygons(object);
      polygons.forEach((polygon) => {
        for (let i = 0; i < polygon.vertices.length; i++) {
          vertices.push(convertToVertex(polygon.vertices[i], options));
        }
      });
      return contents.concat(vertices);
    };
    var convertToVertex = (vertex, options) => {
      const contents = ["vertex", {}, convertToCoordinates(vertex, options)];
      return contents;
    };
    var convertToCoordinates = (vertex, options) => {
      const contents = ["coordinates", {}, ["x", {}, vertex[0]], ["y", {}, vertex[1]], ["z", {}, vertex[2]]];
      return contents;
    };
    var convertToVolumes = (object, options) => {
      const objectcolor = convertColor(object.color);
      const polygons = geometries.geom3.toPolygons(object);
      const contents = [];
      let volume = ["volume", {}];
      if (objectcolor) {
        volume.push(objectcolor);
      }
      let vcount = 0;
      polygons.forEach((polygon) => {
        if (polygon.vertices.length < 3) {
          return;
        }
        const triangles = convertToTriangles(polygon, vcount, options);
        volume = volume.concat(triangles);
        vcount += polygon.vertices.length;
      });
      contents.push(volume);
      return contents;
    };
    var convertColor = (color) => {
      if (color) {
        if (color.length < 4)
          color.push(1);
        return ["color", {}, ["r", {}, color[0]], ["g", {}, color[1]], ["b", {}, color[2]], ["a", {}, color[3]]];
      }
      return null;
    };
    var convertToColor = (polygon, options) => {
      const color = polygon.color;
      return convertColor(color);
    };
    var convertToTriangles = (polygon, index, options) => {
      const polycolor = convertToColor(polygon, options);
      const contents = [];
      for (let i = 0; i < polygon.vertices.length - 2; i++) {
        if (polycolor) {
          contents.push(["triangle", {}, polycolor, ["v1", {}, index], ["v2", {}, index + i + 1], ["v3", {}, index + i + 2]]);
        } else {
          contents.push(["triangle", {}, ["v1", {}, index], ["v2", {}, index + i + 1], ["v3", {}, index + i + 2]]);
        }
      }
      return contents;
    };
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/@jscad/dxf-serializer/autocad_AC2017.js
var require_autocad_AC2017 = __commonJS({
  "node_modules/@jscad/dxf-serializer/autocad_AC2017.js"(exports, module) {
    var dxfHeaders = function() {
      const content = `  0
SECTION
  2
HEADER
  9
$ACADVER
  1
AC1027
  9
$ACADMAINTVER
 70
8
  9
$DWGCODEPAGE
  3
ANSI_1252
  9
$LASTSAVEDBY
  1
unknown
  9
$REQUIREDVERSIONS
160
0
  9
$INSBASE
 10
0.0
 20
0.0
 30
0.0
  9
$EXTMIN
 10
1e+20
 20
1e+20
 30
1e+20
  9
$EXTMAX
 10
-1e+20
 20
-1e+20
 30
-1e+20
  9
$LIMMIN
 10
0.0
 20
0.0
  9
$LIMMAX
 10
12.0
 20
9.0
  9
$ORTHOMODE
 70
0
  9
$REGENMODE
 70
1
  9
$FILLMODE
 70
1
  9
$QTEXTMODE
 70
0
  9
$MIRRTEXT
 70
0
  9
$LTSCALE
 40
1.0
  9
$ATTMODE
 70
1
  9
$TEXTSIZE
 40
0.2
  9
$TRACEWID
 40
0.05
  9
$TEXTSTYLE
  7
Notes
  9
$CLAYER
  8
0
  9
$CELTYPE
  6
ByLayer
  9
$CECOLOR
 62
256
  9
$CELTSCALE
 40
1.0
  9
$DISPSILH
 70
0
  9
$DIMSCALE
 40
1.0
  9
$DIMASZ
 40
3.0
  9
$DIMEXO
 40
1.5
  9
$DIMDLI
 40
6.0
  9
$DIMRND
 40
0.0
  9
$DIMDLE
 40
0.0
  9
$DIMEXE
 40
3.0
  9
$DIMTP
 40
0.0
  9
$DIMTM
 40
0.0
  9
$DIMTXT
 40
3.0
  9
$DIMCEN
 40
3.0
  9
$DIMTSZ
 40
0.0
  9
$DIMTOL
 70
0
  9
$DIMLIM
 70
0
  9
$DIMTIH
 70
0
  9
$DIMTOH
 70
0
  9
$DIMSE1
 70
0
  9
$DIMSE2
 70
0
  9
$DIMTAD
 70
1
  9
$DIMZIN
 70
3
  9
$DIMBLK
  1

  9
$DIMASO
 70
1
  9
$DIMSHO
 70
1
  9
$DIMPOST
  1

  9
$DIMAPOST
  1

  9
$DIMALT
 70
0
  9
$DIMALTD
 70
2
  9
$DIMALTF
 40
25.4
  9
$DIMLFAC
 40
1.0
  9
$DIMTOFL
 70
0
  9
$DIMTVP
 40
0.0
  9
$DIMTIX
 70
0
  9
$DIMSOXD
 70
0
  9
$DIMSAH
 70
0
  9
$DIMBLK1
  1

  9
$DIMBLK2
  1

  9
$DIMSTYLE
  2
Civil-Metric
  9
$DIMCLRD
 70
0
  9
$DIMCLRE
 70
0
  9
$DIMCLRT
 70
0
  9
$DIMTFAC
 40
1.0
  9
$DIMGAP
 40
2.0
  9
$DIMJUST
 70
0
  9
$DIMSD1
 70
0
  9
$DIMSD2
 70
0
  9
$DIMTOLJ
 70
1
  9
$DIMTZIN
 70
0
  9
$DIMALTZ
 70
0
  9
$DIMALTTZ
 70
0
  9
$DIMUPT
 70
0
  9
$DIMDEC
 70
2
  9
$DIMTDEC
 70
2
  9
$DIMALTU
 70
2
  9
$DIMALTTD
 70
2
  9
$DIMTXSTY
  7
Standard
  9
$DIMAUNIT
 70
0
  9
$DIMADEC
 70
2
  9
$DIMALTRND
 40
0.0
  9
$DIMAZIN
 70
2
  9
$DIMDSEP
 70
46
  9
$DIMATFIT
 70
3
  9
$DIMFRAC
 70
1
  9
$DIMLDRBLK
  1

  9
$DIMLUNIT
 70
2
  9
$DIMLWD
 70
-2
  9
$DIMLWE
 70
-2
  9
$DIMTMOVE
 70
0
  9
$DIMFXL
 40
1.0
  9
$DIMFXLON
 70
0
  9
$DIMJOGANG
 40
0.785398163397
  9
$DIMTFILL
 70
0
  9
$DIMTFILLCLR
 70
0
  9
$DIMARCSYM
 70
0
  9
$DIMLTYPE
  6

  9
$DIMLTEX1
  6

  9
$DIMLTEX2
  6

  9
$DIMTXTDIRECTION
 70
0
  9
$LUNITS
 70
2
  9
$LUPREC
 70
4
  9
$SKETCHINC
 40
0.1
  9
$FILLETRAD
 40
0.0
  9
$AUNITS
 70
4
  9
$AUPREC
 70
5
  9
$MENU
  1
.
  9
$ELEVATION
 40
0.0
  9
$PELEVATION
 40
0.0
  9
$THICKNESS
 40
0.0
  9
$LIMCHECK
 70
0
  9
$CHAMFERA
 40
0.0
  9
$CHAMFERB
 40
0.0
  9
$CHAMFERC
 40
0.0
  9
$CHAMFERD
 40
0.0
  9
$SKPOLY
 70
0
  9
$TDCREATE
 40
2457986.69756
  9
$TDUCREATE
 40
2455631.2632
  9
$TDUPDATE
 40
2457986.69756
  9
$TDUUPDATE
 40
2456436.43179
  9
$TDINDWG
 40
0.0003490741
  9
$TDUSRTIMER
 40
0.0003487153
  9
$USRTIMER
 70
1
  9
$ANGBASE
 50
0.0
  9
$ANGDIR
 70
0
  9
$PDMODE
 70
0
  9
$PDSIZE
 40
0.0
  9
$PLINEWID
 40
0.0
  9
$SPLFRAME
 70
0
  9
$SPLINETYPE
 70
6
  9
$SPLINESEGS
 70
8
  9
$HANDSEED
  5
5C7
  9
$SURFTAB1
 70
6
  9
$SURFTAB2
 70
6
  9
$SURFTYPE
 70
6
  9
$SURFU
 70
6
  9
$SURFV
 70
6
  9
$UCSBASE
  2

  9
$UCSNAME
  2

  9
$UCSORG
 10
0.0
 20
0.0
 30
0.0
  9
$UCSXDIR
 10
1.0
 20
0.0
 30
0.0
  9
$UCSYDIR
 10
0.0
 20
1.0
 30
0.0
  9
$UCSORTHOREF
  2

  9
$UCSORTHOVIEW
 70
0
  9
$UCSORGTOP
 10
0.0
 20
0.0
 30
0.0
  9
$UCSORGBOTTOM
 10
0.0
 20
0.0
 30
0.0
  9
$UCSORGLEFT
 10
0.0
 20
0.0
 30
0.0
  9
$UCSORGRIGHT
 10
0.0
 20
0.0
 30
0.0
  9
$UCSORGFRONT
 10
0.0
 20
0.0
 30
0.0
  9
$UCSORGBACK
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSBASE
  2

  9
$PUCSNAME
  2

  9
$PUCSORG
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSXDIR
 10
1.0
 20
0.0
 30
0.0
  9
$PUCSYDIR
 10
0.0
 20
1.0
 30
0.0
  9
$PUCSORTHOREF
  2

  9
$PUCSORTHOVIEW
 70
0
  9
$PUCSORGTOP
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSORGBOTTOM
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSORGLEFT
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSORGRIGHT
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSORGFRONT
 10
0.0
 20
0.0
 30
0.0
  9
$PUCSORGBACK
 10
0.0
 20
0.0
 30
0.0
  9
$USERI1
 70
0
  9
$USERI2
 70
0
  9
$USERI3
 70
0
  9
$USERI4
 70
0
  9
$USERI5
 70
0
  9
$USERR1
 40
0.0
  9
$USERR2
 40
0.0
  9
$USERR3
 40
0.0
  9
$USERR4
 40
0.0
  9
$USERR5
 40
0.0
  9
$WORLDVIEW
 70
1
  9
$SHADEDGE
 70
3
  9
$SHADEDIF
 70
70
  9
$TILEMODE
 70
1
  9
$MAXACTVP
 70
64
  9
$PINSBASE
 10
0.0
 20
0.0
 30
0.0
  9
$PLIMCHECK
 70
0
  9
$PEXTMIN
 10
0.628866766397
 20
0.799999952316
 30
0.0
  9
$PEXTMAX
 10
9.02886638493
 20
7.19999957085
 30
0.0
  9
$PLIMMIN
 10
-0.700541819174
 20
-0.228100386192
  9
$PLIMMAX
 10
10.2994579405
 20
8.27189937351
  9
$UNITMODE
 70
0
  9
$VISRETAIN
 70
1
  9
$PLINEGEN
 70
0
  9
$PSLTSCALE
 70
1
  9
$TREEDEPTH
 70
3020
  9
$CMLSTYLE
  2
Standard
  9
$CMLJUST
 70
0
  9
$CMLSCALE
 40
1.0
  9
$PROXYGRAPHICS
 70
1
  9
$MEASUREMENT
 70
1
  9
$CELWEIGHT
370
-1
  9
$ENDCAPS
280
0
  9
$JOINSTYLE
280
0
  9
$LWDISPLAY
290
0
  9
$INSUNITS
 70
4
  9
$HYPERLINKBASE
  1

  9
$STYLESHEET
  1

  9
$XEDIT
290
1
  9
$CEPSNTYPE
380
0
  9
$PSTYLEMODE
290
1
  9
$FINGERPRINTGUID
  2
{39DB1BDD-BC6C-46D3-A333-DFCC0DC4782D}
  9
$VERSIONGUID
  2
{69EEBB2D-7039-498F-9366-3F994E4A07E7}
  9
$EXTNAMES
290
1
  9
$PSVPSCALE
 40
0.0
  9
$OLESTARTUP
290
0
  9
$SORTENTS
280
127
  9
$INDEXCTL
280
0
  9
$HIDETEXT
280
1
  9
$XCLIPFRAME
280
0
  9
$HALOGAP
280
0
  9
$OBSCOLOR
 70
257
  9
$OBSLTYPE
280
0
  9
$INTERSECTIONDISPLAY
280
0
  9
$INTERSECTIONCOLOR
 70
257
  9
$DIMASSOC
280
2
  9
$PROJECTNAME
  1

  9
$CAMERADISPLAY
290
0
  9
$LENSLENGTH
 40
50.0
  9
$CAMERAHEIGHT
 40
0.0
  9
$STEPSPERSEC
 40
2.0
  9
$STEPSIZE
 40
6.0
  9
$3DDWFPREC
 40
2.0
  9
$PSOLWIDTH
 40
0.25
  9
$PSOLHEIGHT
 40
4.0
  9
$LOFTANG1
 40
1.57079632679
  9
$LOFTANG2
 40
1.57079632679
  9
$LOFTMAG1
 40
0.0
  9
$LOFTMAG2
 40
0.0
  9
$LOFTPARAM
 70
7
  9
$LOFTNORMALS
280
1
  9
$LATITUDE
 40
37.795
  9
$LONGITUDE
 40
-122.394
  9
$NORTHDIRECTION
 40
0.0
  9
$TIMEZONE
 70
-8000
  9
$LIGHTGLYPHDISPLAY
280
1
  9
$TILEMODELIGHTSYNCH
280
1
  9
$CMATERIAL
347
96
  9
$SOLIDHIST
280
1
  9
$SHOWHIST
280
1
  9
$DWFFRAME
280
2
  9
$DGNFRAME
280
0
  9
$REALWORLDSCALE
290
1
  9
$INTERFERECOLOR
 62
1
  9
$INTERFEREOBJVS
345
A3
  9
$INTERFEREVPVS
346
A0
  9
$CSHADOW
280
0
  9
$SHADOWPLANELOCATION
 40
0.0
  0
ENDSEC`;
      return content;
    };
    var dxfClasses = function() {
      const content = `  0
SECTION
  2
CLASSES
  0
CLASS
  1
ACDBDICTIONARYWDFLT
  2
AcDbDictionaryWithDefault
  3
ObjectDBX Classes
 90
0
 91
1
280
0
281
0
  0
CLASS
  1
DICTIONARYVAR
  2
AcDbDictionaryVar
  3
ObjectDBX Classes
 90
0
 91
15
280
0
281
0
  0
CLASS
  1
TABLESTYLE
  2
AcDbTableStyle
  3
ObjectDBX Classes
 90
4095
 91
1
280
0
281
0
  0
CLASS
  1
MATERIAL
  2
AcDbMaterial
  3
ObjectDBX Classes
 90
1153
 91
3
280
0
281
0
  0
CLASS
  1
VISUALSTYLE
  2
AcDbVisualStyle
  3
ObjectDBX Classes
 90
4095
 91
26
280
0
281
0
  0
CLASS
  1
SCALE
  2
AcDbScale
  3
ObjectDBX Classes
 90
1153
 91
17
280
0
281
0
  0
CLASS
  1
MLEADERSTYLE
  2
AcDbMLeaderStyle
  3
ACDB_MLEADERSTYLE_CLASS
 90
4095
 91
3
280
0
281
0
  0
CLASS
  1
CELLSTYLEMAP
  2
AcDbCellStyleMap
  3
ObjectDBX Classes
 90
1152
 91
2
280
0
281
0
  0
CLASS
  1
EXACXREFPANELOBJECT
  2
ExAcXREFPanelObject
  3
EXAC_ESW
 90
1025
 91
0
280
0
281
0
  0
CLASS
  1
NPOCOLLECTION
  2
AcDbImpNonPersistentObjectsCollection
  3
ObjectDBX Classes
 90
1153
 91
0
280
0
281
0
  0
CLASS
  1
LAYER_INDEX
  2
AcDbLayerIndex
  3
ObjectDBX Classes
 90
0
 91
0
280
0
281
0
  0
CLASS
  1
SPATIAL_INDEX
  2
AcDbSpatialIndex
  3
ObjectDBX Classes
 90
0
 91
0
280
0
281
0
  0
CLASS
  1
IDBUFFER
  2
AcDbIdBuffer
  3
ObjectDBX Classes
 90
0
 91
0
280
0
281
0
  0
CLASS
  1
DIMASSOC
  2
AcDbDimAssoc
  3
"AcDbDimAssoc|Product Desc:     AcDim ARX App For Dimension|Company:          Autodesk, Inc.|WEB Address:      www.autodesk.com"
 90
0
 91
0
280
0
281
0
  0
CLASS
  1
ACDBSECTIONVIEWSTYLE
  2
AcDbSectionViewStyle
  3
ObjectDBX Classes
 90
1025
 91
1
280
0
281
0
  0
CLASS
  1
ACDBDETAILVIEWSTYLE
  2
AcDbDetailViewStyle
  3
ObjectDBX Classes
 90
1025
 91
1
280
0
281
0
  0
CLASS
  1
IMAGEDEF
  2
AcDbRasterImageDef
  3
ISM
 90
0
 91
1
280
0
281
0
  0
CLASS
  1
RASTERVARIABLES
  2
AcDbRasterVariables
  3
ISM
 90
0
 91
1
280
0
281
0
  0
CLASS
  1
IMAGEDEF_REACTOR
  2
AcDbRasterImageDefReactor
  3
ISM
 90
1
 91
1
280
0
281
0
  0
CLASS
  1
IMAGE
  2
AcDbRasterImage
  3
ISM
 90
2175
 91
1
280
0
281
1
  0
CLASS
  1
PDFDEFINITION
  2
AcDbPdfDefinition
  3
ObjectDBX Classes
 90
1153
 91
1
280
0
281
0
  0
CLASS
  1
PDFUNDERLAY
  2
AcDbPdfReference
  3
ObjectDBX Classes
 90
4095
 91
1
280
0
281
1
  0
CLASS
  1
DWFDEFINITION
  2
AcDbDwfDefinition
  3
ObjectDBX Classes
 90
1153
 91
2
280
0
281
0
  0
CLASS
  1
DWFUNDERLAY
  2
AcDbDwfReference
  3
ObjectDBX Classes
 90
1153
 91
1
280
0
281
1
  0
CLASS
  1
DGNDEFINITION
  2
AcDbDgnDefinition
  3
ObjectDBX Classes
 90
1153
 91
2
280
0
281
0
  0
CLASS
  1
DGNUNDERLAY
  2
AcDbDgnReference
  3
ObjectDBX Classes
 90
1153
 91
1
280
0
281
1
  0
ENDSEC`;
      return content;
    };
    var dxfTables = function() {
      const content = `  0
SECTION
  2
TABLES
  0
TABLE
  2
VPORT
  5
8
330
0
100
AcDbSymbolTable
 70
0
  0
ENDTAB
  0
TABLE
  2
LTYPE
  5
5F
330
0
100
AcDbSymbolTable
 70
7
  0
LTYPE
  5
14
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
ByBlock
 70
0
  3

 72
65
 73
0
 40
0.0
  0
LTYPE
  5
15
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
ByLayer
 70
0
  3

 72
65
 73
0
 40
0.0
  0
LTYPE
  5
16
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
Continuous
 70
0
  3
Solid line
 72
65
 73
0
 40
0.0
  0
LTYPE
  5
1B1
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
CENTER
 70
0
  3
Center ____ _ ____ _ ____ _ ____ _ ____ _ ____
 72
65
 73
4
 40
2.0
 49
1.25
 74
0
 49
-0.25
 74
0
 49
0.25
 74
0
 49
-0.25
 74
0
  0
LTYPE
  5
1B2
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
DASHED
 70
0
  3
Dashed __ __ __ __ __ __ __ __ __ __ __ __ __ _
 72
65
 73
2
 40
0.75
 49
0.5
 74
0
 49
-0.25
 74
0
  0
LTYPE
  5
1B3
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
PHANTOM
 70
0
  3
Phantom ______  __  __  ______  __  __  ______
 72
65
 73
6
 40
2.5
 49
1.25
 74
0
 49
-0.25
 74
0
 49
0.25
 74
0
 49
-0.25
 74
0
 49
0.25
 74
0
 49
-0.25
 74
0
  0
LTYPE
  5
39E
330
5F
100
AcDbSymbolTableRecord
100
AcDbLinetypeTableRecord
  2
HIDDEN
 70
0
  3
Hidden __ __ __ __ __ __ __ __ __ __ __ __ __ __
 72
65
 73
2
 40
9.525
 49
6.35
 74
0
 49
-3.175
 74
0
  0
ENDTAB
  0
TABLE
  2
LAYER
  5
2
330
0
100
AcDbSymbolTable
 70
3
  0
LAYER
  5
10
330
2
100
AcDbSymbolTableRecord
100
AcDbLayerTableRecord
  2
0
 70
0
  6
Continuous
370
-3
390
F
347
98
348
0
  0
LAYER
  5
1B4
330
2
100
AcDbSymbolTableRecord
100
AcDbLayerTableRecord
  2
View Port
 70
0
  6
Continuous
290
0
370
-3
390
F
347
98
348
0
  0
LAYER
  5
21D
330
2
100
AcDbSymbolTableRecord
100
AcDbLayerTableRecord
  2
Defpoints
 70
0
  6
Continuous
290
0
370
-3
390
F
347
98
348
0
  0
ENDTAB
  0
TABLE
  2
STYLE
  5
3
330
0
100
AcDbSymbolTable
 70
3
  0
STYLE
  5
11
330
3
100
AcDbSymbolTableRecord
100
AcDbTextStyleTableRecord
  2
Standard
 70
0
 40
0.0
 41
1.0
 50
0.0
 71
0
 42
0.2
  3
arial.ttf
  4

  0
STYLE
  5
DC
330
3
100
AcDbSymbolTableRecord
100
AcDbTextStyleTableRecord
  2
Annotative
 70
0
 40
0.0
 41
1.0
 50
0.0
 71
0
 42
0.2
  3
arial.ttf
  4

  0
STYLE
  5
178
330
3
100
AcDbSymbolTableRecord
100
AcDbTextStyleTableRecord
  2
Notes
 70
0
 40
3.0
 41
1.0
 50
0.0
 71
0
 42
0.2
  3
arial.ttf
  4

  0
ENDTAB
  0
TABLE
  2
VIEW
  5
6
330
0
100
AcDbSymbolTable
 70
0
  0
ENDTAB
  0
TABLE
  2
UCS
  5
7
330
0
100
AcDbSymbolTable
 70
0
  0
ENDTAB
  0
TABLE
  2
APPID
  5
9
330
0
100
AcDbSymbolTable
 70
12
  0
APPID
  5
12
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD
 70
0
  0
APPID
  5
DD
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
AcadAnnoPO
 70
0
  0
APPID
  5
DE
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
AcadAnnotative
 70
0
  0
APPID
  5
DF
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_DSTYLE_DIMJAG
 70
0
  0
APPID
  5
E0
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_DSTYLE_DIMTALN
 70
0
  0
APPID
  5
107
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_MLEADERVER
 70
0
  0
APPID
  5
1B5
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
AcAecLayerStandard
 70
0
  0
APPID
  5
1BA
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_EXEMPT_FROM_CAD_STANDARDS
 70
0
  0
APPID
  5
237
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_DSTYLE_DIMBREAK
 70
0
  0
APPID
  5
28E
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_PSEXT
 70
0
  0
APPID
  5
4B0
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
ACAD_NAV_VCDISPLAY
 70
0
  0
APPID
  5
4E3
330
9
100
AcDbSymbolTableRecord
100
AcDbRegAppTableRecord
  2
HATCHBACKGROUNDCOLOR
 70
0
  0
ENDTAB
  0
TABLE
  2
DIMSTYLE
  5
A
330
0
100
AcDbSymbolTable
 70
3
100
AcDbDimStyleTable
 71
3
340
242
340
27
340
E1
  0
DIMSTYLE
105
27
330
A
100
AcDbSymbolTableRecord
100
AcDbDimStyleTableRecord
  2
Standard
 70
0
 41
3.0
 42
2.0
 43
9.0
 44
5.0
140
3.0
141
2.0
147
2.0
340
11
1001
ACAD_DSTYLE_DIMJAG
1070
388
1040
38.0
1001
ACAD_DSTYLE_DIMBREAK
1070
391
1040
90.0
1001
ACAD_DSTYLE_DIMTALN
1070
392
1070
0
  0
DIMSTYLE
105
E1
330
A
100
AcDbSymbolTableRecord
100
AcDbDimStyleTableRecord
  2
Annotative
 70
0
 40
0.0
 41
3.0
 42
2.5
 43
10.0
 44
5.0
140
3.0
141
2.0
147
2.0
340
11
1001
AcadAnnotative
1000
AnnotativeData
1002
{
1070
1
1070
1
1002
}
1001
ACAD_DSTYLE_DIMJAG
1070
388
1040
38.0
1001
ACAD_DSTYLE_DIMBREAK
1070
391
1040
90.0
1001
ACAD_DSTYLE_DIMTALN
1070
392
1070
0
  0
DIMSTYLE
105
242
330
A
100
AcDbSymbolTableRecord
100
AcDbDimStyleTableRecord
  2
Civil-Metric
 70
0
 41
3.0
 42
1.5
 43
6.0
 44
3.0
 73
0
 74
0
 77
1
 78
3
 79
2
140
3.0
141
3.0
147
2.0
179
2
271
2
272
2
276
1
340
11
1001
ACAD_DSTYLE_DIMBREAK
1070
391
1040
3.0
1001
ACAD_DSTYLE_DIMJAG
1070
388
1040
38.0
1001
ACAD_DSTYLE_DIMTALN
1070
392
1070
0
  0
ENDTAB
  0
TABLE
  2
BLOCK_RECORD
  5
1
330
0
100
AcDbSymbolTable
 70
4
  0
BLOCK_RECORD
  5
1F
330
1
100
AcDbSymbolTableRecord
100
AcDbBlockTableRecord
  2
*Model_Space
340
530
 70
0
280
1
281
0
  0
BLOCK_RECORD
  5
58
330
1
100
AcDbSymbolTableRecord
100
AcDbBlockTableRecord
  2
*Paper_Space
340
531
 70
0
280
1
281
0
  0
BLOCK_RECORD
  5
238
330
1
100
AcDbSymbolTableRecord
100
AcDbBlockTableRecord
  2
_ArchTick
340
0
 70
0
280
1
281
0
  0
BLOCK_RECORD
  5
23C
330
1
100
AcDbSymbolTableRecord
100
AcDbBlockTableRecord
  2
_Open30
340
0
 70
0
280
1
281
0
  0
ENDTAB
  0
ENDSEC`;
      return content;
    };
    var dxfBlocks = function() {
      const content = `  0
SECTION
  2
BLOCKS
  0
BLOCK
  5
23A
330
238
100
AcDbEntity
  8
0
100
AcDbBlockBegin
  2
_ArchTick
 70
0
 10
0.0
 20
0.0
 30
0.0
  3
_ArchTick
  1

  0
ENDBLK
  5
23B
330
238
100
AcDbEntity
  8
0
100
AcDbBlockEnd
  0
BLOCK
  5
20
330
1F
100
AcDbEntity
  8
0
100
AcDbBlockBegin
  2
*Model_Space
 70
0
 10
0.0
 20
0.0
 30
0.0
  3
*Model_Space
  1

  0
ENDBLK
  5
21
330
1F
100
AcDbEntity
  8
0
100
AcDbBlockEnd
  0
BLOCK
  5
5A
330
58
100
AcDbEntity
 67
1
  8
0
100
AcDbBlockBegin
  2
*Paper_Space
 70
0
 10
0.0
 20
0.0
 30
0.0
  3
*Paper_Space
  1

  0
ENDBLK
  5
5B
330
58
100
AcDbEntity
 67
1
  8
0
100
AcDbBlockEnd
  0
BLOCK
  5
240
330
23C
100
AcDbEntity
  8
0
100
AcDbBlockBegin
  2
_Open30
 70
0
 10
0.0
 20
0.0
 30
0.0
  3
_Open30
  1

  0
ENDBLK
  5
241
330
23C
100
AcDbEntity
  8
0
100
AcDbBlockEnd
  0
ENDSEC`;
      return content;
    };
    var dxfObjects = function() {
      const content = `  0
SECTION
  2
OBJECTS
  0
DICTIONARY
  5
C
330
0
100
AcDbDictionary
281
1
  3
ACAD_COLOR
350
524
  3
ACAD_GROUP
350
525
  3
ACAD_LAYOUT
350
526
  3
ACAD_MATERIAL
350
527
  3
ACAD_MLEADERSTYLE
350
528
  3
ACAD_MLINESTYLE
350
529
  3
ACAD_PLOTSETTINGS
350
52A
  3
ACAD_PLOTSTYLENAME
350
52C
  3
ACAD_SCALELIST
350
52D
  3
ACAD_TABLESTYLE
350
52E
  3
ACAD_VISUALSTYLE
350
52F
  0
DICTIONARY
  5
524
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
525
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
526
330
C
100
AcDbDictionary
281
1
  3
Model
350
530
  3
Layout1
350
531
  0
DICTIONARY
  5
527
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
528
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
529
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
52A
330
C
100
AcDbDictionary
281
1
  0
ACDBPLACEHOLDER
  5
52B
330
52C
  0
ACDBDICTIONARYWDFLT
  5
52C
330
C
100
AcDbDictionary
281
1
  3
Normal
350
52B
100
AcDbDictionaryWithDefault
340
52B
  0
DICTIONARY
  5
52D
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
52E
330
C
100
AcDbDictionary
281
1
  0
DICTIONARY
  5
52F
330
C
100
AcDbDictionary
281
1
  0
LAYOUT
  5
530
330
526
100
AcDbPlotSettings
  1

  2
DWFx ePlot (XPS Compatible).pc3
  4
ANSI_A_(8.50_x_11.00_Inches)
  6

 40
5.8
 41
17.8
 42
5.8
 43
17.8
 44
215.9
 45
279.4
 46
0.0
 47
0.0
 48
0.0
 49
0.0
140
0.0
141
0.0
142
1.0
143
14.53
 70
11952
 72
0
 73
1
 74
0
  7

 75
0
147
0.069
148
114.98
149
300.29
100
AcDbLayout
  1
Model
 70
1
 71
0
 10
0.0
 20
0.0
 11
12.0
 21
9.0
 12
0.0
 22
0.0
 32
0.0
 14
0.0
 24
0.0
 34
0.0
 15
0.0
 25
0.0
 35
0.0
146
0.0
 13
0.0
 23
0.0
 33
0.0
 16
1.0
 26
0.0
 36
0.0
 17
0.0
 27
1.0
 37
0.0
 76
0
330
1F
  0
LAYOUT
  5
531
330
526
100
AcDbPlotSettings
  1

  2
DWFx ePlot (XPS Compatible).pc3
  4
ANSI_A_(8.50_x_11.00_Inches)
  6

 40
5.8
 41
17.8
 42
5.8
 43
17.8
 44
215.9
 45
279.4
 46
0.0
 47
0.0
 48
0.0
 49
0.0
140
0.0
141
0.0
142
1.0
143
1.0
 70
688
 72
0
 73
1
 74
5
  7
acad.ctb
 75
16
147
1.0
148
0.0
149
0.0
100
AcDbLayout
  1
Layout1
 70
1
 71
1
 10
-0.7
 20
-0.23
 11
10.3
 21
8.27
 12
0.0
 22
0.0
 32
0.0
 14
0.63
 24
0.8
 34
0.0
 15
9.0
 25
7.2
 35
0.0
146
0.0
 13
0.0
 23
0.0
 33
0.0
 16
1.0
 26
0.0
 36
0.0
 17
0.0
 27
1.0
 37
0.0
 76
0
330
58
  0
ENDSEC`;
      return content;
    };
    module.exports = {
      dxfHeaders,
      dxfClasses,
      dxfTables,
      dxfBlocks,
      dxfObjects
    };
  }
});

// node_modules/@jscad/dxf-serializer/colorindex2017.js
var require_colorindex2017 = __commonJS({
  "node_modules/@jscad/dxf-serializer/colorindex2017.js"(exports, module) {
    var colorIndex = [
      [0, 0, 0, 255],
      // index 0, added for easy maintenance
      // 1
      [255, 0, 0, 255],
      [255, 255, 0, 255],
      [0, 255, 0, 255],
      [0, 255, 255, 255],
      [0, 0, 255, 255],
      [255, 0, 255, 255],
      [255, 255, 255, 255],
      [128, 128, 128, 255],
      [192, 192, 192, 255],
      [255, 0, 0, 255],
      // 11
      [255, 127, 127, 255],
      [165, 0, 0, 255],
      [165, 82, 82, 255],
      [127, 0, 0, 255],
      [127, 63, 63, 255],
      [76, 0, 0, 255],
      [76, 38, 38, 255],
      [38, 0, 0, 255],
      [38, 19, 19, 255],
      [255, 63, 0, 255],
      // 21
      [255, 159, 127, 255],
      [165, 41, 0, 255],
      [165, 103, 82, 255],
      [127, 31, 0, 255],
      [127, 79, 63, 255],
      [76, 19, 0, 255],
      [76, 47, 38, 255],
      [38, 9, 0, 255],
      [38, 28, 19, 255],
      [255, 127, 0, 255],
      // 31
      [255, 191, 127, 255],
      [165, 82, 0, 255],
      [165, 124, 82, 255],
      [127, 63, 0, 255],
      [127, 95, 63, 255],
      [76, 38, 0, 255],
      [76, 57, 38, 255],
      [38, 19, 0, 255],
      [38, 28, 19, 255],
      [255, 191, 0, 255],
      // 41
      [255, 223, 127, 255],
      [165, 124, 0, 255],
      [165, 145, 82, 255],
      [127, 95, 0, 255],
      [127, 111, 63, 255],
      [76, 57, 0, 255],
      [76, 66, 38, 255],
      [38, 28, 0, 255],
      [38, 33, 19, 255],
      [255, 255, 0, 255],
      // 51
      [255, 255, 127, 255],
      [165, 165, 0, 255],
      [165, 165, 82, 255],
      [127, 127, 0, 255],
      [127, 127, 63, 255],
      [76, 76, 0, 255],
      [76, 76, 38, 255],
      [38, 38, 0, 255],
      [38, 38, 19, 255],
      [191, 255, 0, 255],
      // 61
      [223, 255, 127, 255],
      [124, 165, 0, 255],
      [145, 165, 82, 255],
      [95, 127, 0, 255],
      [111, 127, 63, 255],
      [57, 76, 0, 255],
      [66, 76, 38, 255],
      [28, 38, 0, 255],
      [33, 38, 19, 255],
      [127, 255, 0, 255],
      // 71
      [191, 255, 127, 255],
      [82, 165, 0, 255],
      [124, 165, 82, 255],
      [63, 127, 0, 255],
      [95, 127, 63, 255],
      [38, 76, 0, 255],
      [57, 76, 38, 255],
      [19, 38, 0, 255],
      [28, 38, 19, 255],
      [63, 255, 0, 255],
      // 81
      [159, 255, 127, 255],
      [41, 165, 0, 255],
      [103, 165, 82, 255],
      [31, 127, 0, 255],
      [79, 127, 63, 255],
      [19, 76, 0, 255],
      [47, 76, 38, 255],
      [9, 38, 0, 255],
      [23, 38, 19, 255],
      [0, 255, 0, 255],
      // 91
      [125, 255, 127, 255],
      [0, 165, 0, 255],
      [82, 165, 82, 255],
      [0, 127, 0, 255],
      [63, 127, 63, 255],
      [0, 76, 0, 255],
      [38, 76, 38, 255],
      [0, 38, 0, 255],
      [19, 38, 19, 255],
      [0, 255, 63, 255],
      // 101
      [127, 255, 159, 255],
      [0, 165, 41, 255],
      [82, 165, 103, 255],
      [0, 127, 31, 255],
      [63, 127, 79, 255],
      [0, 76, 19, 255],
      [38, 76, 47, 255],
      [0, 38, 9, 255],
      [19, 88, 23, 255],
      [0, 255, 127, 255],
      // 111
      [127, 255, 191, 255],
      [0, 165, 82, 255],
      [82, 165, 124, 255],
      [0, 127, 63, 255],
      [63, 127, 95, 255],
      [0, 76, 38, 255],
      [38, 76, 57, 255],
      [0, 38, 19, 255],
      [19, 88, 28, 255],
      [0, 255, 191, 255],
      // 121
      [127, 255, 223, 255],
      [0, 165, 124, 255],
      [82, 165, 145, 255],
      [0, 127, 95, 255],
      [63, 127, 111, 255],
      [0, 76, 57, 255],
      [38, 76, 66, 255],
      [0, 38, 28, 255],
      [19, 88, 88, 255],
      [0, 255, 255, 255],
      // 131
      [127, 255, 255, 255],
      [0, 165, 165, 255],
      [82, 165, 165, 255],
      [0, 127, 127, 255],
      [63, 127, 127, 255],
      [0, 76, 76, 255],
      [38, 76, 76, 255],
      [0, 38, 38, 255],
      [19, 88, 88, 255],
      [0, 191, 255, 255],
      // 141
      [127, 223, 255, 255],
      [0, 124, 165, 255],
      [82, 145, 165, 255],
      [0, 95, 127, 255],
      [63, 111, 217, 255],
      [0, 57, 76, 255],
      [38, 66, 126, 255],
      [0, 28, 38, 255],
      [19, 88, 88, 255],
      [0, 127, 255, 255],
      // 151
      [127, 191, 255, 255],
      [0, 82, 165, 255],
      [82, 124, 165, 255],
      [0, 63, 127, 255],
      [63, 95, 127, 255],
      [0, 38, 76, 255],
      [38, 57, 126, 255],
      [0, 19, 38, 255],
      [19, 28, 88, 255],
      [0, 63, 255, 255],
      // 161
      [127, 159, 255, 255],
      [0, 41, 165, 255],
      [82, 103, 165, 255],
      [0, 31, 127, 255],
      [63, 79, 127, 255],
      [0, 19, 76, 255],
      [38, 47, 126, 255],
      [0, 9, 38, 255],
      [19, 23, 88, 255],
      [0, 0, 255, 255],
      // 171
      [127, 127, 255, 255],
      [0, 0, 165, 255],
      [82, 82, 165, 255],
      [0, 0, 127, 255],
      [63, 63, 127, 255],
      [0, 0, 76, 255],
      [38, 38, 126, 255],
      [0, 0, 38, 255],
      [19, 19, 88, 255],
      [63, 0, 255, 255],
      // 181
      [159, 127, 255, 255],
      [41, 0, 165, 255],
      [103, 82, 165, 255],
      [31, 0, 127, 255],
      [79, 63, 127, 255],
      [19, 0, 76, 255],
      [47, 38, 126, 255],
      [9, 0, 38, 255],
      [23, 19, 88, 255],
      [127, 0, 255, 255],
      // 191
      [191, 127, 255, 255],
      [165, 0, 82, 255],
      [124, 82, 165, 255],
      [63, 0, 127, 255],
      [95, 63, 127, 255],
      [38, 0, 76, 255],
      [57, 38, 126, 255],
      [19, 0, 38, 255],
      [28, 19, 88, 255],
      [191, 0, 255, 255],
      // 201
      [223, 127, 255, 255],
      [124, 0, 165, 255],
      [142, 82, 165, 255],
      [95, 0, 127, 255],
      [111, 63, 127, 255],
      [57, 0, 76, 255],
      [66, 38, 76, 255],
      [28, 0, 38, 255],
      [88, 19, 88, 255],
      [255, 0, 255, 255],
      // 211
      [255, 127, 255, 255],
      [165, 0, 165, 255],
      [165, 82, 165, 255],
      [127, 0, 127, 255],
      [127, 63, 127, 255],
      [76, 0, 76, 255],
      [76, 38, 76, 255],
      [38, 0, 38, 255],
      [88, 19, 88, 255],
      [255, 0, 191, 255],
      // 221
      [255, 127, 223, 255],
      [165, 0, 124, 255],
      [165, 82, 145, 255],
      [127, 0, 95, 255],
      [127, 63, 111, 255],
      [76, 0, 57, 255],
      [76, 38, 66, 255],
      [38, 0, 28, 255],
      [88, 19, 88, 255],
      [255, 0, 127, 255],
      // 231
      [255, 127, 191, 255],
      [165, 0, 82, 255],
      [165, 82, 124, 255],
      [127, 0, 63, 255],
      [127, 63, 95, 255],
      [76, 0, 38, 255],
      [76, 38, 57, 255],
      [38, 0, 19, 255],
      [88, 19, 28, 255],
      [255, 0, 63, 255],
      // 241
      [255, 127, 159, 255],
      [165, 0, 41, 255],
      [165, 82, 103, 255],
      [127, 0, 31, 255],
      [127, 63, 79, 255],
      [76, 0, 19, 255],
      [76, 38, 47, 255],
      [38, 0, 9, 255],
      [88, 19, 23, 255],
      [0, 0, 0, 255],
      // 251
      [101, 101, 101, 255],
      [102, 102, 102, 255],
      [153, 153, 153, 255],
      [204, 204, 204, 255],
      [255, 255, 255, 255]
    ];
    module.exports = colorIndex;
  }
});

// node_modules/@jscad/dxf-serializer/index.js
var require_dxf_serializer = __commonJS({
  "node_modules/@jscad/dxf-serializer/index.js"(exports, module) {
    var { geometries, modifiers } = require_src();
    var { geom3, geom2, path2 } = geometries;
    var { flatten, toArray } = require_src2();
    var { dxfHeaders, dxfClasses, dxfTables, dxfBlocks, dxfObjects } = require_autocad_AC2017();
    var colorindex2017 = require_colorindex2017();
    var mimeType = "application/dxf";
    var serialize = (options, ...objects) => {
      const defaults = {
        geom2To: "lwpolyline",
        // or polyline
        geom3To: "3dface",
        // or polyline
        pathTo: "lwpolyline",
        statusCallback: null,
        colorIndex: colorindex2017
      };
      options = Object.assign({}, defaults, options);
      options.entityId = 0;
      objects = flatten(objects);
      objects = objects.filter((object) => geom3.isA(object) || geom2.isA(object) || path2.isA(object));
      if (objects.length === 0)
        throw new Error("only JSCAD geometries can be serialized to DXF");
      objects = toArray(modifiers.generalize({ snap: true, triangulate: true }, objects));
      const dxfContent = `999
Created by JSCAD
${dxfHeaders(options)}
${dxfClasses(options)}
${dxfTables(options)}
${dxfBlocks(options)}
${dxfEntities(objects, options)}
${dxfObjects(options)}
  0
EOF
`;
      return [dxfContent];
    };
    var dxfEntities = (objects, options) => {
      const entityContents = objects.map((object, i) => {
        if (geom2.isA(object)) {
          const color = object.color;
          const name = object.name;
          const outlines = geom2.toOutlines(object);
          const paths = outlines.map((outline) => ({ closed: true, points: outline, color, name }));
          if (options.geom2To === "polyline") {
            return PathsToPolyine(paths, options);
          }
          return PathsToLwpolyline(paths, options);
        }
        if (geom3.isA(object)) {
          if (options.geom3To === "polyline") {
            return PolygonsToPolyline(object, options);
          }
          return PolygonsTo3DFaces(object, options);
        }
        if (path2.isA(object)) {
          const color = object.color;
          const name = object.name;
          const path = { closed: object.isClosed, points: path2.toPoints(object), color, name };
          return PathsToLwpolyline([path], options);
        }
        return "";
      });
      let section = `  0
SECTION
  2
ENTITIES
`;
      entityContents.forEach((content) => {
        if (content) {
          section += content;
        }
      });
      section += `  0
ENDSEC`;
      return section;
    };
    var PathsToLwpolyline = (paths, options) => {
      options.statusCallback && options.statusCallback({ progress: 0 });
      let str = "";
      paths.forEach((path, i) => {
        if (path.points.length < 1)
          return;
        const numpointsClosed = path.points.length + (path.closed ? 1 : 0);
        str += `  0
LWPOLYLINE
  5
${getEntityId(options)}
  100
AcDbEntity
  3
${getName(path, options)}
  8
0
  67
0
  62
${getColorNumber(path, options)}
  100
AcDbPolyline
  90
${numpointsClosed}
  70
${path.closed ? 1 : 0}
`;
        for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
          let pointindexwrapped = pointindex;
          if (pointindexwrapped >= path.points.length)
            pointindexwrapped -= path.points.length;
          const point = path.points[pointindexwrapped];
          str += `  10
${point[0]}
  20
${point[1]}
`;
        }
        options.statusCallback && options.statusCallback({ progress: 100 * i / paths.length });
      });
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [str];
    };
    var PathsToPolyine = (paths, options) => {
      options.statusCallback && options.statusCallback({ progress: 0 });
      let str = "";
      paths.forEach((path, i) => {
        const numpointsClosed = path.points.length + (path.closed ? 1 : 0);
        str += `  0
POLYLINE
  5
${getEntityId(options)}
  100
AcDbEntity
  3
${getName(path, options)}
  8
0
  62
${getColorNumber(path, options)}
  100
AcDb2dPolyline
`;
        for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
          let pointindexwrapped = pointindex;
          if (pointindexwrapped >= path.points.length)
            pointindexwrapped -= path.points.length;
          const point = path.points[pointindexwrapped];
          str += `  0
VERTEX
  5
${getEntityId(options)}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb2dVertex
 10
${point[0]}
 20
${point[1]}
`;
        }
        str += `  0
SEQEND
  5
${getEntityId(options)}
  100
AcDbEntity
`;
        options.statusCallback && options.statusCallback({ progress: 100 * i / paths.length });
      });
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [str];
    };
    var PolygonsTo3DFaces = (object, options) => {
      options.statusCallback && options.statusCallback({ progress: 0 });
      let str = "";
      const polygons = geom3.toPolygons(object);
      const objectColor = getColorNumber(object, options);
      polygons.forEach((polygon, i) => {
        const polyColor = polygon.color ? getColorNumber(polygon, options) : objectColor;
        const triangles = polygonToTriangles(polygon);
        triangles.forEach((triangle, i2) => {
          str += triangleTo3DFaces(triangle, options, polyColor);
        });
      });
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [str];
    };
    var polygonToTriangles = (polygon) => {
      const length = polygon.vertices.length - 2;
      if (length < 1)
        return [];
      const pivot = polygon.vertices[0];
      const triangles = [];
      for (let i = 0; i < length; i++) {
        triangles.push([pivot, polygon.vertices[i + 1], polygon.vertices[i + 2]]);
      }
      return triangles;
    };
    var triangleTo3DFaces = (triangle, options, color) => {
      const corner10 = triangle[0];
      const corner11 = triangle[1];
      const corner12 = triangle[2];
      const corner13 = triangle[2];
      const str = `  0
3DFACE
  5
${getEntityId(options)}
  100
AcDbEntity
  8
0
  62
${color}
  100
AcDbFace
  70
0
  10
${corner10[0]}
  20
${corner10[1]}
  30
${corner10[2]}
  11
${corner11[0]}
  21
${corner11[1]}
  31
${corner11[2]}
  12
${corner12[0]}
  22
${corner12[1]}
  32
${corner12[2]}
  13
${corner13[0]}
  23
${corner13[1]}
  33
${corner13[2]}
`;
      return str;
    };
    var PolygonsToPolyline = (object, options) => {
      let str = "";
      const mesh = polygons2polyfaces(geom3.toPolygons(object));
      if (mesh.faces.length > 0) {
        str += `  0
POLYLINE
  5
${getEntityId(options)}
  100
AcDbEntity
  3
${getName(object, options)}
  8
0
  62
${getColorNumber(object, options)}
  100
AcDb3dPolyline
  70
64
  71
${mesh.vertices.length}
  72
${mesh.faces.length}
`;
        mesh.vertices.forEach((vertex) => {
          str += `  0
VERTEX
  5
${getEntityId(options)}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb3dPolylineVertex
  10
${vertex[0]}
  20
${vertex[1]}
  30
${vertex[2]}
  70
192
`;
        });
        mesh.faces.forEach((face) => {
          str += `  0
VERTEX
  5
${getEntityId(options)}
  100
AcDbEntity
  8
0
  100
AcDbVertex
  100
AcDb3dPolylineVertex
  10
0
  20
0
  30
0
  70
128
  71
${face[0]}
  72
${face[1]}
  73
${face[2]}
  74
${face[3]}
`;
        });
      }
      return [str];
    };
    var polygons2polyfaces = (polygons) => {
      const faces = [];
      const vertices = [];
      for (let i = 0; i < polygons.length; ++i) {
        const polygon = polygons[i];
        const face = [];
        for (let j = 0; j < polygon.vertices.length; ++j) {
          const vv = polygon.vertices[j];
          vertices.push([vv[0], vv[1], vv[2]]);
          face.push(vertices.length);
        }
        while (face.length < 4) {
          face.push(0);
        }
        faces.push(face);
      }
      return { faces, vertices };
    };
    var getEntityId = (options) => {
      options.entityId++;
      const padded = "00000" + options.entityId.toString(16).toUpperCase();
      return "CAD" + padded.substr(padded.length - 5);
    };
    var getName = (object, options) => {
      if (object.name)
        return object.name;
      const padded = "00000" + options.entityId.toString(16).toUpperCase();
      return "CAD" + padded.substr(padded.length - 5);
    };
    var getColorNumber = (object, options) => {
      let colorNumber = 256;
      if (object.color) {
        const r = Math.floor(object.color[0] * 255);
        const g = Math.floor(object.color[1] * 255);
        const b = Math.floor(object.color[2] * 255);
        const index = options.colorIndex;
        let closest = 255 + 255 + 255;
        for (let i = 1; i < index.length; i++) {
          const rgb = index[i];
          const diff = Math.abs(r - rgb[0]) + Math.abs(g - rgb[1]) + Math.abs(b - rgb[2]);
          if (diff < closest) {
            colorNumber = i;
            if (diff === 0)
              break;
            closest = diff;
          }
        }
      }
      return colorNumber;
    };
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/@jscad/json-serializer/index.js
var require_json_serializer = __commonJS({
  "node_modules/@jscad/json-serializer/index.js"(exports, module) {
    var { utils } = require_src();
    var replacer = (key, value) => {
      switch (key) {
        case "transforms":
        case "plane":
          return Array.from(value);
        case "points":
        case "vertices":
          return value.map((v) => Array.from(v));
        case "sides":
          return value.map((s) => [Array.from(s[0]), Array.from(s[1])]);
        default:
          break;
      }
      return value;
    };
    var serialize = (options, ...objects) => {
      const defaults = {
        statusCallback: null
      };
      options = Object.assign({}, defaults, options);
      objects = utils.flatten(objects);
      options.statusCallback && options.statusCallback({ progress: 0 });
      const notation = JSON.stringify(objects, replacer);
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [notation];
    };
    var mimeType = "application/json";
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/@jscad/obj-serializer/index.js
var require_obj_serializer = __commonJS({
  "node_modules/@jscad/obj-serializer/index.js"(exports, module) {
    var { colors, geometries, modifiers } = require_src();
    var { flatten, toArray } = require_src2();
    var mimeType = "application/object";
    var serialize = (options, ...objects) => {
      const defaults = {
        statusCallback: null,
        triangulate: true
        // OBJ file supports polygon faces, but triangulate by default for safety
      };
      options = Object.assign({}, defaults, options);
      objects = flatten(objects);
      let objects3d = objects.filter((object) => geometries.geom3.isA(object));
      if (objects3d.length === 0)
        throw new Error("only 3D geometries can be serialized to OBJ");
      if (objects.length !== objects3d.length)
        console.warn("some objects could not be serialized to OBJ");
      objects3d = toArray(modifiers.generalize({ snap: true, triangulate: options.triangulate }, objects3d));
      options.statusCallback && options.statusCallback({ progress: 0 });
      let body = "# Wavefront OBJ file generated by JSCAD\n";
      const vertices = [];
      let previousColor = "default";
      objects3d.forEach((object, i) => {
        options.statusCallback && options.statusCallback({ progress: 100 * i / objects3d.length });
        body += "\n";
        const objectColor = getColorName(object);
        const polygons = geometries.geom3.toPolygons(object).filter((p) => p.vertices.length >= 3);
        polygons.forEach((polygon) => {
          polygon.vertices.forEach((vertex) => {
            const vertexString = convertVertex(vertex);
            if (vertices.indexOf(vertexString) < 0) {
              vertices.push(vertexString);
              body += `${vertexString}
`;
            }
          });
        });
        body += "\n";
        polygons.forEach((polygon) => {
          const indices = polygon.vertices.map((v) => vertices.indexOf(convertVertex(v)) + 1);
          const color = getColorName(polygon) || objectColor || "default";
          if (color !== previousColor) {
            body += `usemtl ${color}
`;
            previousColor = color;
          }
          body += `f ${indices.join(" ")}
`;
        });
      });
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [body];
    };
    var convertVertex = (vertex) => `v ${vertex[0]} ${vertex[1]} ${vertex[2]}`;
    var getColorName = (object) => {
      let colorName;
      if (object.color) {
        const r = object.color[0];
        const g = object.color[1];
        const b = object.color[2];
        let closest = 255 + 255 + 255;
        for (const name in colors.cssColors) {
          const rgb = colors.cssColors[name];
          const diff = Math.abs(r - rgb[0]) + Math.abs(g - rgb[1]) + Math.abs(b - rgb[2]);
          if (diff < closest) {
            colorName = name;
            if (diff === 0)
              break;
            closest = diff;
          }
        }
      }
      return colorName;
    };
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/@jscad/stl-serializer/CSGToStlb.js
var require_CSGToStlb = __commonJS({
  "node_modules/@jscad/stl-serializer/CSGToStlb.js"(exports, module) {
    var { geometries } = require_src();
    var serializeBinary = (objects, options) => {
      options.statusCallback && options.statusCallback({ progress: 0 });
      const buffer = new ArrayBuffer(4);
      const int32buffer = new Int32Array(buffer, 0, 1);
      const int8buffer = new Int8Array(buffer, 0, 4);
      int32buffer[0] = 287454020;
      if (int8buffer[0] !== 68) {
        throw new Error("Binary STL output is currently only supported on little-endian (Intel) processors");
      }
      let numtriangles = 0;
      let numpolygons = 0;
      objects.forEach((object, i) => {
        const polygons = geometries.geom3.toPolygons(object);
        polygons.forEach((polygon) => {
          const numvertices = polygon.vertices.length;
          const thisnumtriangles = numvertices >= 3 ? numvertices - 2 : 0;
          numtriangles += thisnumtriangles;
          numpolygons += 1;
        });
      });
      const headerarray = new Uint8Array(80);
      for (let i = 0; i < 80; i++) {
        headerarray[i] = 65;
      }
      const ar1 = new Uint32Array(1);
      ar1[0] = numtriangles;
      const allTrianglesBuffer = new ArrayBuffer(50 * numtriangles);
      const allTrianglesBufferAsInt8 = new Int8Array(allTrianglesBuffer);
      const triangleBuffer = new ArrayBuffer(50);
      const triangleBufferAsInt8 = new Int8Array(triangleBuffer);
      const triangleFloat32array = new Float32Array(triangleBuffer, 0, 12);
      const triangleUint16array = new Uint16Array(triangleBuffer, 48, 1);
      let byteoffset = 0;
      objects.forEach((object) => {
        const polygons = geometries.geom3.toPolygons(object);
        polygons.forEach((polygon, index) => {
          const vertices = polygon.vertices;
          const numvertices = vertices.length;
          const plane = geometries.poly3.plane(polygon);
          for (let i = 0; i < numvertices - 2; i++) {
            triangleFloat32array[0] = plane[0];
            triangleFloat32array[1] = plane[1];
            triangleFloat32array[2] = plane[2];
            let arindex = 3;
            for (let v = 0; v < 3; v++) {
              const vv = v + (v > 0 ? i : 0);
              const vertex = vertices[vv];
              triangleFloat32array[arindex++] = vertex[0];
              triangleFloat32array[arindex++] = vertex[1];
              triangleFloat32array[arindex++] = vertex[2];
            }
            triangleUint16array[0] = 0;
            allTrianglesBufferAsInt8.set(triangleBufferAsInt8, byteoffset);
            byteoffset += 50;
          }
          options.statusCallback && options.statusCallback({ progress: 100 * index / numpolygons });
        });
      });
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [headerarray.buffer, ar1.buffer, allTrianglesBuffer];
    };
    module.exports = {
      serializeBinary
    };
  }
});

// node_modules/@jscad/stl-serializer/CSGToStla.js
var require_CSGToStla = __commonJS({
  "node_modules/@jscad/stl-serializer/CSGToStla.js"(exports, module) {
    var { geometries } = require_src();
    var serializeText = (objects, options) => {
      options.statusCallback && options.statusCallback({ progress: 0 });
      const result = `solid JSCAD
${convertToStl(objects, options)}
endsolid JSCAD
`;
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [result];
    };
    var convertToStl = (objects, options) => {
      const result = [];
      objects.forEach((object, i) => {
        result.push(convertToFacets(object, options));
        options.statusCallback && options.statusCallback({ progress: 100 * i / objects.length });
      });
      return result.join("\n");
    };
    var convertToFacets = (object, options) => {
      const result = [];
      const polygons = geometries.geom3.toPolygons(object);
      polygons.forEach((polygon, i) => {
        result.push(convertToFacet(polygon));
      });
      return result.join("\n");
    };
    var vector3DtoStlString = (v) => `${v[0]} ${v[1]} ${v[2]}`;
    var vertextoStlString = (vertex) => `vertex ${vector3DtoStlString(vertex)}`;
    var convertToFacet = (polygon) => {
      const result = [];
      if (polygon.vertices.length >= 3) {
        const firstVertexStl = vertextoStlString(polygon.vertices[0]);
        for (let i = 0; i < polygon.vertices.length - 2; i++) {
          const facet = `facet normal ${vector3DtoStlString(geometries.poly3.plane(polygon))}
outer loop
${firstVertexStl}
${vertextoStlString(polygon.vertices[i + 1])}
${vertextoStlString(polygon.vertices[i + 2])}
endloop
endfacet`;
          result.push(facet);
        }
      }
      return result.join("\n");
    };
    module.exports = {
      serializeText
    };
  }
});

// node_modules/@jscad/stl-serializer/index.js
var require_stl_serializer = __commonJS({
  "node_modules/@jscad/stl-serializer/index.js"(exports, module) {
    var { geometries, modifiers } = require_src();
    var { flatten, toArray } = require_src2();
    var { serializeBinary } = require_CSGToStlb();
    var { serializeText } = require_CSGToStla();
    var mimeType = "application/sla";
    var serialize = (options, ...objects) => {
      const defaults = {
        binary: true,
        statusCallback: null
      };
      options = Object.assign({}, defaults, options);
      objects = flatten(objects);
      let objects3d = objects.filter((object) => geometries.geom3.isA(object));
      if (objects3d.length === 0)
        throw new Error("only 3D geometries can be serialized to STL");
      if (objects.length !== objects3d.length)
        console.warn("some objects could not be serialized to STL");
      objects3d = toArray(modifiers.generalize({ snap: true, triangulate: true }, objects3d));
      return options.binary ? serializeBinary(objects3d, options) : serializeText(objects3d, options);
    };
    module.exports = {
      mimeType,
      serialize
    };
  }
});

// node_modules/@jscad/svg-serializer/node_modules/onml/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/@jscad/svg-serializer/node_modules/onml/lib/stringify.js"(exports, module) {
    "use strict";
    var isObject = (o) => o && Object.prototype.toString.call(o) === "[object Object]";
    function indenter(indentation) {
      if (!(indentation > 0)) {
        return (txt) => txt;
      }
      var space = " ".repeat(indentation);
      return (txt) => {
        if (typeof txt !== "string") {
          return txt;
        }
        const arr = txt.split("\n");
        if (arr.length === 1) {
          return space + txt;
        }
        return arr.map((e) => e.trim() === "" ? e : space + e).join("\n");
      };
    }
    var clean = (txt) => txt.split("\n").filter((e) => e.trim() !== "").join("\n");
    function stringify(a, indentation) {
      const cr = indentation > 0 ? "\n" : "";
      const indent = indenter(indentation);
      function rec(a2) {
        let body = "";
        let isFlat = true;
        let res;
        const isEmpty = a2.some((e, i, arr) => {
          if (i === 0) {
            res = "<" + e;
            return arr.length === 1;
          }
          if (i === 1) {
            if (isObject(e)) {
              Object.keys(e).map((key) => {
                let val = e[key];
                if (Array.isArray(val)) {
                  val = val.join(" ");
                }
                res += " " + key + '="' + val + '"';
              });
              if (arr.length === 2) {
                return true;
              }
              res += ">";
              return;
            }
            res += ">";
          }
          switch (typeof e) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
              body += e + cr;
              return;
          }
          isFlat = false;
          body += rec(e);
        });
        if (isEmpty) {
          return res + "/>" + cr;
        }
        return isFlat ? res + clean(body) + "</" + a2[0] + ">" + cr : res + cr + indent(body) + "</" + a2[0] + ">" + cr;
      }
      return rec(a);
    }
    module.exports = stringify;
  }
});

// node_modules/@jscad/svg-serializer/package.json
var require_package = __commonJS({
  "node_modules/@jscad/svg-serializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/svg-serializer",
      version: "2.3.13",
      description: "SVG Serializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m './tests/*.test.js'"
      },
      contributors: [
        {
          name: "Rene K. Mueller",
          url: "http://renekmueller.com"
        },
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "export",
        "serializer",
        "svg"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/modeling": "2.12.0",
        onml: "1.3.0"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/svg-serializer/index.js
var require_svg_serializer = __commonJS({
  "node_modules/@jscad/svg-serializer/index.js"(exports, module) {
    var { geometries, maths, measurements, utils } = require_src();
    var stringify = require_stringify2();
    var version = require_package().version;
    var mimeType = "image/svg+xml";
    var serialize = (options, ...objects) => {
      const defaults = {
        unit: "mm",
        // em | ex | px | in | cm | mm | pt | pc
        decimals: 1e4,
        version,
        statusCallback: null
      };
      options = Object.assign({}, defaults, options);
      objects = utils.flatten(objects);
      const objects2d = objects.filter((object) => geometries.geom2.isA(object) || geometries.path2.isA(object));
      if (objects2d.length === 0)
        throw new Error("only 2D geometries can be serialized to SVG");
      if (objects.length !== objects2d.length)
        console.warn("some objects could not be serialized to SVG");
      options.statusCallback && options.statusCallback({ progress: 0 });
      const bounds = getBounds(objects2d);
      let width = 0;
      let height = 0;
      if (bounds) {
        width = Math.round((bounds[1][0] - bounds[0][0]) * options.decimals) / options.decimals;
        height = Math.round((bounds[1][1] - bounds[0][1]) * options.decimals) / options.decimals;
      }
      let body = [
        "svg",
        {
          width: width + options.unit,
          height: height + options.unit,
          viewBox: "0 0 " + width + " " + height,
          fill: "none",
          "fill-rule": "evenodd",
          "stroke-width": "0.1px",
          version: "1.1",
          baseProfile: "tiny",
          xmlns: "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink"
        }
      ];
      if (bounds) {
        body = body.concat(convertObjects(objects2d, bounds, options));
      }
      const svg = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Created by JSCAD SVG Serializer -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Tiny//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-tiny.dtd">
${stringify(body, 2)}`;
      options.statusCallback && options.statusCallback({ progress: 100 });
      return [svg];
    };
    var getBounds = (objects) => {
      const allbounds = measurements.measureBoundingBox(objects);
      if (objects.length === 1)
        return allbounds;
      const sumofbounds = allbounds.reduce((sum, bounds) => {
        maths.vec3.min(sum[0], sum[0], bounds[0]);
        maths.vec3.max(sum[1], sum[1], bounds[1]);
        return sum;
      }, [[0, 0, 0], [0, 0, 0]]);
      return sumofbounds;
    };
    var convertObjects = (objects, bounds, options) => {
      const xoffset = 0 - bounds[0][0];
      const yoffset = 0 - bounds[1][1];
      const contents = [];
      objects.forEach((object, i) => {
        options.statusCallback && options.statusCallback({ progress: 100 * i / objects.length });
        if (geometries.geom2.isA(object)) {
          contents.push(convertGeom2(object, [xoffset, yoffset], options));
        }
        if (geometries.path2.isA(object)) {
          contents.push(convertPaths([object], [xoffset, yoffset], options));
        }
      });
      return contents;
    };
    var reflect = (x, y, px, py) => {
      const ox = x - px;
      const oy = y - py;
      if (x === px && y === px)
        return [x, y];
      if (x === px)
        return [x, py - oy];
      if (y === py)
        return [px - -ox, y];
      return [px - -ox, py - oy];
    };
    var convertGeom2 = (object, offsets, options) => {
      const outlines = geometries.geom2.toOutlines(object);
      const paths = outlines.map((outline) => geometries.path2.fromPoints({ closed: true }, outline));
      options.color = "black";
      if (object.color)
        options.color = convertColor(object.color);
      options.id = null;
      if (object.id)
        options.id = object.id;
      options.class = null;
      if (object.class)
        options.class = object.class;
      return convertToContinousPath(paths, offsets, options);
    };
    var convertToContinousPath = (paths, offsets, options) => {
      let instructions = "";
      paths.forEach((path) => instructions += convertPath(path, offsets, options));
      const d = { fill: options.color, d: instructions };
      if (options.id)
        d.id = options.id;
      if (options.class)
        d.class = options.class;
      return ["g", ["path", d]];
    };
    var convertPaths = (paths, offsets, options) => paths.reduce((res, path, i) => {
      const d = { d: convertPath(path, offsets, options) };
      if (path.color)
        d.stroke = convertColor(path.color);
      if (path.id)
        d.id = path.id;
      if (path.class)
        d.class = path.class;
      return res.concat([["path", d]]);
    }, ["g"]);
    var convertPath = (path, offsets, options) => {
      let str = "";
      const numpointsClosed = path.points.length + (path.isClosed ? 1 : 0);
      for (let pointindex = 0; pointindex < numpointsClosed; pointindex++) {
        let pointindexwrapped = pointindex;
        if (pointindexwrapped >= path.points.length)
          pointindexwrapped -= path.points.length;
        const point = path.points[pointindexwrapped];
        const offpoint = [point[0] + offsets[0], point[1] + offsets[1]];
        const svgpoint = reflect(offpoint[0], offpoint[1], 0, 0);
        const x = Math.round(svgpoint[0] * options.decimals) / options.decimals;
        const y = Math.round(svgpoint[1] * options.decimals) / options.decimals;
        if (pointindex > 0) {
          str += `L${x} ${y}`;
        } else {
          str += `M${x} ${y}`;
        }
      }
      return str;
    };
    var convertColor = (color) => `rgb(${color[0] * 255},${color[1] * 255},${color[2] * 255},${color[3] * 255})`;
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/@jscad/x3d-serializer/node_modules/onml/lib/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/@jscad/x3d-serializer/node_modules/onml/lib/stringify.js"(exports, module) {
    "use strict";
    var isObject = (o) => o && Object.prototype.toString.call(o) === "[object Object]";
    function indenter(indentation) {
      if (!(indentation > 0)) {
        return (txt) => txt;
      }
      var space = " ".repeat(indentation);
      return (txt) => {
        if (typeof txt !== "string") {
          return txt;
        }
        const arr = txt.split("\n");
        if (arr.length === 1) {
          return space + txt;
        }
        return arr.map((e) => e.trim() === "" ? e : space + e).join("\n");
      };
    }
    var clean = (txt) => txt.split("\n").filter((e) => e.trim() !== "").join("\n");
    function stringify(a, indentation) {
      const cr = indentation > 0 ? "\n" : "";
      const indent = indenter(indentation);
      function rec(a2) {
        let body = "";
        let isFlat = true;
        let res;
        const isEmpty = a2.some((e, i, arr) => {
          if (i === 0) {
            res = "<" + e;
            return arr.length === 1;
          }
          if (i === 1) {
            if (isObject(e)) {
              Object.keys(e).map((key) => {
                let val = e[key];
                if (Array.isArray(val)) {
                  val = val.join(" ");
                }
                res += " " + key + '="' + val + '"';
              });
              if (arr.length === 2) {
                return true;
              }
              res += ">";
              return;
            }
            res += ">";
          }
          switch (typeof e) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
              body += e + cr;
              return;
          }
          isFlat = false;
          body += rec(e);
        });
        if (isEmpty) {
          return res + "/>" + cr;
        }
        return isFlat ? res + clean(body) + "</" + a2[0] + ">" + cr : res + cr + indent(body) + "</" + a2[0] + ">" + cr;
      }
      return rec(a);
    }
    module.exports = stringify;
  }
});

// node_modules/@jscad/x3d-serializer/src/index.js
var require_src3 = __commonJS({
  "node_modules/@jscad/x3d-serializer/src/index.js"(exports, module) {
    var { geometries, modifiers } = require_src();
    var { geom2, geom3, path2, poly2, poly3 } = geometries;
    var { flatten } = require_src2();
    var stringify = require_stringify3();
    var mimeType = "model/x3d+xml";
    var defNames = /* @__PURE__ */ new Map();
    var serialize = (options, ...objects) => {
      const defaults = {
        color: [0, 0, 1, 1],
        // default colorRGBA specification
        shininess: 8 / 256,
        smooth: false,
        decimals: 1e3,
        metadata: true,
        unit: "millimeter",
        // millimeter, inch, feet, meter or micrometer
        statusCallback: null
      };
      options = Object.assign({}, defaults, options);
      objects = flatten(objects);
      objects = objects.filter((object) => geom3.isA(object) || geom2.isA(object) || path2.isA(object));
      if (objects.length === 0)
        throw new Error("expected one or more geom3/geom2/path2 objects");
      options.statusCallback && options.statusCallback({ progress: 0 });
      let body = [
        "X3D",
        {
          profile: "Interchange",
          version: "3.3",
          "xmlns:xsd": "http://www.w3.org/2001/XMLSchema-instance",
          "xsd:noNamespaceSchemaLocation": "http://www.web3d.org/specifications/x3d-3.3.xsd"
        }
      ];
      if (options.metadata) {
        body.push([
          "head",
          {},
          ["meta", { name: "creator", content: "Created by JSCAD" }],
          ["meta", { name: "reference", content: "https://www.openjscad.xyz" }],
          ["meta", { name: "created", content: (/* @__PURE__ */ new Date()).toISOString() }]
        ]);
      } else {
        body.push([
          "head",
          {},
          ["meta", { name: "creator", content: "Created by JSCAD" }]
        ]);
      }
      body = body.concat(convertObjects(objects, options));
      const contents = `<?xml version="1.0" encoding="UTF-8"?>
${stringify(body, 2)}`;
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return [contents];
    };
    var convertObjects = (objects, options) => {
      const shapes = [];
      objects.forEach((object, i) => {
        options.statusCallback && options.statusCallback({ progress: 100 * i / objects.length });
        if (geom3.isA(object)) {
          object = modifiers.generalize({ snap: true, triangulate: true }, object);
          const polygons = geom3.toPolygons(object);
          if (polygons.length > 0) {
            shapes.push(convertGeom3(object, options));
          }
        }
        if (geom2.isA(object)) {
          shapes.push(convertGeom2(object, options));
        }
        if (path2.isA(object)) {
          shapes.push(convertPath2(object, options));
        }
      });
      const transform = ["Transform", { rotation: "1 0 0 -1.5708" }, ...shapes];
      const scene = ["Scene", {}, transform];
      return [scene];
    };
    var convertPath2 = (object, options) => {
      const points = path2.toPoints(object).slice();
      if (points.length > 1 && object.isClosed)
        points.push(points[0]);
      const shape = ["Shape", shapeAttributes(object), convertPolyline2D(poly2.create(points), options)];
      if (object.color) {
        shape.push(convertAppearance(object, "emissiveColor", options));
      }
      return shape;
    };
    var convertGeom2 = (object, options) => {
      const outlines = geom2.toOutlines(object);
      const group = ["Group", {}];
      outlines.forEach((outline) => {
        if (outline.length > 1)
          outline.push(outline[0]);
        const shape = ["Shape", shapeAttributes(object), convertPolyline2D(poly2.create(outline), options)];
        if (object.color) {
          shape.push(convertAppearance(object, "emissiveColor", options));
        }
        group.push(shape);
      });
      return group;
    };
    var shapeAttributes = (object, attributes = {}) => {
      if (object.id) {
        Object.assign(attributes, { DEF: checkDefName(object.id) });
      }
      return attributes;
    };
    var checkDefName = (defName) => {
      const count = defNames.get(defName) || 0;
      defNames.set(defName, count + 1);
      if (count > 0)
        console.warn(`Warning: object.id set as DEF but not unique. ${defName} set ${count + 1} times.`);
      return defName;
    };
    var convertPolyline2D = (object, options) => {
      const lineSegments = object.vertices.map((p) => `${p[0]} ${p[1]}`).join(" ");
      return ["Polyline2D", { lineSegments }];
    };
    var convertAppearance = (object, colorField, options) => {
      const colorRGB = object.color.slice(0, 3);
      const color = colorRGB.join(" ");
      const transparency = roundToDecimals(1 - object.color[3], options);
      const materialFields = { [colorField]: color, transparency };
      if (colorField === "diffuseColor") {
        Object.assign(
          materialFields,
          { specularColor: "0.2 0.2 0.2", shininess: options.shininess }
        );
      }
      return ["Appearance", ["Material", materialFields]];
    };
    var convertGeom3 = (object, options) => {
      const shape = ["Shape", shapeAttributes(object), convertMesh(object, options)];
      let appearance = ["Appearance", {}, ["Material"]];
      if (object.color) {
        appearance = convertAppearance(object, "diffuseColor", options);
      }
      shape.push(appearance);
      return shape;
    };
    var convertMesh = (object, options) => {
      const mesh = convertToTriangles(object, options);
      const lists = polygons2coordinates(mesh, options);
      const indexList = lists[0].join(" ");
      const pointList = lists[1].join(" ");
      const colorList = lists[2].join(" ");
      const faceset = [
        "IndexedTriangleSet",
        { ccw: "true", colorPerVertex: "false", normalPerVertex: options.smooth, solid: "false", index: indexList },
        ["Coordinate", { point: pointList }]
      ];
      if (!object.color) {
        faceset.push(["Color", { color: colorList }]);
      }
      return faceset;
    };
    var convertToTriangles = (object, options) => {
      const triangles = [];
      const polygons = geom3.toPolygons(object);
      polygons.forEach((poly) => {
        const firstVertex = poly.vertices[0];
        for (let i = poly.vertices.length - 3; i >= 0; i--) {
          const triangle = poly3.fromPoints([
            firstVertex,
            poly.vertices[i + 1],
            poly.vertices[i + 2]
          ]);
          let color = options.color;
          if (object.color)
            color = object.color;
          if (poly.color)
            color = poly.color;
          triangle.color = color;
          triangles.push(triangle);
        }
      });
      return triangles;
    };
    var convertToColor = (polygon, options) => {
      let color = options.color;
      if (polygon.color)
        color = polygon.color;
      return `${color[0]} ${color[1]} ${color[2]}`;
    };
    var roundToDecimals = (float, options) => Math.round(float * options.decimals) / options.decimals;
    var polygons2coordinates = (polygons, options) => {
      const indexList = [];
      const pointList = [];
      const colorList = [];
      const vertexTagToCoordIndexMap = /* @__PURE__ */ new Map();
      polygons.forEach((polygon) => {
        const polygonVertexIndices = [];
        const numvertices = polygon.vertices.length;
        for (let i = 0; i < numvertices; i++) {
          const vertex = polygon.vertices[i];
          const id = `${vertex[0]},${vertex[1]},${vertex[2]}`;
          if (!vertexTagToCoordIndexMap.has(id)) {
            const x = roundToDecimals(vertex[0], options);
            const y = roundToDecimals(vertex[1], options);
            const z = roundToDecimals(vertex[2], options);
            pointList.push(`${x} ${y} ${z}`);
            vertexTagToCoordIndexMap.set(id, pointList.length - 1);
          }
          polygonVertexIndices.push(vertexTagToCoordIndexMap.get(id));
        }
        indexList.push(polygonVertexIndices.join(" "));
        colorList.push(convertToColor(polygon, options));
      });
      vertexTagToCoordIndexMap.clear();
      return [indexList, pointList, colorList];
    };
    module.exports = {
      serialize,
      mimeType
    };
  }
});

// node_modules/fflate/lib/worker.cjs
var require_worker = __commonJS({
  "node_modules/fflate/lib/worker.cjs"(exports) {
    "use strict";
    var ch2 = {};
    exports["default"] = function(c, id, msg, transfer, cb) {
      var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
      ], { type: "text/javascript" }))));
      w.onmessage = function(e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
          var err = new Error(ed[0]);
          err["code"] = ed[1];
          err.stack = ed[2];
          cb(err, null);
        } else
          cb(null, d);
      };
      w.postMessage(msg, transfer);
      return w;
    };
  }
});

// node_modules/fflate/lib/index.cjs
var require_lib = __commonJS({
  "node_modules/fflate/lib/index.cjs"(exports) {
    "use strict";
    var node_worker_1 = require_worker();
    var u8 = Uint8Array;
    var u16 = Uint16Array;
    var u32 = Uint32Array;
    var fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    var fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var freb = function(eb, start) {
      var b = new u16(31);
      for (var i2 = 0; i2 < 31; ++i2) {
        b[i2] = start += 1 << eb[i2 - 1];
      }
      var r = new u32(b[30]);
      for (var i2 = 1; i2 < 30; ++i2) {
        for (var j = b[i2]; j < b[i2 + 1]; ++j) {
          r[j] = j - b[i2] << 5 | i2;
        }
      }
      return [b, r];
    };
    var _a = freb(fleb, 2);
    var fl = _a[0];
    var revfl = _a[1];
    fl[28] = 258, revfl[258] = 28;
    var _b = freb(fdeb, 0);
    var fd = _b[0];
    var revfd = _b[1];
    var rev = new u16(32768);
    for (i = 0; i < 32768; ++i) {
      x = (i & 43690) >>> 1 | (i & 21845) << 1;
      x = (x & 52428) >>> 2 | (x & 13107) << 2;
      x = (x & 61680) >>> 4 | (x & 3855) << 4;
      rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
    }
    var x;
    var i;
    var hMap = function(cd, mb, r) {
      var s = cd.length;
      var i2 = 0;
      var l = new u16(mb);
      for (; i2 < s; ++i2) {
        if (cd[i2])
          ++l[cd[i2] - 1];
      }
      var le = new u16(mb);
      for (i2 = 0; i2 < mb; ++i2) {
        le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            var sv = i2 << 4 | cd[i2];
            var r_1 = mb - cd[i2];
            var v = le[cd[i2] - 1]++ << r_1;
            for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
              co[rev[v] >>> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s);
        for (i2 = 0; i2 < s; ++i2) {
          if (cd[i2]) {
            co[i2] = rev[le[cd[i2] - 1]++] >>> 15 - cd[i2];
          }
        }
      }
      return co;
    };
    var flt = new u8(288);
    for (i = 0; i < 144; ++i)
      flt[i] = 8;
    var i;
    for (i = 144; i < 256; ++i)
      flt[i] = 9;
    var i;
    for (i = 256; i < 280; ++i)
      flt[i] = 7;
    var i;
    for (i = 280; i < 288; ++i)
      flt[i] = 8;
    var i;
    var fdt = new u8(32);
    for (i = 0; i < 32; ++i)
      fdt[i] = 5;
    var i;
    var flm = hMap(flt, 9, 0);
    var flrm = hMap(flt, 9, 1);
    var fdm = hMap(fdt, 5, 0);
    var fdrm = hMap(fdt, 5, 1);
    var max = function(a) {
      var m = a[0];
      for (var i2 = 1; i2 < a.length; ++i2) {
        if (a[i2] > m)
          m = a[i2];
      }
      return m;
    };
    var bits = function(d, p, m) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
    };
    var bits16 = function(d, p) {
      var o = p / 8 | 0;
      return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
    };
    var shft = function(p) {
      return (p + 7) / 8 | 0;
    };
    var slc = function(v, s, e) {
      if (s == null || s < 0)
        s = 0;
      if (e == null || e > v.length)
        e = v.length;
      var n = new (v.BYTES_PER_ELEMENT == 2 ? u16 : v.BYTES_PER_ELEMENT == 4 ? u32 : u8)(e - s);
      n.set(v.subarray(s, e));
      return n;
    };
    exports.FlateErrorCode = {
      UnexpectedEOF: 0,
      InvalidBlockType: 1,
      InvalidLengthLiteral: 2,
      InvalidDistance: 3,
      StreamFinished: 4,
      NoStreamHandler: 5,
      InvalidHeader: 6,
      NoCallback: 7,
      InvalidUTF8: 8,
      ExtraFieldTooLong: 9,
      InvalidDate: 10,
      FilenameTooLong: 11,
      StreamFinishing: 12,
      InvalidZipData: 13,
      UnknownCompressionMethod: 14
    };
    var ec = [
      "unexpected EOF",
      "invalid block type",
      "invalid length/literal",
      "invalid distance",
      "stream finished",
      "no stream handler",
      ,
      "no callback",
      "invalid UTF-8 data",
      "extra field too long",
      "date not in range 1980-2099",
      "filename too long",
      "stream finishing",
      "invalid zip data"
      // determined by unknown compression method
    ];
    var err = function(ind, msg, nt) {
      var e = new Error(msg || ec[ind]);
      e.code = ind;
      if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
      if (!nt)
        throw e;
      return e;
    };
    var inflt = function(dat, buf, st) {
      var sl = dat.length;
      if (!sl || st && st.f && !st.l)
        return buf || new u8(0);
      var noBuf = !buf || st;
      var noSt = !st || st.i;
      if (!st)
        st = {};
      if (!buf)
        buf = new u8(sl * 3);
      var cbuf = function(l2) {
        var bl = buf.length;
        if (l2 > bl) {
          var nbuf = new u8(Math.max(bl * 2, l2));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      var tbts = sl * 8;
      do {
        if (!lm) {
          final = bits(dat, pos, 1);
          var type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
            if (t > sl) {
              if (noSt)
                err(0);
              break;
            }
            if (noBuf)
              cbuf(bt + l);
            buf.set(dat.subarray(s, t), bt);
            st.b = bt += l, st.p = pos = t * 8, st.f = final;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            var tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            var ldt = new u8(tl);
            var clt = new u8(19);
            for (var i2 = 0; i2 < hcLen; ++i2) {
              clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
            }
            pos += hcLen * 3;
            var clb = max(clt), clbmsk = (1 << clb) - 1;
            var clm = hMap(clt, clb, 1);
            for (var i2 = 0; i2 < tl; ) {
              var r = clm[bits(dat, pos, clbmsk)];
              pos += r & 15;
              var s = r >>> 4;
              if (s < 16) {
                ldt[i2++] = s;
              } else {
                var c = 0, n = 0;
                if (s == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
                else if (s == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i2++] = c;
              }
            }
            var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            err(1);
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
        }
        if (noBuf)
          cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (; ; lpos = pos) {
          var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
          pos += c & 15;
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (!c)
            err(2);
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lpos = pos, lm = null;
            break;
          } else {
            var add = sym - 254;
            if (sym > 264) {
              var i2 = sym - 257, b = fleb[i2];
              add = bits(dat, pos, (1 << b) - 1) + fl[i2];
              pos += b;
            }
            var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
            if (!d)
              err(3);
            pos += d & 15;
            var dt = fd[dsym];
            if (dsym > 3) {
              var b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (noBuf)
              cbuf(bt + 131072);
            var end = bt + add;
            for (; bt < end; bt += 4) {
              buf[bt] = buf[bt - dt];
              buf[bt + 1] = buf[bt + 1 - dt];
              buf[bt + 2] = buf[bt + 2 - dt];
              buf[bt + 3] = buf[bt + 3 - dt];
            }
            bt = end;
          }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt == buf.length ? buf : slc(buf, 0, bt);
    };
    var wbits = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
    };
    var wbits16 = function(d, p, v) {
      v <<= p & 7;
      var o = p / 8 | 0;
      d[o] |= v;
      d[o + 1] |= v >>> 8;
      d[o + 2] |= v >>> 16;
    };
    var hTree = function(d, mb) {
      var t = [];
      for (var i2 = 0; i2 < d.length; ++i2) {
        if (d[i2])
          t.push({ s: i2, f: d[i2] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
        return [et, 0];
      if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return [v, 1];
      }
      t.sort(function(a, b) {
        return a.f - b.f;
      });
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
      t[0] = { s: -1, f: l.f + r.f, l, r };
      while (i1 != s - 1) {
        l = t[t[i0].f < t[i22].f ? i0++ : i22++];
        r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
        t[i1++] = { s: -1, f: l.f + r.f, l, r };
      }
      var maxSym = t2[0].s;
      for (var i2 = 1; i2 < s; ++i2) {
        if (t2[i2].s > maxSym)
          maxSym = t2[i2].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i2 = 0, dt = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
          return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for (; i2 < s; ++i2) {
          var i2_1 = t2[i2].s;
          if (tr[i2_1] > mb) {
            dt += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt >>>= lft;
        while (dt > 0) {
          var i2_2 = t2[i2].s;
          if (tr[i2_2] < mb)
            dt -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i2;
        }
        for (; i2 >= 0 && dt; --i2) {
          var i2_3 = t2[i2].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt;
          }
        }
        mbt = mb;
      }
      return [new u8(tr), mbt];
    };
    var ln = function(n, l, d) {
      return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
    };
    var lc = function(c) {
      var s = c.length;
      while (s && !c[--s])
        ;
      var cl = new u16(++s);
      var cli = 0, cln = c[0], cls = 1;
      var w = function(v) {
        cl[cli++] = v;
      };
      for (var i2 = 1; i2 <= s; ++i2) {
        if (c[i2] == cln && i2 != s)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w(32754);
            if (cls > 2) {
              w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w(cln), --cls;
            for (; cls > 6; cls -= 6)
              w(8304);
            if (cls > 2)
              w(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w(cln);
          cls = 1;
          cln = c[i2];
        }
      }
      return [cl.subarray(0, cli), s];
    };
    var clen = function(cf, cl) {
      var l = 0;
      for (var i2 = 0; i2 < cl.length; ++i2)
        l += cf[i2] * cl[i2];
      return l;
    };
    var wfblk = function(out, pos, dat) {
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >>> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i2 = 0; i2 < s; ++i2)
        out[o + i2 + 4] = dat[i2];
      return (o + 4 + s) * 8;
    };
    var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
      wbits(out, p++, final);
      ++lf[256];
      var _a2 = hTree(lf, 15), dlt = _a2[0], mlb = _a2[1];
      var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
      var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
      var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
      var lcfreq = new u16(19);
      for (var i2 = 0; i2 < lclt.length; ++i2)
        lcfreq[lclt[i2] & 31]++;
      for (var i2 = 0; i2 < lcdt.length; ++i2)
        lcfreq[lcdt[i2] & 31]++;
      var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
      if (flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i2 = 0; i2 < nlcc; ++i2)
          wbits(out, p + 3 * i2, lct[clim[i2]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
          var clct = lcts[it];
          for (var i2 = 0; i2 < clct.length; ++i2) {
            var len = clct[i2] & 31;
            wbits(out, p, llm[len]), p += lct[len];
            if (len > 15)
              wbits(out, p, clct[i2] >>> 5 & 127), p += clct[i2] >>> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i2 = 0; i2 < li; ++i2) {
        if (syms[i2] > 255) {
          var len = syms[i2] >>> 18 & 31;
          wbits16(out, p, lm[len + 257]), p += ll[len + 257];
          if (len > 7)
            wbits(out, p, syms[i2] >>> 23 & 31), p += fleb[len];
          var dst = syms[i2] & 31;
          wbits16(out, p, dm[dst]), p += dl[dst];
          if (dst > 3)
            wbits16(out, p, syms[i2] >>> 5 & 8191), p += fdeb[dst];
        } else {
          wbits16(out, p, lm[syms[i2]]), p += ll[syms[i2]];
        }
      }
      wbits16(out, p, lm[256]);
      return p + ll[256];
    };
    var deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    var et = new u8(0);
    var dflt = function(dat, lvl, plvl, pre, post, lst) {
      var s = dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
      var w = o.subarray(pre, o.length - post);
      var pos = 0;
      if (!lvl || s < 8) {
        for (var i2 = 0; i2 <= s; i2 += 65535) {
          var e = i2 + 65535;
          if (e >= s) {
            w[pos >> 3] = lst;
          }
          pos = wfblk(w, pos + 1, dat.subarray(i2, e));
        }
      } else {
        var opt = deo[lvl - 1];
        var n = opt >>> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = new u16(32768), head = new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i3) {
          return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
        };
        var syms = new u32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
        for (; i2 < s; ++i2) {
          var hv = hsh(i2);
          var imod = i2 & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i2) {
            var rem = s - i2;
            if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
              pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
              li = lc_1 = eb = 0, bs = i2;
              for (var j = 0; j < 286; ++j)
                lf[j] = 0;
              for (var j = 0; j < 30; ++j)
                df[j] = 0;
            }
            var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i2 - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i2);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i2 + l] == dat[i2 + l - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                    ;
                  if (nl > l) {
                    l = nl, d = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j = 0; j < mmd; ++j) {
                      var ti = i2 - dif + j + 32768 & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti + 32768 & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod + 32768 & 32767;
              }
            }
            if (d) {
              syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
              var lin = revfl[l] & 31, din = revfd[d] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i2 + l;
              ++lc_1;
            } else {
              syms[li++] = dat[i2];
              ++lf[dat[i2]];
            }
          }
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
        if (!lst && pos & 7)
          pos = wfblk(w, pos + 1, et);
      }
      return slc(o, 0, pre + shft(pos) + post);
    };
    var crct = function() {
      var t = new Int32Array(256);
      for (var i2 = 0; i2 < 256; ++i2) {
        var c = i2, k = 9;
        while (--k)
          c = (c & 1 && -306674912) ^ c >>> 1;
        t[i2] = c;
      }
      return t;
    }();
    var crc = function() {
      var c = -1;
      return {
        p: function(d) {
          var cr = c;
          for (var i2 = 0; i2 < d.length; ++i2)
            cr = crct[cr & 255 ^ d[i2]] ^ cr >>> 8;
          c = cr;
        },
        d: function() {
          return ~c;
        }
      };
    };
    var adler = function() {
      var a = 1, b = 0;
      return {
        p: function(d) {
          var n = a, m = b;
          var l = d.length | 0;
          for (var i2 = 0; i2 != l; ) {
            var e = Math.min(i2 + 2655, l);
            for (; i2 < e; ++i2)
              m += n += d[i2];
            n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
          }
          a = n, b = m;
        },
        d: function() {
          a %= 65521, b %= 65521;
          return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
        }
      };
    };
    var dopt = function(dat, opt, pre, post, st) {
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
    };
    var mrg = function(a, b) {
      var o = {};
      for (var k in a)
        o[k] = a[k];
      for (var k in b)
        o[k] = b[k];
      return o;
    };
    var wcln = function(fn, fnStr, td2) {
      var dt = fn();
      var st = fn.toString();
      var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
      for (var i2 = 0; i2 < dt.length; ++i2) {
        var v = dt[i2], k = ks[i2];
        if (typeof v == "function") {
          fnStr += ";" + k + "=";
          var st_1 = v.toString();
          if (v.prototype) {
            if (st_1.indexOf("[native code]") != -1) {
              var spInd = st_1.indexOf(" ", 8) + 1;
              fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
            } else {
              fnStr += st_1;
              for (var t in v.prototype)
                fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
            }
          } else
            fnStr += st_1;
        } else
          td2[k] = v;
      }
      return [fnStr, td2];
    };
    var ch = [];
    var cbfs = function(v) {
      var tl = [];
      for (var k in v) {
        if (v[k].buffer) {
          tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
      }
      return tl;
    };
    var wrkr = function(fns, init, id, cb) {
      var _a2;
      if (!ch[id]) {
        var fnStr = "", td_1 = {}, m = fns.length - 1;
        for (var i2 = 0; i2 < m; ++i2)
          _a2 = wcln(fns[i2], fnStr, td_1), fnStr = _a2[0], td_1 = _a2[1];
        ch[id] = wcln(fns[m], fnStr, td_1);
      }
      var td2 = mrg({}, ch[id][1]);
      return node_worker_1["default"](ch[id][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
    };
    var bInflt = function() {
      return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gu8];
    };
    var bDflt = function() {
      return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
    };
    var gze = function() {
      return [gzh, gzhl, wbytes, crc, crct];
    };
    var guze = function() {
      return [gzs, gzl];
    };
    var zle = function() {
      return [zlh, wbytes, adler];
    };
    var zule = function() {
      return [zlv];
    };
    var pbf = function(msg) {
      return postMessage(msg, [msg.buffer]);
    };
    var gu8 = function(o) {
      return o && o.size && new u8(o.size);
    };
    var cbify = function(dat, opts, fns, init, id, cb) {
      var w = wrkr(fns, init, id, function(err2, dat2) {
        w.terminate();
        cb(err2, dat2);
      });
      w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
      return function() {
        w.terminate();
      };
    };
    var astrm = function(strm) {
      strm.ondata = function(dat, final) {
        return postMessage([dat, final], [dat.buffer]);
      };
      return function(ev) {
        return strm.push(ev.data[0], ev.data[1]);
      };
    };
    var astrmify = function(fns, strm, opts, init, id) {
      var t;
      var w = wrkr(fns, init, id, function(err2, dat) {
        if (err2)
          w.terminate(), strm.ondata.call(strm, err2);
        else {
          if (dat[1])
            w.terminate();
          strm.ondata.call(strm, err2, dat[0], dat[1]);
        }
      });
      w.postMessage(opts);
      strm.push = function(d, f) {
        if (!strm.ondata)
          err(5);
        if (t)
          strm.ondata(err(4, 0, 1), null, !!f);
        w.postMessage([d, t = f], [d.buffer]);
      };
      strm.terminate = function() {
        w.terminate();
      };
    };
    var b2 = function(d, b) {
      return d[b] | d[b + 1] << 8;
    };
    var b4 = function(d, b) {
      return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
    };
    var b8 = function(d, b) {
      return b4(d, b) + b4(d, b + 4) * 4294967296;
    };
    var wbytes = function(d, b, v) {
      for (; v; ++b)
        d[b] = v, v >>>= 8;
    };
    var gzh = function(c, o) {
      var fn = o.filename;
      c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
      if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
      if (fn) {
        c[3] = 8;
        for (var i2 = 0; i2 <= fn.length; ++i2)
          c[i2 + 10] = fn.charCodeAt(i2);
      }
    };
    var gzs = function(d) {
      if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        err(6, "invalid gzip data");
      var flg = d[3];
      var st = 10;
      if (flg & 4)
        st += d[10] | (d[11] << 8) + 2;
      for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
        ;
      return st + (flg & 2);
    };
    var gzl = function(d) {
      var l = d.length;
      return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
    };
    var gzhl = function(o) {
      return 10 + (o.filename && o.filename.length + 1 || 0);
    };
    var zlh = function(c, o) {
      var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = fl2 << 6 | (fl2 ? 32 - 2 * fl2 : 1);
    };
    var zlv = function(d) {
      if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        err(6, "invalid zlib data");
      if (d[1] & 32)
        err(6, "invalid zlib data: preset dictionaries not supported");
    };
    function AsyncCmpStrm(opts, cb) {
      if (!cb && typeof opts == "function")
        cb = opts, opts = {};
      this.ondata = cb;
      return opts;
    }
    var Deflate = function() {
      function Deflate2(opts, cb) {
        if (!cb && typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
      }
      Deflate2.prototype.p = function(c, f) {
        this.ondata(dopt(c, this.o, 0, 0, !f), f);
      };
      Deflate2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        this.d = final;
        this.p(chunk, final || false);
      };
      return Deflate2;
    }();
    exports.Deflate = Deflate;
    var AsyncDeflate = function() {
      function AsyncDeflate2(opts, cb) {
        astrmify([
          bDflt,
          function() {
            return [astrm, Deflate];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Deflate(ev.data);
          onmessage = astrm(strm);
        }, 6);
      }
      return AsyncDeflate2;
    }();
    exports.AsyncDeflate = AsyncDeflate;
    function deflate(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt
      ], function(ev) {
        return pbf(deflateSync(ev.data[0], ev.data[1]));
      }, 0, cb);
    }
    exports.deflate = deflate;
    function deflateSync(data, opts) {
      return dopt(data, opts || {}, 0, 0);
    }
    exports.deflateSync = deflateSync;
    var Inflate = function() {
      function Inflate2(cb) {
        this.s = {};
        this.p = new u8(0);
        this.ondata = cb;
      }
      Inflate2.prototype.e = function(c) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        var l = this.p.length;
        var n = new u8(l + c.length);
        n.set(this.p), n.set(c, l), this.p = n;
      };
      Inflate2.prototype.c = function(final) {
        this.d = this.s.i = final || false;
        var bts = this.s.b;
        var dt = inflt(this.p, this.o, this.s);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      };
      Inflate2.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
      };
      return Inflate2;
    }();
    exports.Inflate = Inflate;
    var AsyncInflate = function() {
      function AsyncInflate2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          function() {
            return [astrm, Inflate];
          }
        ], this, 0, function() {
          var strm = new Inflate();
          onmessage = astrm(strm);
        }, 7);
      }
      return AsyncInflate2;
    }();
    exports.AsyncInflate = AsyncInflate;
    function inflate(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt
      ], function(ev) {
        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
      }, 1, cb);
    }
    exports.inflate = inflate;
    function inflateSync(data, out) {
      return inflt(data, out);
    }
    exports.inflateSync = inflateSync;
    var Gzip = function() {
      function Gzip2(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Gzip2.prototype.push = function(chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
      };
      Gzip2.prototype.p = function(c, f) {
        this.c.p(c);
        this.l += c.length;
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
        if (this.v)
          gzh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f);
      };
      return Gzip2;
    }();
    exports.Gzip = Gzip;
    exports.Compress = Gzip;
    var AsyncGzip = function() {
      function AsyncGzip2(opts, cb) {
        astrmify([
          bDflt,
          gze,
          function() {
            return [astrm, Deflate, Gzip];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Gzip(ev.data);
          onmessage = astrm(strm);
        }, 8);
      }
      return AsyncGzip2;
    }();
    exports.AsyncGzip = AsyncGzip;
    exports.AsyncCompress = AsyncGzip;
    function gzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt,
        gze,
        function() {
          return [gzipSync];
        }
      ], function(ev) {
        return pbf(gzipSync(ev.data[0], ev.data[1]));
      }, 2, cb);
    }
    exports.gzip = gzip;
    exports.compress = gzip;
    function gzipSync(data, opts) {
      if (!opts)
        opts = {};
      var c = crc(), l = data.length;
      c.p(data);
      var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
      return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
    }
    exports.gzipSync = gzipSync;
    exports.compressSync = gzipSync;
    var Gunzip = function() {
      function Gunzip2(cb) {
        this.v = 1;
        Inflate.call(this, cb);
      }
      Gunzip2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          var s = this.p.length > 3 ? gzs(this.p) : 4;
          if (s >= this.p.length && !final)
            return;
          this.p = this.p.subarray(s), this.v = 0;
        }
        if (final) {
          if (this.p.length < 8)
            err(6, "invalid gzip data");
          this.p = this.p.subarray(0, -8);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Gunzip2;
    }();
    exports.Gunzip = Gunzip;
    var AsyncGunzip = function() {
      function AsyncGunzip2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          guze,
          function() {
            return [astrm, Inflate, Gunzip];
          }
        ], this, 0, function() {
          var strm = new Gunzip();
          onmessage = astrm(strm);
        }, 9);
      }
      return AsyncGunzip2;
    }();
    exports.AsyncGunzip = AsyncGunzip;
    function gunzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt,
        guze,
        function() {
          return [gunzipSync];
        }
      ], function(ev) {
        return pbf(gunzipSync(ev.data[0]));
      }, 3, cb);
    }
    exports.gunzip = gunzip;
    function gunzipSync(data, out) {
      return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
    }
    exports.gunzipSync = gunzipSync;
    var Zlib = function() {
      function Zlib2(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Zlib2.prototype.push = function(chunk, final) {
        Deflate.prototype.push.call(this, chunk, final);
      };
      Zlib2.prototype.p = function(c, f) {
        this.c.p(c);
        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
        if (this.v)
          zlh(raw, this.o), this.v = 0;
        if (f)
          wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f);
      };
      return Zlib2;
    }();
    exports.Zlib = Zlib;
    var AsyncZlib = function() {
      function AsyncZlib2(opts, cb) {
        astrmify([
          bDflt,
          zle,
          function() {
            return [astrm, Deflate, Zlib];
          }
        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {
          var strm = new Zlib(ev.data);
          onmessage = astrm(strm);
        }, 10);
      }
      return AsyncZlib2;
    }();
    exports.AsyncZlib = AsyncZlib;
    function zlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bDflt,
        zle,
        function() {
          return [zlibSync];
        }
      ], function(ev) {
        return pbf(zlibSync(ev.data[0], ev.data[1]));
      }, 4, cb);
    }
    exports.zlib = zlib;
    function zlibSync(data, opts) {
      if (!opts)
        opts = {};
      var a = adler();
      a.p(data);
      var d = dopt(data, opts, 2, 4);
      return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
    }
    exports.zlibSync = zlibSync;
    var Unzlib = function() {
      function Unzlib2(cb) {
        this.v = 1;
        Inflate.call(this, cb);
      }
      Unzlib2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          if (this.p.length < 2 && !final)
            return;
          this.p = this.p.subarray(2), this.v = 0;
        }
        if (final) {
          if (this.p.length < 4)
            err(6, "invalid zlib data");
          this.p = this.p.subarray(0, -4);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Unzlib2;
    }();
    exports.Unzlib = Unzlib;
    var AsyncUnzlib = function() {
      function AsyncUnzlib2(cb) {
        this.ondata = cb;
        astrmify([
          bInflt,
          zule,
          function() {
            return [astrm, Inflate, Unzlib];
          }
        ], this, 0, function() {
          var strm = new Unzlib();
          onmessage = astrm(strm);
        }, 11);
      }
      return AsyncUnzlib2;
    }();
    exports.AsyncUnzlib = AsyncUnzlib;
    function unzlib(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return cbify(data, opts, [
        bInflt,
        zule,
        function() {
          return [unzlibSync];
        }
      ], function(ev) {
        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
      }, 5, cb);
    }
    exports.unzlib = unzlib;
    function unzlibSync(data, out) {
      return inflt((zlv(data), data.subarray(2, -4)), out);
    }
    exports.unzlibSync = unzlibSync;
    var Decompress = function() {
      function Decompress2(cb) {
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
        this.ondata = cb;
      }
      Decompress2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (!this.s) {
          if (this.p && this.p.length) {
            var n = new u8(this.p.length + chunk.length);
            n.set(this.p), n.set(chunk, this.p.length);
          } else
            this.p = chunk;
          if (this.p.length > 2) {
            var _this_1 = this;
            var cb = function() {
              _this_1.ondata.apply(_this_1, arguments);
            };
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
            this.s.push(this.p, final);
            this.p = null;
          }
        } else
          this.s.push(chunk, final);
      };
      return Decompress2;
    }();
    exports.Decompress = Decompress;
    var AsyncDecompress = function() {
      function AsyncDecompress2(cb) {
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
        this.ondata = cb;
      }
      AsyncDecompress2.prototype.push = function(chunk, final) {
        Decompress.prototype.push.call(this, chunk, final);
      };
      return AsyncDecompress2;
    }();
    exports.AsyncDecompress = AsyncDecompress;
    function decompress(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
    }
    exports.decompress = decompress;
    function decompressSync(data, out) {
      return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
    }
    exports.decompressSync = decompressSync;
    var fltn = function(d, p, t, o) {
      for (var k in d) {
        var val = d[k], n = p + k, op = o;
        if (Array.isArray(val))
          op = mrg(o, val[1]), val = val[0];
        if (val instanceof u8)
          t[n] = [val, op];
        else {
          t[n += "/"] = [new u8(0), op];
          fltn(val, n, t, o);
        }
      }
    };
    var te = typeof TextEncoder != "undefined" && new TextEncoder();
    var td = typeof TextDecoder != "undefined" && new TextDecoder();
    var tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e) {
    }
    var dutf8 = function(d) {
      for (var r = "", i2 = 0; ; ) {
        var c = d[i2++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i2 + eb > d.length)
          return [r, slc(d, i2 - 1)];
        if (!eb)
          r += String.fromCharCode(c);
        else if (eb == 3) {
          c = ((c & 15) << 18 | (d[i2++] & 63) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1)
          r += String.fromCharCode((c & 31) << 6 | d[i2++] & 63);
        else
          r += String.fromCharCode((c & 15) << 12 | (d[i2++] & 63) << 6 | d[i2++] & 63);
      }
    };
    var DecodeUTF8 = function() {
      function DecodeUTF82(cb) {
        this.ondata = cb;
        if (tds)
          this.t = new TextDecoder();
        else
          this.p = et;
      }
      DecodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        final = !!final;
        if (this.t) {
          this.ondata(this.t.decode(chunk, { stream: true }), final);
          if (final) {
            if (this.t.decode().length)
              err(8);
            this.t = null;
          }
          return;
        }
        if (!this.p)
          err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a2 = dutf8(dat), ch2 = _a2[0], np = _a2[1];
        if (final) {
          if (np.length)
            err(8);
          this.p = null;
        } else
          this.p = np;
        this.ondata(ch2, final);
      };
      return DecodeUTF82;
    }();
    exports.DecodeUTF8 = DecodeUTF8;
    var EncodeUTF8 = function() {
      function EncodeUTF82(cb) {
        this.ondata = cb;
      }
      EncodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
      };
      return EncodeUTF82;
    }();
    exports.EncodeUTF8 = EncodeUTF8;
    function strToU8(str, latin1) {
      if (latin1) {
        var ar_1 = new u8(str.length);
        for (var i2 = 0; i2 < str.length; ++i2)
          ar_1[i2] = str.charCodeAt(i2);
        return ar_1;
      }
      if (te)
        return te.encode(str);
      var l = str.length;
      var ar = new u8(str.length + (str.length >> 1));
      var ai = 0;
      var w = function(v) {
        ar[ai++] = v;
      };
      for (var i2 = 0; i2 < l; ++i2) {
        if (ai + 5 > ar.length) {
          var n = new u8(ai + 8 + (l - i2 << 1));
          n.set(ar);
          ar = n;
        }
        var c = str.charCodeAt(i2);
        if (c < 128 || latin1)
          w(c);
        else if (c < 2048)
          w(192 | c >> 6), w(128 | c & 63);
        else if (c > 55295 && c < 57344)
          c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i2) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
        else
          w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
      }
      return slc(ar, 0, ai);
    }
    exports.strToU8 = strToU8;
    function strFromU8(dat, latin1) {
      if (latin1) {
        var r = "";
        for (var i2 = 0; i2 < dat.length; i2 += 16384)
          r += String.fromCharCode.apply(null, dat.subarray(i2, i2 + 16384));
        return r;
      } else if (td)
        return td.decode(dat);
      else {
        var _a2 = dutf8(dat), out = _a2[0], ext = _a2[1];
        if (ext.length)
          err(8);
        return out;
      }
    }
    exports.strFromU8 = strFromU8;
    var dbf = function(l) {
      return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    var slzh = function(d, b) {
      return b + 30 + b2(d, b + 26) + b2(d, b + 28);
    };
    var zh = function(d, b, z) {
      var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
      var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
      return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
    };
    var z64e = function(d, b) {
      for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
        ;
      return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
    };
    var exfl = function(ex) {
      var le = 0;
      if (ex) {
        for (var k in ex) {
          var l = ex[k].length;
          if (l > 65535)
            err(9);
          le += l + 4;
        }
      }
      return le;
    };
    var wzh = function(d, b, f, fn, u, c, ce, co) {
      var fl2 = fn.length, ex = f.extra, col = co && co.length;
      var exl = exfl(ex);
      wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
      if (ce != null)
        d[b++] = 20, d[b++] = f.os;
      d[b] = 20, b += 2;
      d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
      d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
      var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
      if (y < 0 || y > 119)
        err(10);
      wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;
      if (c != null) {
        wbytes(d, b, f.crc);
        wbytes(d, b + 4, c);
        wbytes(d, b + 8, f.size);
      }
      wbytes(d, b + 12, fl2);
      wbytes(d, b + 14, exl), b += 16;
      if (ce != null) {
        wbytes(d, b, col);
        wbytes(d, b + 6, f.attrs);
        wbytes(d, b + 10, ce), b += 14;
      }
      d.set(fn, b);
      b += fl2;
      if (exl) {
        for (var k in ex) {
          var exf = ex[k], l = exf.length;
          wbytes(d, b, +k);
          wbytes(d, b + 2, l);
          d.set(exf, b + 4), b += 4 + l;
        }
      }
      if (col)
        d.set(co, b), b += col;
      return b;
    };
    var wzf = function(o, b, c, d, e) {
      wbytes(o, b, 101010256);
      wbytes(o, b + 8, c);
      wbytes(o, b + 10, c);
      wbytes(o, b + 12, d);
      wbytes(o, b + 16, e);
    };
    var ZipPassThrough = function() {
      function ZipPassThrough2(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
      }
      ZipPassThrough2.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
      };
      ZipPassThrough2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
          this.crc = this.c.d();
        this.process(chunk, final || false);
      };
      return ZipPassThrough2;
    }();
    exports.ZipPassThrough = ZipPassThrough;
    var ZipDeflate = function() {
      function ZipDeflate2(filename, opts) {
        var _this_1 = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
          _this_1.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
      }
      ZipDeflate2.prototype.process = function(chunk, final) {
        try {
          this.d.push(chunk, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      ZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return ZipDeflate2;
    }();
    exports.ZipDeflate = ZipDeflate;
    var AsyncZipDeflate = function() {
      function AsyncZipDeflate2(filename, opts) {
        var _this_1 = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err2, dat, final) {
          _this_1.ondata(err2, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
      }
      AsyncZipDeflate2.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
      };
      AsyncZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return AsyncZipDeflate2;
    }();
    exports.AsyncZipDeflate = AsyncZipDeflate;
    var Zip = function() {
      function Zip2(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
      }
      Zip2.prototype.add = function(file) {
        var _this_1 = this;
        if (!this.ondata)
          err(5);
        if (this.d & 2)
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
          var f = strToU8(file.filename), fl_1 = f.length;
          var com = file.comment, o = com && strToU8(com);
          var u = fl_1 != file.filename.length || o && com.length != o.length;
          var hl_1 = fl_1 + exfl(file.extra) + 30;
          if (fl_1 > 65535)
            this.ondata(err(11, 0, 1), null, false);
          var header = new u8(hl_1);
          wzh(header, 0, file, f, u);
          var chks_1 = [header];
          var pAll_1 = function() {
            for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
              var chk = chks_2[_i];
              _this_1.ondata(null, chk, false);
            }
            chks_1 = [];
          };
          var tr_1 = this.d;
          this.d = 0;
          var ind_1 = this.u.length;
          var uf_1 = mrg(file, {
            f,
            u,
            o,
            t: function() {
              if (file.terminate)
                file.terminate();
            },
            r: function() {
              pAll_1();
              if (tr_1) {
                var nxt = _this_1.u[ind_1 + 1];
                if (nxt)
                  nxt.r();
                else
                  _this_1.d = 1;
              }
              tr_1 = 1;
            }
          });
          var cl_1 = 0;
          file.ondata = function(err2, dat, final) {
            if (err2) {
              _this_1.ondata(err2, dat, final);
              _this_1.terminate();
            } else {
              cl_1 += dat.length;
              chks_1.push(dat);
              if (final) {
                var dd = new u8(16);
                wbytes(dd, 0, 134695760);
                wbytes(dd, 4, file.crc);
                wbytes(dd, 8, cl_1);
                wbytes(dd, 12, file.size);
                chks_1.push(dd);
                uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                if (tr_1)
                  uf_1.r();
                tr_1 = 1;
              } else if (tr_1)
                pAll_1();
            }
          };
          this.u.push(uf_1);
        }
      };
      Zip2.prototype.end = function() {
        var _this_1 = this;
        if (this.d & 2) {
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
          return;
        }
        if (this.d)
          this.e();
        else
          this.u.push({
            r: function() {
              if (!(_this_1.d & 1))
                return;
              _this_1.u.splice(-1, 1);
              _this_1.e();
            },
            t: function() {
            }
          });
        this.d = 3;
      };
      Zip2.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
          var f = _c[_b2];
          wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
          bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
      };
      Zip2.prototype.terminate = function() {
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f = _a2[_i];
          f.t();
        }
        this.d = 2;
      };
      return Zip2;
    }();
    exports.Zip = Zip;
    function zip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      var r = {};
      fltn(data, "", r, opts);
      var k = Object.keys(r);
      var lft = k.length, o = 0, tot = 0;
      var slft = lft, files = new Array(lft);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var cbd = function(a, b) {
        mt(function() {
          cb(a, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var cbf = function() {
        var out = new u8(tot + 22), oe = o, cdl = tot - o;
        tot = 0;
        for (var i3 = 0; i3 < slft; ++i3) {
          var f = files[i3];
          try {
            var l = f.c.length;
            wzh(out, tot, f, f.f, f.u, l);
            var badd = 30 + f.f.length + exfl(f.extra);
            var loc = tot + badd;
            out.set(f.c, loc);
            wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
          } catch (e) {
            return cbd(e, null);
          }
        }
        wzf(out, o, files.length, cdl, oe);
        cbd(null, out);
      };
      if (!lft)
        cbf();
      var _loop_1 = function(i3) {
        var fn = k[i3];
        var _a2 = r[fn], file = _a2[0], p = _a2[1];
        var c = crc(), size = file.length;
        c.p(file);
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        var compression = p.level == 0 ? 0 : 8;
        var cbl = function(e, d) {
          if (e) {
            tAll();
            cbd(e, null);
          } else {
            var l = d.length;
            files[i3] = mrg(p, {
              size,
              crc: c.d(),
              c: d,
              f,
              m,
              u: s != fn.length || m && com.length != ms,
              compression
            });
            o += 30 + s + exl + l;
            tot += 76 + 2 * (s + exl) + (ms || 0) + l;
            if (!--lft)
              cbf();
          }
        };
        if (s > 65535)
          cbl(err(11, 0, 1), null);
        if (!compression)
          cbl(null, file);
        else if (size < 16e4) {
          try {
            cbl(null, deflateSync(file, p));
          } catch (e) {
            cbl(e, null);
          }
        } else
          term.push(deflate(file, p, cbl));
      };
      for (var i2 = 0; i2 < slft; ++i2) {
        _loop_1(i2);
      }
      return tAll;
    }
    exports.zip = zip;
    function zipSync(data, opts) {
      if (!opts)
        opts = {};
      var r = {};
      var files = [];
      fltn(data, "", r, opts);
      var o = 0;
      var tot = 0;
      for (var fn in r) {
        var _a2 = r[fn], file = _a2[0], p = _a2[1];
        var compression = p.level == 0 ? 0 : 8;
        var f = strToU8(fn), s = f.length;
        var com = p.comment, m = com && strToU8(com), ms = m && m.length;
        var exl = exfl(p.extra);
        if (s > 65535)
          err(11);
        var d = compression ? deflateSync(file, p) : file, l = d.length;
        var c = crc();
        c.p(file);
        files.push(mrg(p, {
          size: file.length,
          crc: c.d(),
          c: d,
          f,
          m,
          u: s != fn.length || m && com.length != ms,
          o,
          compression
        }));
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
      }
      var out = new u8(tot + 22), oe = o, cdl = tot - o;
      for (var i2 = 0; i2 < files.length; ++i2) {
        var f = files[i2];
        wzh(out, f.o, f, f.f, f.u, f.c.length);
        var badd = 30 + f.f.length + exfl(f.extra);
        out.set(f.c, f.o + badd);
        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
      }
      wzf(out, o, files.length, cdl, oe);
      return out;
    }
    exports.zipSync = zipSync;
    var UnzipPassThrough = function() {
      function UnzipPassThrough2() {
      }
      UnzipPassThrough2.prototype.push = function(data, final) {
        this.ondata(null, data, final);
      };
      UnzipPassThrough2.compression = 0;
      return UnzipPassThrough2;
    }();
    exports.UnzipPassThrough = UnzipPassThrough;
    var UnzipInflate = function() {
      function UnzipInflate2() {
        var _this_1 = this;
        this.i = new Inflate(function(dat, final) {
          _this_1.ondata(null, dat, final);
        });
      }
      UnzipInflate2.prototype.push = function(data, final) {
        try {
          this.i.push(data, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      UnzipInflate2.compression = 8;
      return UnzipInflate2;
    }();
    exports.UnzipInflate = UnzipInflate;
    var AsyncUnzipInflate = function() {
      function AsyncUnzipInflate2(_, sz) {
        var _this_1 = this;
        if (sz < 32e4) {
          this.i = new Inflate(function(dat, final) {
            _this_1.ondata(null, dat, final);
          });
        } else {
          this.i = new AsyncInflate(function(err2, dat, final) {
            _this_1.ondata(err2, dat, final);
          });
          this.terminate = this.i.terminate;
        }
      }
      AsyncUnzipInflate2.prototype.push = function(data, final) {
        if (this.i.terminate)
          data = slc(data, 0);
        this.i.push(data, final);
      };
      AsyncUnzipInflate2.compression = 8;
      return AsyncUnzipInflate2;
    }();
    exports.AsyncUnzipInflate = AsyncUnzipInflate;
    var Unzip = function() {
      function Unzip2(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
          0: UnzipPassThrough
        };
        this.p = et;
      }
      Unzip2.prototype.push = function(chunk, final) {
        var _this_1 = this;
        if (!this.onfile)
          err(5);
        if (!this.p)
          err(4);
        if (this.c > 0) {
          var len = Math.min(this.c, chunk.length);
          var toAdd = chunk.subarray(0, len);
          this.c -= len;
          if (this.d)
            this.d.push(toAdd, !this.c);
          else
            this.k[0].push(toAdd);
          chunk = chunk.subarray(len);
          if (chunk.length)
            return this.push(chunk, final);
        } else {
          var f = 0, i2 = 0, is = void 0, buf = void 0;
          if (!this.p.length)
            buf = chunk;
          else if (!chunk.length)
            buf = this.p;
          else {
            buf = new u8(this.p.length + chunk.length);
            buf.set(this.p), buf.set(chunk, this.p.length);
          }
          var l = buf.length, oc = this.c, add = oc && this.d;
          var _loop_2 = function() {
            var _a2;
            var sig = b4(buf, i2);
            if (sig == 67324752) {
              f = 1, is = i2;
              this_1.d = null;
              this_1.c = 0;
              var bf = b2(buf, i2 + 6), cmp_1 = b2(buf, i2 + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i2 + 26), es = b2(buf, i2 + 28);
              if (l > i2 + 30 + fnl + es) {
                var chks_3 = [];
                this_1.k.unshift(chks_3);
                f = 2;
                var sc_1 = b4(buf, i2 + 18), su_1 = b4(buf, i2 + 22);
                var fn_1 = strFromU8(buf.subarray(i2 + 30, i2 += 30 + fnl), !u);
                if (sc_1 == 4294967295) {
                  _a2 = dd ? [-2] : z64e(buf, i2), sc_1 = _a2[0], su_1 = _a2[1];
                } else if (dd)
                  sc_1 = -1;
                i2 += es;
                this_1.c = sc_1;
                var d_1;
                var file_1 = {
                  name: fn_1,
                  compression: cmp_1,
                  start: function() {
                    if (!file_1.ondata)
                      err(5);
                    if (!sc_1)
                      file_1.ondata(null, et, true);
                    else {
                      var ctr = _this_1.o[cmp_1];
                      if (!ctr)
                        file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                      d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                      d_1.ondata = function(err2, dat3, final2) {
                        file_1.ondata(err2, dat3, final2);
                      };
                      for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                        var dat2 = chks_4[_i];
                        d_1.push(dat2, false);
                      }
                      if (_this_1.k[0] == chks_3 && _this_1.c)
                        _this_1.d = d_1;
                      else
                        d_1.push(et, true);
                    }
                  },
                  terminate: function() {
                    if (d_1 && d_1.terminate)
                      d_1.terminate();
                  }
                };
                if (sc_1 >= 0)
                  file_1.size = sc_1, file_1.originalSize = su_1;
                this_1.onfile(file_1);
              }
              return "break";
            } else if (oc) {
              if (sig == 134695760) {
                is = i2 += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
                return "break";
              } else if (sig == 33639248) {
                is = i2 -= 4, f = 3, this_1.c = 0;
                return "break";
              }
            }
          };
          var this_1 = this;
          for (; i2 < l - 4; ++i2) {
            var state_1 = _loop_2();
            if (state_1 === "break")
              break;
          }
          this.p = et;
          if (oc < 0) {
            var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i2);
            if (add)
              add.push(dat, !!f);
            else
              this.k[+(f == 2)].push(dat);
          }
          if (f & 2)
            return this.push(buf.subarray(i2), final);
          this.p = buf.subarray(i2);
        }
        if (final) {
          if (this.c)
            err(13);
          this.p = null;
        }
      };
      Unzip2.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
      };
      return Unzip2;
    }();
    exports.Unzip = Unzip;
    var mt = typeof queueMicrotask == "function" ? queueMicrotask : typeof setTimeout == "function" ? setTimeout : function(fn) {
      fn();
    };
    function unzip(data, opts, cb) {
      if (!cb)
        cb = opts, opts = {};
      if (typeof cb != "function")
        err(7);
      var term = [];
      var tAll = function() {
        for (var i3 = 0; i3 < term.length; ++i3)
          term[i3]();
      };
      var files = {};
      var cbd = function(a, b) {
        mt(function() {
          cb(a, b);
        });
      };
      mt(function() {
        cbd = cb;
      });
      var e = data.length - 22;
      for (; b4(data, e) != 101010256; --e) {
        if (!e || data.length - e > 65558) {
          cbd(err(13, 0, 1), null);
          return tAll;
        }
      }
      ;
      var lft = b2(data, e + 8);
      if (lft) {
        var c = lft;
        var o = b4(data, e + 16);
        var z = o == 4294967295;
        if (z) {
          e = b4(data, e - 12);
          if (b4(data, e) != 101075792) {
            cbd(err(13, 0, 1), null);
            return tAll;
          }
          c = lft = b4(data, e + 32);
          o = b4(data, e + 48);
        }
        var fltr = opts && opts.filter;
        var _loop_3 = function(i3) {
          var _a2 = zh(data, o, z), c_1 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
          o = no;
          var cbl = function(e2, d) {
            if (e2) {
              tAll();
              cbd(e2, null);
            } else {
              if (d)
                files[fn] = d;
              if (!--lft)
                cbd(null, files);
            }
          };
          if (!fltr || fltr({
            name: fn,
            size: sc,
            originalSize: su,
            compression: c_1
          })) {
            if (!c_1)
              cbl(null, slc(data, b, b + sc));
            else if (c_1 == 8) {
              var infl = data.subarray(b, b + sc);
              if (sc < 32e4) {
                try {
                  cbl(null, inflateSync(infl, new u8(su)));
                } catch (e2) {
                  cbl(e2, null);
                }
              } else
                term.push(inflate(infl, { size: su }, cbl));
            } else
              cbl(err(14, "unknown compression type " + c_1, 1), null);
          } else
            cbl(null, null);
        };
        for (var i2 = 0; i2 < c; ++i2) {
          _loop_3(i2);
        }
      } else
        cbd(null, {});
      return tAll;
    }
    exports.unzip = unzip;
    function unzipSync(data, opts) {
      var files = {};
      var e = data.length - 22;
      for (; b4(data, e) != 101010256; --e) {
        if (!e || data.length - e > 65558)
          err(13);
      }
      ;
      var c = b2(data, e + 8);
      if (!c)
        return {};
      var o = b4(data, e + 16);
      var z = o == 4294967295;
      if (z) {
        e = b4(data, e - 12);
        if (b4(data, e) != 101075792)
          err(13);
        c = b4(data, e + 32);
        o = b4(data, e + 48);
      }
      var fltr = opts && opts.filter;
      for (var i2 = 0; i2 < c; ++i2) {
        var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
        o = no;
        if (!fltr || fltr({
          name: fn,
          size: sc,
          originalSize: su,
          compression: c_2
        })) {
          if (!c_2)
            files[fn] = slc(data, b, b + sc);
          else if (c_2 == 8)
            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));
          else
            err(14, "unknown compression type " + c_2);
        }
      }
      return files;
    }
    exports.unzipSync = unzipSync;
  }
});

// node_modules/onml/lib/stringify.js
var require_stringify4 = __commonJS({
  "node_modules/onml/lib/stringify.js"(exports, module) {
    "use strict";
    function isObject(o) {
      return o && Object.prototype.toString.call(o) === "[object Object]";
    }
    function indenter(indentation) {
      var space = " ".repeat(indentation);
      return function(txt) {
        var arr, res = [];
        if (typeof txt !== "string") {
          return txt;
        }
        arr = txt.split("\n");
        if (arr.length === 1) {
          return space + txt;
        }
        arr.forEach(function(e) {
          if (e.trim() === "") {
            res.push(e);
            return;
          }
          res.push(space + e);
        });
        return res.join("\n");
      };
    }
    function clean(txt) {
      var arr = txt.split("\n");
      var res = [];
      arr.forEach(function(e) {
        if (e.trim() === "") {
          return;
        }
        res.push(e);
      });
      return res.join("\n");
    }
    function stringify(a, indentation) {
      var cr = "";
      var indent = function(t) {
        return t;
      };
      if (indentation > 0) {
        cr = "\n";
        indent = indenter(indentation);
      }
      function rec(a2) {
        var res, body, isEmpty, isFlat;
        body = "";
        isFlat = true;
        isEmpty = a2.some(function(e, i, arr) {
          if (i === 0) {
            res = "<" + e;
            if (arr.length === 1) {
              return true;
            }
            return;
          }
          if (i === 1) {
            if (isObject(e)) {
              Object.keys(e).forEach(function(key) {
                res += " " + key + '="' + e[key] + '"';
              });
              if (arr.length === 2) {
                return true;
              }
              res += ">";
              return;
            } else {
              res += ">";
            }
          }
          switch (typeof e) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
              body += e + cr;
              return;
          }
          isFlat = false;
          body += rec(e);
        });
        if (isEmpty) {
          return res + "/>" + cr;
        } else {
          if (isFlat) {
            return res + clean(body) + "</" + a2[0] + ">" + cr;
          } else {
            return res + cr + indent(body) + "</" + a2[0] + ">" + cr;
          }
        }
      }
      return rec(a);
    }
    module.exports = stringify;
  }
});

// node_modules/@jscad/3mf-serializer/src/index.js
var require_src4 = __commonJS({
  "node_modules/@jscad/3mf-serializer/src/index.js"(exports, module) {
    var zipSync = require_lib().zipSync;
    var strToU8 = require_lib().strToU8;
    var stringify = require_stringify4();
    var { colors, geometries, modifiers } = require_src();
    var { flatten, toArray } = require_src2();
    var mimeType = "model/3mf";
    var fileExtension = "3mf";
    var serialize = (options, ...objects) => {
      const defaults = {
        unit: "millimeter",
        // micron, millimeter, centimeter, inch, foot, meter
        metadata: true,
        defaultcolor: [255 / 255, 160 / 255, 0, 1],
        // JSCAD Orange
        compress: true
      };
      options = Object.assign({}, defaults, options);
      objects = flatten(objects);
      let objects3d = objects.filter((object) => geometries.geom3.isA(object));
      if (objects3d.length === 0)
        throw new Error("only 3D geometries can be serialized to 3MF");
      if (objects.length !== objects3d.length)
        console.warn("some objects could not be serialized to 3MF");
      objects = toArray(modifiers.generalize({ snap: true, triangulate: true }, objects3d));
      const body = [
        "model",
        {
          unit: options.unit,
          "xml:lang": "und"
        },
        ["metadata", { name: "Application" }, "JSCAD"]
      ];
      if (options.metadata) {
        body.push(["metadata", { name: "CreationDate" }, (/* @__PURE__ */ new Date()).toISOString()]);
      }
      body.push(translateResources(objects, options));
      body.push(translateBuild(objects, options));
      const xml = `<?xml version="1.0" encoding="UTF-8"?>
${stringify(body, 2)}`;
      if (options.compress) {
        const data = {
          "3D": {
            "3dmodel.model": strToU8(xml)
          },
          "_rels": {
            ".rels": strToU8(rels)
          },
          "[Content_Types].xml": strToU8(contenttype)
        };
        const opts = {
          comment: "created by JSCAD"
        };
        const zipData = zipSync(data, opts);
        return [zipData.buffer];
      }
      return [xml];
    };
    var contenttype = `<?xml version="1.0" encoding="UTF-8" ?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml">
  </Default>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml">
  </Default>
</Types>`;
    var rels = `<?xml version="1.0" encoding="UTF-8" ?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel">
  </Relationship>
</Relationships>`;
    var translateResources = (objects, options) => {
      let resources = ["resources", {}, translateMaterials(objects, options)];
      resources = resources.concat(translateObjects(objects, options));
      return resources;
    };
    var translateMaterials = (objects, options) => {
      let basematerials = ["basematerials", { id: "0" }];
      const materials = [];
      objects.forEach((object, i) => {
        let srgb = colors.rgbToHex(options.defaultcolor).toUpperCase();
        if (object.color) {
          srgb = colors.rgbToHex(object.color).toUpperCase();
        }
        materials.push(["base", { name: `mat${i}`, displaycolor: srgb }]);
      });
      basematerials = basematerials.concat(materials);
      return basematerials;
    };
    var translateObjects = (objects, options) => {
      const contents = [];
      objects.forEach((object, i) => {
        if (geometries.geom3.isA(object)) {
          const polygons = geometries.geom3.toPolygons(object);
          if (polygons.length > 0) {
            options.id = i;
            contents.push(convertToObject(object, options));
          }
        }
      });
      return contents;
    };
    var translateBuild = (objects, options) => {
      let build = ["build", {}];
      const items = [];
      objects.forEach((object, i) => {
        items.push(["item", { objectid: `${i + 1}` }]);
      });
      build = build.concat(items);
      return build;
    };
    var convertToObject = (object, options) => {
      const name = object.name ? object.name : `Part ${options.id}`;
      const contents = ["object", { id: `${options.id + 1}`, type: "model", pid: "0", pindex: `${options.id}`, name }, convertToMesh(object, options)];
      return contents;
    };
    var convertToMesh = (object, options) => {
      const contents = ["mesh", {}, convertToVertices(object, options), convertToVolumes(object, options)];
      return contents;
    };
    var convertToVertices = (object, options) => {
      const contents = ["vertices", {}];
      const vertices = [];
      const polygons = geometries.geom3.toPolygons(object);
      polygons.forEach((polygon) => {
        for (let i = 0; i < polygon.vertices.length; i++) {
          vertices.push(convertToVertex(polygon.vertices[i], options));
        }
      });
      return contents.concat(vertices);
    };
    var convertToVertex = (vertex, options) => {
      const contents = ["vertex", { x: vertex[0], y: vertex[1], z: vertex[2] }];
      return contents;
    };
    var convertToVolumes = (object, options) => {
      let n = 0;
      const polygons = geometries.geom3.toPolygons(object);
      let contents = ["triangles", {}];
      polygons.forEach((polygon) => {
        if (polygon.vertices.length < 3) {
          return;
        }
        const triangles = convertToTriangles(polygon, n);
        contents = contents.concat(triangles);
        n += polygon.vertices.length;
      });
      return contents;
    };
    var convertToTriangles = (polygon, index) => {
      const contents = [];
      for (let i = 0; i < polygon.vertices.length - 2; i++) {
        const triangle = ["triangle", { v1: index, v2: index + i + 1, v3: index + i + 2 }];
        contents.push(triangle);
      }
      return contents;
    };
    module.exports = {
      serialize,
      mimeType,
      fileExtension
    };
  }
});

// node_modules/@jscad/io/formats.js
var require_formats = __commonJS({
  "node_modules/@jscad/io/formats.js"(exports, module) {
    var { geometries } = require_src();
    var formats = {
      stl: {
        displayName: "STL (Binary)",
        description: "STereoLithography, Binary",
        extension: "stl",
        mimetype: "application/sla",
        deserializable: true,
        convertGeom3: false,
        convertGeom2: false
      },
      stla: {
        displayName: "STL (ASCII)",
        description: "STereoLithography, ASCII",
        extension: "stl",
        mimetype: "application/sla",
        deserializable: false,
        // just once
        convertGeom3: true,
        convertGeom2: false
      },
      stlb: {
        displayName: "STL (Binary)",
        description: "STereoLithography, Binary",
        extension: "stl",
        mimetype: "application/sla",
        deserializable: false,
        // just once
        convertGeom3: true,
        convertGeom2: false
      },
      amf: {
        displayName: "AMF (experimental)",
        description: "Additive Manufacturing File Format",
        extension: "amf",
        mimetype: "application/amf+xml",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: false
      },
      dxf: {
        displayName: "DXF (ASCII)",
        description: "AutoCAD Drawing Exchange Format",
        extension: "dxf",
        mimetype: "application/dxf",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: true
      },
      jscad: {
        displayName: "JSCAD",
        description: "JSCAD Design Source",
        extension: "jscad",
        mimetype: "application/javascript",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: true
      },
      json: {
        displayName: "json",
        description: "JavaScript Object Notation Format",
        extension: "json",
        mimetype: "application/json",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: true
      },
      js: {
        displayName: "js",
        description: "JavaScript Source",
        extension: "js",
        mimetype: "application/javascript",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: true
      },
      obj: {
        displayName: "OBJ",
        description: "Wavefront OBJ File",
        extension: "obj",
        mimetype: "text/plain",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: false
      },
      svg: {
        displayName: "SVG",
        description: "Scalable Vector Graphics Format",
        extension: "svg",
        mimetype: "image/svg+xml",
        deserializable: true,
        convertGeom3: false,
        convertGeom2: true
      },
      x3d: {
        displayName: "X3D",
        description: "X3D File Format",
        extension: "x3d",
        mimetype: "model/x3d+xml",
        deserializable: true,
        convertGeom3: true,
        convertGeom2: true
      },
      "3mf": {
        displayName: "3MF",
        description: "3D Manufacturing Format",
        extension: "3mf",
        mimetype: "model/3mf",
        deserializable: false,
        convertGeom3: true,
        convertGeom2: false
      }
    };
    var conversionFormats = [
      // 3D file formats
      "amf",
      "js",
      "jscad",
      "obj",
      "scad",
      "stl",
      "dxf",
      // 2D file formats
      "svg",
      "ttf",
      "woff"
    ];
    var supportedFormatsForObjects = (objects) => {
      const objectFormats = [];
      let found3Dsolid = false;
      let found2Dsolid = false;
      for (let i = 0; i < objects.length; i++) {
        if (geometries.geom3.isA(objects[i])) {
          found3Dsolid = true;
        }
        if (geometries.geom2.isA(objects[i]) || geometries.path2.isA(objects[i])) {
          found2Dsolid = true;
        }
      }
      for (const format in formats) {
        if (found3Dsolid && formats[format].convertGeom3 === true) {
          objectFormats[objectFormats.length] = format;
          continue;
        }
        if (found2Dsolid && formats[format].convertGeom2 === true) {
          objectFormats[objectFormats.length] = format;
        }
      }
      return objectFormats;
    };
    var supportedOutputExtensions = () => {
      const supported = [];
      for (const format in formats) {
        if (formats[format].convertGeom3 === true || formats[format].convertGeom2 === true) {
          if (supported.indexOf(formats[format].extension) < 0) {
            supported.push(formats[format].extension);
          }
        }
      }
      return supported;
    };
    var supportedOutputFormats = () => {
      const supported = [];
      for (const format in formats) {
        if (formats[format].convertGeom3 === true || formats[format].convertGeom2 === true) {
          supported.push(format);
        }
      }
      return supported;
    };
    var supportedInputExtensions = () => {
      const supported = [];
      for (const format in formats) {
        if (formats[format].deserializable === true) {
          supported.push(formats[format].extension);
        }
      }
      return supported;
    };
    module.exports = {
      formats,
      conversionFormats,
      supportedInputExtensions,
      supportedOutputExtensions,
      supportedOutputFormats,
      supportedFormatsForObjects
    };
  }
});

// node_modules/@jscad/io/prepareOutput.js
var require_prepareOutput = __commonJS({
  "node_modules/@jscad/io/prepareOutput.js"(exports, module) {
    var { toArray } = require_src2();
    var { formats } = require_formats();
    var amfSerializer = require_amf_serializer();
    var dxfSerializer = require_dxf_serializer();
    var jsonSerializer = require_json_serializer();
    var objSerializer = require_obj_serializer();
    var stlSerializer = require_stl_serializer();
    var svgSerializer = require_svg_serializer();
    var x3dSerializer = require_src3();
    var m3fSerializer = require_src4();
    var prepareOutput = (objects, params) => {
      const defaults = {
        format: void 0,
        version: "0.0.0"
      };
      const { format, version } = Object.assign({}, defaults, params);
      const metaData = {
        producer: "JSCAD " + version,
        date: /* @__PURE__ */ new Date(),
        version
      };
      const outputFormatHandlers = {
        amf: amfSerializer,
        // Geom3 to AMF
        stl: stlSerializer,
        // Geom3 to STL ASCII // NOTE: now using binary output by default !!
        stla: {
          mimeType: stlSerializer.mimeType,
          serialize: (options2, data2) => stlSerializer.serialize(Object.assign({}, { binary: false }, options2), data2)
        },
        // Geom3 to STL ASCII
        stlb: stlSerializer,
        // Geom3 to STL BINARY
        dxf: dxfSerializer,
        // Geom2 to DXF
        obj: objSerializer,
        svg: svgSerializer,
        // Geom2 to SVG
        x3d: x3dSerializer,
        // Geom3 to X3D
        "3mf": m3fSerializer,
        // Geom3 to 3MF
        json: jsonSerializer,
        // Geom3 or Geom2 to JSON
        js: {
          mimeType: formats.js.mimetype,
          serialize: (options2, objects2) => toArray(objects2)
          // js , pass through
        },
        jscad: {
          mimeType: formats.jscad.mimetype,
          serialize: (options2, objects2) => toArray(objects2)
          // jscad , pass through
        },
        undefined: () => {
          throw new Error("Not supported : only jscad, stl, amf, dxf, svg or json as output format");
        }
      };
      const options = Object.assign({}, metaData, params);
      const data = outputFormatHandlers[format].serialize(options, objects);
      const mimeType = outputFormatHandlers[format].mimeType;
      return { data, mimeType };
    };
    module.exports = prepareOutput;
  }
});

// node_modules/@jscad/amf-deserializer/package.json
var require_package2 = __commonJS({
  "node_modules/@jscad/amf-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/amf-deserializer",
      version: "2.3.5",
      description: "AMF Deserializer for JSCAD",
      repository: "https://github.com/jscad/OpenJSCAD.org/",
      main: "src/index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m 'tests/**/*.test.js'"
      },
      contributors: [
        {
          name: "Rene K. Mueller",
          url: "http://renekmueller.com"
        },
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "amf"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/modeling": "2.12.0",
        saxes: "5.0.1"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/amf-deserializer/src/objectBuilder.js
var require_objectBuilder = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/objectBuilder.js"(exports, module) {
    var { maths, geometries } = require_src();
    var lastmaterial;
    var findMaterial = (materials, id) => {
      if (lastmaterial && lastmaterial.id === id)
        return lastmaterial;
      for (let i = 0; i < materials.length; i++) {
        if (materials[i].id && materials[i].id === id) {
          lastmaterial = materials[i];
          return lastmaterial;
        }
      }
      return null;
    };
    var getValue = (objects, type) => {
      for (let i = 0; i < objects.length; i++) {
        if (objects[i].type === type)
          return objects[i].value;
      }
      return null;
    };
    var getColor = (objects) => {
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        if (obj.type === "color") {
          let r = parseFloat(getValue(obj.objects, "r"));
          let g = parseFloat(getValue(obj.objects, "g"));
          let b = parseFloat(getValue(obj.objects, "b"));
          let a = parseFloat(getValue(obj.objects, "a"));
          if (Number.isNaN(r))
            r = 1;
          if (Number.isNaN(g))
            g = 1;
          if (Number.isNaN(b))
            b = 1;
          if (Number.isNaN(a))
            a = 1;
          return [r, g, b, a];
        }
      }
      return null;
    };
    var findColorByMaterial = (materials, id) => {
      const m = findMaterial(materials, id);
      if (m) {
        return getColor(m.objects);
      }
      return null;
    };
    var createObject = (obj, index, data, options) => {
      const vertices = [];
      const faces = [];
      const colors = [];
      const materials = data.amfMaterials;
      const addCoord = (coord, cidx) => {
        if (coord.type === "coordinates") {
          const x = parseFloat(getValue(coord.objects, "x"));
          const y = parseFloat(getValue(coord.objects, "y"));
          const z = parseFloat(getValue(coord.objects, "z"));
          vertices.push([x, y, z]);
        }
      };
      const addVertex = (vertex, vidx) => {
        if (vertex.type === "vertex") {
          vertex.objects.forEach(addCoord);
        }
      };
      const addTriangle = (tri, tidx) => {
        if (tri.type === "triangle") {
          const v1 = parseInt(getValue(tri.objects, "v1"));
          const v2 = parseInt(getValue(tri.objects, "v2"));
          const v3 = parseInt(getValue(tri.objects, "v3"));
          faces.push([v1, v2, v3]);
          const c = getColor(tri.objects);
          if (c) {
            colors.push(c);
          } else {
            colors.push(tricolor);
          }
        }
      };
      let tricolor = null;
      const addPart = (part, pidx) => {
        switch (part.type) {
          case "vertices":
            part.objects.forEach(addVertex);
            break;
          case "volume":
            tricolor = getColor(part.objects);
            if (part.materialid) {
              tricolor = findColorByMaterial(materials, part.materialid);
            }
            part.objects.forEach(addTriangle);
            break;
          default:
            break;
        }
      };
      const addMesh = (mesh, midx) => {
        if (mesh.type === "mesh") {
          mesh.objects.forEach(addPart);
        }
      };
      if (options.instantiate === true) {
        const scale = options.amf.scale;
        const vertex = scale !== 1 ? ([x, y, z]) => maths.vec3.fromValues(x * scale, y * scale, z * scale) : (v) => maths.vec3.clone(v);
        obj.objects.forEach(addMesh);
        const ocolor = getColor(obj.objects);
        const fcount = faces.length;
        const vcount = vertices.length;
        const polygons = [];
        for (let i = 0; i < fcount; i++) {
          const subData = [];
          for (let j = 0; j < faces[i].length; j++) {
            if (faces[i][j] < 0 || faces[i][j] >= vcount) {
              continue;
            }
            subData.push(vertex(vertices[faces[i][j]]));
          }
          const polygon = geometries.poly3.fromPoints(subData);
          const pcolor = colors[i] ? colors[i] : void 0;
          if (pcolor)
            polygon.color = pcolor;
          polygons.push(polygon);
        }
        let shape = geometries.geom3.create(polygons);
        if (ocolor) {
          shape = shape.color = ocolor;
        }
        return shape;
      }
      let code = "";
      if (obj.objects.length > 0) {
        obj.objects.forEach(addMesh);
        const ocolor = getColor(obj.objects);
        const fcount = faces.length;
        const vcount = vertices.length;
        code += `
// Object ${obj.id}
//  faces   : ${fcount}
//  vertices: ${vcount}
const createObject${obj.id} = () => {
  let polygons = []
  let polygon
`;
        for (let i = 0; i < fcount; i++) {
          code += "  polygon = geometries.poly3.fromPoints([\n";
          for (let j = 0; j < faces[i].length; j++) {
            if (faces[i][j] < 0 || faces[i][j] >= vcount) {
              continue;
            }
            code += `      [${vertices[faces[i][j]]}],
`;
          }
          code += "  ])\n";
          const c = colors[i];
          if (c) {
            code += `  polygon.color = [${c}]
`;
          }
          code += "  polygons.push(polygon)\n";
        }
        code += "  let shape = geometries.geom3.create(polygons)\n";
        const scale = options.scale ? options.scale : 1;
        if (scale !== 1) {
          code += `  shape = transforms.scale([${scale},${scale},${scale}], shape)
`;
        }
        if (ocolor) {
          code += `  shape = colors.colorize([${ocolor}], shape)
`;
        }
        code += "  return shape\n}\n";
      }
      return code;
    };
    module.exports = createObject;
  }
});

// node_modules/xmlchars/xml/1.0/ed5.js
var require_ed5 = __commonJS({
  "node_modules/xmlchars/xml/1.0/ed5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAR = "	\n\r -퟿-�𐀀-􏿿";
    exports.S = " 	\r\n";
    exports.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
    exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
    exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
    exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
    exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
    exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
    exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
    exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= SPACE && c <= 55295 || c === NL || c === CR || c === TAB || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isChar = isChar;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports.isNameChar = isNameChar;
  }
});

// node_modules/xmlchars/xml/1.1/ed2.js
var require_ed2 = __commonJS({
  "node_modules/xmlchars/xml/1.1/ed2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAR = "-퟿-�𐀀-􏿿";
    exports.RESTRICTED_CHAR = "-\b\v\f---";
    exports.S = " 	\r\n";
    exports.NAME_START_CHAR = ":A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
    exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
    exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
    exports.RESTRICTED_CHAR_RE = new RegExp("^[" + exports.RESTRICTED_CHAR + "]$", "u");
    exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
    exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
    exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
    exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
    exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= 1 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isChar = isChar;
    function isRestrictedChar(c) {
      return c >= 1 && c <= 8 || c === 11 || c === 12 || c >= 14 && c <= 31 || c >= 127 && c <= 132 || c >= 134 && c <= 159;
    }
    exports.isRestrictedChar = isRestrictedChar;
    function isCharAndNotRestricted(c) {
      return c === 9 || c === 10 || c === 13 || c > 31 && c < 127 || c === 133 || c > 159 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isCharAndNotRestricted = isCharAndNotRestricted;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports.isNameChar = isNameChar;
  }
});

// node_modules/xmlchars/xmlns/1.0/ed3.js
var require_ed3 = __commonJS({
  "node_modules/xmlchars/xmlns/1.0/ed3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NC_NAME_START_CHAR = "A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�𐀀-󯿿";
    exports.NC_NAME_CHAR = "-" + exports.NC_NAME_START_CHAR + ".0-9·̀-ͯ‿-⁀";
    exports.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "]$", "u");
    exports.NC_NAME_CHAR_RE = new RegExp("^[" + exports.NC_NAME_CHAR + "]$", "u");
    exports.NC_NAME_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "][" + exports.NC_NAME_CHAR + "]*$", "u");
    function isNCNameStartChar(c) {
      return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNCNameStartChar = isNCNameStartChar;
    function isNCNameChar(c) {
      return isNCNameStartChar(c) || (c === 45 || c === 46 || c >= 48 && c <= 57 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256);
    }
    exports.isNCNameChar = isNCNameChar;
  }
});

// node_modules/saxes/saxes.js
var require_saxes = __commonJS({
  "node_modules/saxes/saxes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ed5 = require_ed5();
    var ed2 = require_ed2();
    var NSed3 = require_ed3();
    var isS = ed5.isS;
    var isChar10 = ed5.isChar;
    var isNameStartChar = ed5.isNameStartChar;
    var isNameChar = ed5.isNameChar;
    var S_LIST = ed5.S_LIST;
    var NAME_RE = ed5.NAME_RE;
    var isChar11 = ed2.isChar;
    var isNCNameStartChar = NSed3.isNCNameStartChar;
    var isNCNameChar = NSed3.isNCNameChar;
    var NC_NAME_RE = NSed3.NC_NAME_RE;
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      __proto__: null,
      xml: XML_NAMESPACE,
      xmlns: XMLNS_NAMESPACE
    };
    var XML_ENTITIES = {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      __proto__: null,
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    };
    var EOC = -1;
    var NL_LIKE = -2;
    var S_BEGIN = 0;
    var S_BEGIN_WHITESPACE = 1;
    var S_DOCTYPE = 2;
    var S_DOCTYPE_QUOTE = 3;
    var S_DTD = 4;
    var S_DTD_QUOTED = 5;
    var S_DTD_OPEN_WAKA = 6;
    var S_DTD_OPEN_WAKA_BANG = 7;
    var S_DTD_COMMENT = 8;
    var S_DTD_COMMENT_ENDING = 9;
    var S_DTD_COMMENT_ENDED = 10;
    var S_DTD_PI = 11;
    var S_DTD_PI_ENDING = 12;
    var S_TEXT = 13;
    var S_ENTITY = 14;
    var S_OPEN_WAKA = 15;
    var S_OPEN_WAKA_BANG = 16;
    var S_COMMENT = 17;
    var S_COMMENT_ENDING = 18;
    var S_COMMENT_ENDED = 19;
    var S_CDATA = 20;
    var S_CDATA_ENDING = 21;
    var S_CDATA_ENDING_2 = 22;
    var S_PI_FIRST_CHAR = 23;
    var S_PI_REST = 24;
    var S_PI_BODY = 25;
    var S_PI_ENDING = 26;
    var S_XML_DECL_NAME_START = 27;
    var S_XML_DECL_NAME = 28;
    var S_XML_DECL_EQ = 29;
    var S_XML_DECL_VALUE_START = 30;
    var S_XML_DECL_VALUE = 31;
    var S_XML_DECL_SEPARATOR = 32;
    var S_XML_DECL_ENDING = 33;
    var S_OPEN_TAG = 34;
    var S_OPEN_TAG_SLASH = 35;
    var S_ATTRIB = 36;
    var S_ATTRIB_NAME = 37;
    var S_ATTRIB_NAME_SAW_WHITE = 38;
    var S_ATTRIB_VALUE = 39;
    var S_ATTRIB_VALUE_QUOTED = 40;
    var S_ATTRIB_VALUE_CLOSED = 41;
    var S_ATTRIB_VALUE_UNQUOTED = 42;
    var S_CLOSE_TAG = 43;
    var S_CLOSE_TAG_SAW_WHITE = 44;
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    var BANG = 33;
    var DQUOTE = 34;
    var AMP = 38;
    var SQUOTE = 39;
    var MINUS = 45;
    var FORWARD_SLASH = 47;
    var SEMICOLON = 59;
    var LESS = 60;
    var EQUAL = 61;
    var GREATER = 62;
    var QUESTION = 63;
    var OPEN_BRACKET = 91;
    var CLOSE_BRACKET = 93;
    var NEL = 133;
    var LS = 8232;
    var isQuote = (c) => c === DQUOTE || c === SQUOTE;
    var QUOTES = [DQUOTE, SQUOTE];
    var DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
    var DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
    var XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
    var ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];
    function nsPairCheck(parser, prefix, uri) {
      switch (prefix) {
        case "xml":
          if (uri !== XML_NAMESPACE) {
            parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
          }
          break;
        case "xmlns":
          if (uri !== XMLNS_NAMESPACE) {
            parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
          }
          break;
        default:
      }
      switch (uri) {
        case XMLNS_NAMESPACE:
          parser.fail(prefix === "" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even "xmlns") to the URI ${XMLNS_NAMESPACE}.`);
          break;
        case XML_NAMESPACE:
          switch (prefix) {
            case "xml":
              break;
            case "":
              parser.fail(`the default namespace may not be set to ${uri}.`);
              break;
            default:
              parser.fail("may not assign the xml namespace to another prefix.");
          }
          break;
        default:
      }
    }
    function nsMappingCheck(parser, mapping) {
      for (const local of Object.keys(mapping)) {
        nsPairCheck(parser, local, mapping[local]);
      }
    }
    var isNCName = (name) => NC_NAME_RE.test(name);
    var isName = (name) => NAME_RE.test(name);
    var FORBIDDEN_START = 0;
    var FORBIDDEN_BRACKET = 1;
    var FORBIDDEN_BRACKET_BRACKET = 2;
    exports.EVENTS = [
      "xmldecl",
      "text",
      "processinginstruction",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "cdata",
      "error",
      "end",
      "ready"
    ];
    var EVENT_NAME_TO_HANDLER_NAME = {
      xmldecl: "xmldeclHandler",
      text: "textHandler",
      processinginstruction: "piHandler",
      doctype: "doctypeHandler",
      comment: "commentHandler",
      opentagstart: "openTagStartHandler",
      attribute: "attributeHandler",
      opentag: "openTagHandler",
      closetag: "closeTagHandler",
      cdata: "cdataHandler",
      error: "errorHandler",
      end: "endHandler",
      ready: "readyHandler"
    };
    var SaxesParser = class {
      /**
       * @param opt The parser options.
       */
      constructor(opt) {
        this.opt = opt !== null && opt !== void 0 ? opt : {};
        this.fragmentOpt = !!this.opt.fragment;
        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
        this.trackPosition = this.opt.position !== false;
        this.fileName = this.opt.fileName;
        if (xmlnsOpt) {
          this.nameStartCheck = isNCNameStartChar;
          this.nameCheck = isNCNameChar;
          this.isName = isNCName;
          this.processAttribs = this.processAttribsNS;
          this.pushAttrib = this.pushAttribNS;
          this.ns = Object.assign({ __proto__: null }, rootNS);
          const additional = this.opt.additionalNamespaces;
          if (additional != null) {
            nsMappingCheck(this, additional);
            Object.assign(this.ns, additional);
          }
        } else {
          this.nameStartCheck = isNameStartChar;
          this.nameCheck = isNameChar;
          this.isName = isName;
          this.processAttribs = this.processAttribsPlain;
          this.pushAttrib = this.pushAttribPlain;
        }
        this.stateTable = [
          /* eslint-disable @typescript-eslint/unbound-method */
          this.sBegin,
          this.sBeginWhitespace,
          this.sDoctype,
          this.sDoctypeQuote,
          this.sDTD,
          this.sDTDQuoted,
          this.sDTDOpenWaka,
          this.sDTDOpenWakaBang,
          this.sDTDComment,
          this.sDTDCommentEnding,
          this.sDTDCommentEnded,
          this.sDTDPI,
          this.sDTDPIEnding,
          this.sText,
          this.sEntity,
          this.sOpenWaka,
          this.sOpenWakaBang,
          this.sComment,
          this.sCommentEnding,
          this.sCommentEnded,
          this.sCData,
          this.sCDataEnding,
          this.sCDataEnding2,
          this.sPIFirstChar,
          this.sPIRest,
          this.sPIBody,
          this.sPIEnding,
          this.sXMLDeclNameStart,
          this.sXMLDeclName,
          this.sXMLDeclEq,
          this.sXMLDeclValueStart,
          this.sXMLDeclValue,
          this.sXMLDeclSeparator,
          this.sXMLDeclEnding,
          this.sOpenTag,
          this.sOpenTagSlash,
          this.sAttrib,
          this.sAttribName,
          this.sAttribNameSawWhite,
          this.sAttribValue,
          this.sAttribValueQuoted,
          this.sAttribValueClosed,
          this.sAttribValueUnquoted,
          this.sCloseTag,
          this.sCloseTagSawWhite
        ];
        this._init();
      }
      /**
       * Indicates whether or not the parser is closed. If ``true``, wait for
       * the ``ready`` event to write again.
       */
      get closed() {
        return this._closed;
      }
      _init() {
        var _a;
        this.openWakaBang = "";
        this.text = "";
        this.name = "";
        this.piTarget = "";
        this.entity = "";
        this.q = null;
        this.tags = [];
        this.tag = null;
        this.topNS = null;
        this.chunk = "";
        this.chunkPosition = 0;
        this.i = 0;
        this.prevI = 0;
        this.carriedFromPrevious = void 0;
        this.forbiddenState = FORBIDDEN_START;
        this.attribList = [];
        const { fragmentOpt } = this;
        this.state = fragmentOpt ? S_TEXT : S_BEGIN;
        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
        this.xmlDeclPossible = !fragmentOpt;
        this.xmlDeclExpects = ["version"];
        this.entityReturnState = void 0;
        let { defaultXMLVersion } = this.opt;
        if (defaultXMLVersion === void 0) {
          if (this.opt.forceXMLVersion === true) {
            throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
          }
          defaultXMLVersion = "1.0";
        }
        this.setXMLVersion(defaultXMLVersion);
        this.positionAtNewLine = 0;
        this.doctype = false;
        this._closed = false;
        this.xmlDecl = {
          version: void 0,
          encoding: void 0,
          standalone: void 0
        };
        this.line = 1;
        this.column = 0;
        this.ENTITIES = Object.create(XML_ENTITIES);
        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
      }
      /**
       * The stream position the parser is currently looking at. This field is
       * zero-based.
       *
       * This field is not based on counting Unicode characters but is to be
       * interpreted as a plain index into a JavaScript string.
       */
      get position() {
        return this.chunkPosition + this.i;
      }
      /**
       * The column number of the next character to be read by the parser.  *
       * This field is zero-based. (The first column in a line is 0.)
       *
       * This field reports the index at which the next character would be in the
       * line if the line were represented as a JavaScript string.  Note that this
       * *can* be different to a count based on the number of *Unicode characters*
       * due to how JavaScript handles astral plane characters.
       *
       * See [[column]] for a number that corresponds to a count of Unicode
       * characters.
       */
      get columnIndex() {
        return this.position - this.positionAtNewLine;
      }
      /**
       * Set an event listener on an event. The parser supports one handler per
       * event type. If you try to set an event handler over an existing handler,
       * the old handler is silently overwritten.
       *
       * @param name The event to listen to.
       *
       * @param handler The handler to set.
       */
      on(name, handler) {
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
      }
      /**
       * Unset an event handler.
       *
       * @parma name The event to stop listening to.
       */
      off(name) {
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
      }
      /**
       * Make an error object. The error object will have a message that contains
       * the ``fileName`` option passed at the creation of the parser. If position
       * tracking was turned on, it will also have line and column number
       * information.
       *
       * @param message The message describing the error to report.
       *
       * @returns An error object with a properly formatted message.
       */
      makeError(message) {
        var _a;
        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
        if (this.trackPosition) {
          if (msg.length > 0) {
            msg += ":";
          }
          msg += `${this.line}:${this.column}`;
        }
        if (msg.length > 0) {
          msg += ": ";
        }
        return new Error(msg + message);
      }
      /**
       * Report a parsing error. This method is made public so that client code may
       * check for issues that are outside the scope of this project and can report
       * errors.
       *
       * @param message The error to report.
       *
       * @returns this
       */
      fail(message) {
        const err = this.makeError(message);
        const handler = this.errorHandler;
        if (handler === void 0) {
          throw err;
        } else {
          handler(err);
        }
        return this;
      }
      /**
       * Write a XML data to the parser.
       *
       * @param chunk The XML data to write.
       *
       * @returns this
       */
      write(chunk) {
        if (this.closed) {
          return this.fail("cannot write after close; assign an onready handler.");
        }
        let end = false;
        if (chunk === null) {
          end = true;
          chunk = "";
        } else if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        if (this.carriedFromPrevious !== void 0) {
          chunk = `${this.carriedFromPrevious}${chunk}`;
          this.carriedFromPrevious = void 0;
        }
        let limit = chunk.length;
        const lastCode = chunk.charCodeAt(limit - 1);
        if (!end && // A trailing CR or surrogate must be carried over to the next
        // chunk.
        (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
          this.carriedFromPrevious = chunk[limit - 1];
          limit--;
          chunk = chunk.slice(0, limit);
        }
        const { stateTable } = this;
        this.chunk = chunk;
        this.i = 0;
        while (this.i < limit) {
          stateTable[this.state].call(this);
        }
        this.chunkPosition += limit;
        return end ? this.end() : this;
      }
      /**
       * Close the current stream. Perform final well-formedness checks and reset
       * the parser tstate.
       *
       * @returns this
       */
      close() {
        return this.write(null);
      }
      /**
       * Get a single code point out of the current chunk. This updates the current
       * position if we do position tracking.
       *
       * This is the algorithm to use for XML 1.0.
       *
       * @returns The character read.
       */
      getCode10() {
        const { chunk, i } = this;
        this.prevI = i;
        this.i = i + 1;
        if (i >= chunk.length) {
          return EOC;
        }
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 55296) {
          if (code >= SPACE || code === TAB) {
            return code;
          }
          switch (code) {
            case NL:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL;
            case CR:
              if (chunk.charCodeAt(i + 1) === NL) {
                this.i = i + 2;
              }
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL_LIKE;
            default:
              this.fail("disallowed character.");
              return code;
          }
        }
        if (code > 56319) {
          if (!(code >= 57344 && code <= 65533)) {
            this.fail("disallowed character.");
          }
          return code;
        }
        const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
        this.i = i + 2;
        if (final > 1114111) {
          this.fail("disallowed character.");
        }
        return final;
      }
      /**
       * Get a single code point out of the current chunk. This updates the current
       * position if we do position tracking.
       *
       * This is the algorithm to use for XML 1.1.
       *
       * @returns {number} The character read.
       */
      getCode11() {
        const { chunk, i } = this;
        this.prevI = i;
        this.i = i + 1;
        if (i >= chunk.length) {
          return EOC;
        }
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 55296) {
          if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
            return code;
          }
          switch (code) {
            case NL:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL;
            case CR: {
              const next = chunk.charCodeAt(i + 1);
              if (next === NL || next === NEL) {
                this.i = i + 2;
              }
            }
            case NEL:
            case LS:
              this.line++;
              this.column = 0;
              this.positionAtNewLine = this.position;
              return NL_LIKE;
            default:
              this.fail("disallowed character.");
              return code;
          }
        }
        if (code > 56319) {
          if (!(code >= 57344 && code <= 65533)) {
            this.fail("disallowed character.");
          }
          return code;
        }
        const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
        this.i = i + 2;
        if (final > 1114111) {
          this.fail("disallowed character.");
        }
        return final;
      }
      /**
       * Like ``getCode`` but with the return value normalized so that ``NL`` is
       * returned for ``NL_LIKE``.
       */
      getCodeNorm() {
        const c = this.getCode();
        return c === NL_LIKE ? NL : c;
      }
      unget() {
        this.i = this.prevI;
        this.column--;
      }
      /**
       * Capture characters into a buffer until encountering one of a set of
       * characters.
       *
       * @param chars An array of codepoints. Encountering a character in the array
       * ends the capture. (``chars`` may safely contain ``NL``.)
       *
       * @return The character code that made the capture end, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      captureTo(chars) {
        let { i: start } = this;
        const { chunk } = this;
        while (true) {
          const c = this.getCode();
          const isNLLike = c === NL_LIKE;
          const final = isNLLike ? NL : c;
          if (final === EOC || chars.includes(final)) {
            this.text += chunk.slice(start, this.prevI);
            return final;
          }
          if (isNLLike) {
            this.text += `${chunk.slice(start, this.prevI)}
`;
            start = this.i;
          }
        }
      }
      /**
       * Capture characters into a buffer until encountering a character.
       *
       * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
       * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
       *
       * @return ``true`` if we ran into the character. Otherwise, we ran into the
       * end of the current chunk.
       */
      captureToChar(char) {
        let { i: start } = this;
        const { chunk } = this;
        while (true) {
          let c = this.getCode();
          switch (c) {
            case NL_LIKE:
              this.text += `${chunk.slice(start, this.prevI)}
`;
              start = this.i;
              c = NL;
              break;
            case EOC:
              this.text += chunk.slice(start);
              return false;
            default:
          }
          if (c === char) {
            this.text += chunk.slice(start, this.prevI);
            return true;
          }
        }
      }
      /**
       * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
       * this parser.
       *
       * @return The character code that made the test fail, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      captureNameChars() {
        const { chunk, i: start } = this;
        while (true) {
          const c = this.getCode();
          if (c === EOC) {
            this.name += chunk.slice(start);
            return EOC;
          }
          if (!isNameChar(c)) {
            this.name += chunk.slice(start, this.prevI);
            return c === NL_LIKE ? NL : c;
          }
        }
      }
      /**
       * Skip white spaces.
       *
       * @return The character that ended the skip, or ``EOC`` if we hit
       * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
       * instead.
       */
      skipSpaces() {
        while (true) {
          const c = this.getCodeNorm();
          if (c === EOC || !isS(c)) {
            return c;
          }
        }
      }
      setXMLVersion(version) {
        this.currentXMLVersion = version;
        if (version === "1.0") {
          this.isChar = isChar10;
          this.getCode = this.getCode10;
        } else {
          this.isChar = isChar11;
          this.getCode = this.getCode11;
        }
      }
      // STATE ENGINE METHODS
      // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
      // to be sure never to come back to this state later.
      sBegin() {
        if (this.chunk.charCodeAt(0) === 65279) {
          this.i++;
          this.column++;
        }
        this.state = S_BEGIN_WHITESPACE;
      }
      sBeginWhitespace() {
        const iBefore = this.i;
        const c = this.skipSpaces();
        if (this.prevI !== iBefore) {
          this.xmlDeclPossible = false;
        }
        switch (c) {
          case LESS:
            this.state = S_OPEN_WAKA;
            if (this.text.length !== 0) {
              throw new Error("no-empty text at start");
            }
            break;
          case EOC:
            break;
          default:
            this.unget();
            this.state = S_TEXT;
            this.xmlDeclPossible = false;
        }
      }
      sDoctype() {
        var _a;
        const c = this.captureTo(DOCTYPE_TERMINATOR);
        switch (c) {
          case GREATER: {
            (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
            this.state = S_TEXT;
            this.doctype = true;
            break;
          }
          case EOC:
            break;
          default:
            this.text += String.fromCodePoint(c);
            if (c === OPEN_BRACKET) {
              this.state = S_DTD;
            } else if (isQuote(c)) {
              this.state = S_DOCTYPE_QUOTE;
              this.q = c;
            }
        }
      }
      sDoctypeQuote() {
        const q = this.q;
        if (this.captureToChar(q)) {
          this.text += String.fromCodePoint(q);
          this.q = null;
          this.state = S_DOCTYPE;
        }
      }
      sDTD() {
        const c = this.captureTo(DTD_TERMINATOR);
        if (c === EOC) {
          return;
        }
        this.text += String.fromCodePoint(c);
        if (c === CLOSE_BRACKET) {
          this.state = S_DOCTYPE;
        } else if (c === LESS) {
          this.state = S_DTD_OPEN_WAKA;
        } else if (isQuote(c)) {
          this.state = S_DTD_QUOTED;
          this.q = c;
        }
      }
      sDTDQuoted() {
        const q = this.q;
        if (this.captureToChar(q)) {
          this.text += String.fromCodePoint(q);
          this.state = S_DTD;
          this.q = null;
        }
      }
      sDTDOpenWaka() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        switch (c) {
          case BANG:
            this.state = S_DTD_OPEN_WAKA_BANG;
            this.openWakaBang = "";
            break;
          case QUESTION:
            this.state = S_DTD_PI;
            break;
          default:
            this.state = S_DTD;
        }
      }
      sDTDOpenWakaBang() {
        const char = String.fromCodePoint(this.getCodeNorm());
        const owb = this.openWakaBang += char;
        this.text += char;
        if (owb !== "-") {
          this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
          this.openWakaBang = "";
        }
      }
      sDTDComment() {
        if (this.captureToChar(MINUS)) {
          this.text += "-";
          this.state = S_DTD_COMMENT_ENDING;
        }
      }
      sDTDCommentEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
      }
      sDTDCommentEnded() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
          this.state = S_DTD;
        } else {
          this.fail("malformed comment.");
          this.state = S_DTD_COMMENT;
        }
      }
      sDTDPI() {
        if (this.captureToChar(QUESTION)) {
          this.text += "?";
          this.state = S_DTD_PI_ENDING;
        }
      }
      sDTDPIEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
          this.state = S_DTD;
        }
      }
      sText() {
        if (this.tags.length !== 0) {
          this.handleTextInRoot();
        } else {
          this.handleTextOutsideRoot();
        }
      }
      sEntity() {
        let { i: start } = this;
        const { chunk } = this;
        loop:
          while (true) {
            switch (this.getCode()) {
              case NL_LIKE:
                this.entity += `${chunk.slice(start, this.prevI)}
`;
                start = this.i;
                break;
              case SEMICOLON: {
                const { entityReturnState } = this;
                const entity = this.entity + chunk.slice(start, this.prevI);
                this.state = entityReturnState;
                let parsed;
                if (entity === "") {
                  this.fail("empty entity name.");
                  parsed = "&;";
                } else {
                  parsed = this.parseEntity(entity);
                  this.entity = "";
                }
                if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
                  this.text += parsed;
                }
                break loop;
              }
              case EOC:
                this.entity += chunk.slice(start);
                break loop;
              default:
            }
          }
      }
      sOpenWaka() {
        const c = this.getCode();
        if (isNameStartChar(c)) {
          this.state = S_OPEN_TAG;
          this.unget();
          this.xmlDeclPossible = false;
        } else {
          switch (c) {
            case FORWARD_SLASH:
              this.state = S_CLOSE_TAG;
              this.xmlDeclPossible = false;
              break;
            case BANG:
              this.state = S_OPEN_WAKA_BANG;
              this.openWakaBang = "";
              this.xmlDeclPossible = false;
              break;
            case QUESTION:
              this.state = S_PI_FIRST_CHAR;
              break;
            default:
              this.fail("disallowed character in tag name");
              this.state = S_TEXT;
              this.xmlDeclPossible = false;
          }
        }
      }
      sOpenWakaBang() {
        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
        switch (this.openWakaBang) {
          case "[CDATA[":
            if (!this.sawRoot && !this.reportedTextBeforeRoot) {
              this.fail("text data outside of root node.");
              this.reportedTextBeforeRoot = true;
            }
            if (this.closedRoot && !this.reportedTextAfterRoot) {
              this.fail("text data outside of root node.");
              this.reportedTextAfterRoot = true;
            }
            this.state = S_CDATA;
            this.openWakaBang = "";
            break;
          case "--":
            this.state = S_COMMENT;
            this.openWakaBang = "";
            break;
          case "DOCTYPE":
            this.state = S_DOCTYPE;
            if (this.doctype || this.sawRoot) {
              this.fail("inappropriately located doctype declaration.");
            }
            this.openWakaBang = "";
            break;
          default:
            if (this.openWakaBang.length >= 7) {
              this.fail("incorrect syntax.");
            }
        }
      }
      sComment() {
        if (this.captureToChar(MINUS)) {
          this.state = S_COMMENT_ENDING;
        }
      }
      sCommentEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === MINUS) {
          this.state = S_COMMENT_ENDED;
          (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
          this.text = "";
        } else {
          this.text += `-${String.fromCodePoint(c)}`;
          this.state = S_COMMENT;
        }
      }
      sCommentEnded() {
        const c = this.getCodeNorm();
        if (c !== GREATER) {
          this.fail("malformed comment.");
          this.text += `--${String.fromCodePoint(c)}`;
          this.state = S_COMMENT;
        } else {
          this.state = S_TEXT;
        }
      }
      sCData() {
        if (this.captureToChar(CLOSE_BRACKET)) {
          this.state = S_CDATA_ENDING;
        }
      }
      sCDataEnding() {
        const c = this.getCodeNorm();
        if (c === CLOSE_BRACKET) {
          this.state = S_CDATA_ENDING_2;
        } else {
          this.text += `]${String.fromCodePoint(c)}`;
          this.state = S_CDATA;
        }
      }
      sCDataEnding2() {
        var _a;
        const c = this.getCodeNorm();
        switch (c) {
          case GREATER: {
            (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
            this.state = S_TEXT;
            break;
          }
          case CLOSE_BRACKET:
            this.text += "]";
            break;
          default:
            this.text += `]]${String.fromCodePoint(c)}`;
            this.state = S_CDATA;
        }
      }
      // We need this separate state to check the first character fo the pi target
      // with this.nameStartCheck which allows less characters than this.nameCheck.
      sPIFirstChar() {
        const c = this.getCodeNorm();
        if (this.nameStartCheck(c)) {
          this.piTarget += String.fromCodePoint(c);
          this.state = S_PI_REST;
        } else if (c === QUESTION || isS(c)) {
          this.fail("processing instruction without a target.");
          this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
        } else {
          this.fail("disallowed character in processing instruction name.");
          this.piTarget += String.fromCodePoint(c);
          this.state = S_PI_REST;
        }
      }
      sPIRest() {
        const { chunk, i: start } = this;
        while (true) {
          const c = this.getCodeNorm();
          if (c === EOC) {
            this.piTarget += chunk.slice(start);
            return;
          }
          if (!this.nameCheck(c)) {
            this.piTarget += chunk.slice(start, this.prevI);
            const isQuestion = c === QUESTION;
            if (isQuestion || isS(c)) {
              if (this.piTarget === "xml") {
                if (!this.xmlDeclPossible) {
                  this.fail("an XML declaration must be at the start of the document.");
                }
                this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
              } else {
                this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
              }
            } else {
              this.fail("disallowed character in processing instruction name.");
              this.piTarget += String.fromCodePoint(c);
            }
            break;
          }
        }
      }
      sPIBody() {
        if (this.text.length === 0) {
          const c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_PI_ENDING;
          } else if (!isS(c)) {
            this.text = String.fromCodePoint(c);
          }
        } else if (this.captureToChar(QUESTION)) {
          this.state = S_PI_ENDING;
        }
      }
      sPIEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
          const { piTarget } = this;
          if (piTarget.toLowerCase() === "xml") {
            this.fail("the XML declaration must appear at the start of the document.");
          }
          (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
            target: piTarget,
            body: this.text
          });
          this.piTarget = this.text = "";
          this.state = S_TEXT;
        } else if (c === QUESTION) {
          this.text += "?";
        } else {
          this.text += `?${String.fromCodePoint(c)}`;
          this.state = S_PI_BODY;
        }
        this.xmlDeclPossible = false;
      }
      sXMLDeclNameStart() {
        const c = this.skipSpaces();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          return;
        }
        if (c !== EOC) {
          this.state = S_XML_DECL_NAME;
          this.name = String.fromCodePoint(c);
        }
      }
      sXMLDeclName() {
        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.name += this.text;
          this.text = "";
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (!(isS(c) || c === EQUAL)) {
          return;
        }
        this.name += this.text;
        this.text = "";
        if (!this.xmlDeclExpects.includes(this.name)) {
          switch (this.name.length) {
            case 0:
              this.fail("did not expect any more name/value pairs.");
              break;
            case 1:
              this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
              break;
            default:
              this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
          }
        }
        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
      }
      sXMLDeclEq() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (isS(c)) {
          return;
        }
        if (c !== EQUAL) {
          this.fail("value required.");
        }
        this.state = S_XML_DECL_VALUE_START;
      }
      sXMLDeclValueStart() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (isS(c)) {
          return;
        }
        if (!isQuote(c)) {
          this.fail("value must be quoted.");
          this.q = SPACE;
        } else {
          this.q = c;
        }
        this.state = S_XML_DECL_VALUE;
      }
      sXMLDeclValue() {
        const c = this.captureTo([this.q, QUESTION]);
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          this.text = "";
          this.fail("XML declaration is incomplete.");
          return;
        }
        if (c === EOC) {
          return;
        }
        const value = this.text;
        this.text = "";
        switch (this.name) {
          case "version": {
            this.xmlDeclExpects = ["encoding", "standalone"];
            const version = value;
            this.xmlDecl.version = version;
            if (!/^1\.[0-9]+$/.test(version)) {
              this.fail("version number must match /^1\\.[0-9]+$/.");
            } else if (!this.opt.forceXMLVersion) {
              this.setXMLVersion(version);
            }
            break;
          }
          case "encoding":
            if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
              this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
            }
            this.xmlDeclExpects = ["standalone"];
            this.xmlDecl.encoding = value;
            break;
          case "standalone":
            if (value !== "yes" && value !== "no") {
              this.fail('standalone value must match "yes" or "no".');
            }
            this.xmlDeclExpects = [];
            this.xmlDecl.standalone = value;
            break;
          default:
        }
        this.name = "";
        this.state = S_XML_DECL_SEPARATOR;
      }
      sXMLDeclSeparator() {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_XML_DECL_ENDING;
          return;
        }
        if (!isS(c)) {
          this.fail("whitespace required.");
          this.unget();
        }
        this.state = S_XML_DECL_NAME_START;
      }
      sXMLDeclEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
          if (this.piTarget !== "xml") {
            this.fail("processing instructions are not allowed before root.");
          } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
            this.fail("XML declaration must contain a version.");
          }
          (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
          this.name = "";
          this.piTarget = this.text = "";
          this.state = S_TEXT;
        } else {
          this.fail("The character ? is disallowed anywhere in XML declarations.");
        }
        this.xmlDeclPossible = false;
      }
      sOpenTag() {
        var _a;
        const c = this.captureNameChars();
        if (c === EOC) {
          return;
        }
        const tag = this.tag = {
          name: this.name,
          attributes: /* @__PURE__ */ Object.create(null)
        };
        this.name = "";
        if (this.xmlnsOpt) {
          this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
        }
        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        this.sawRoot = true;
        if (!this.fragmentOpt && this.closedRoot) {
          this.fail("documents may contain only one root.");
        }
        switch (c) {
          case GREATER:
            this.openTag();
            break;
          case FORWARD_SLASH:
            this.state = S_OPEN_TAG_SLASH;
            break;
          default:
            if (!isS(c)) {
              this.fail("disallowed character in tag name.");
            }
            this.state = S_ATTRIB;
        }
      }
      sOpenTagSlash() {
        if (this.getCode() === GREATER) {
          this.openSelfClosingTag();
        } else {
          this.fail("forward-slash in opening tag not followed by >.");
          this.state = S_ATTRIB;
        }
      }
      sAttrib() {
        const c = this.skipSpaces();
        if (c === EOC) {
          return;
        }
        if (isNameStartChar(c)) {
          this.unget();
          this.state = S_ATTRIB_NAME;
        } else if (c === GREATER) {
          this.openTag();
        } else if (c === FORWARD_SLASH) {
          this.state = S_OPEN_TAG_SLASH;
        } else {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribName() {
        const c = this.captureNameChars();
        if (c === EQUAL) {
          this.state = S_ATTRIB_VALUE;
        } else if (isS(c)) {
          this.state = S_ATTRIB_NAME_SAW_WHITE;
        } else if (c === GREATER) {
          this.fail("attribute without value.");
          this.pushAttrib(this.name, this.name);
          this.name = this.text = "";
          this.openTag();
        } else if (c !== EOC) {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribNameSawWhite() {
        const c = this.skipSpaces();
        switch (c) {
          case EOC:
            return;
          case EQUAL:
            this.state = S_ATTRIB_VALUE;
            break;
          default:
            this.fail("attribute without value.");
            this.text = "";
            this.name = "";
            if (c === GREATER) {
              this.openTag();
            } else if (isNameStartChar(c)) {
              this.unget();
              this.state = S_ATTRIB_NAME;
            } else {
              this.fail("disallowed character in attribute name.");
              this.state = S_ATTRIB;
            }
        }
      }
      sAttribValue() {
        const c = this.getCodeNorm();
        if (isQuote(c)) {
          this.q = c;
          this.state = S_ATTRIB_VALUE_QUOTED;
        } else if (!isS(c)) {
          this.fail("unquoted attribute value.");
          this.state = S_ATTRIB_VALUE_UNQUOTED;
          this.unget();
        }
      }
      sAttribValueQuoted() {
        const { q, chunk } = this;
        let { i: start } = this;
        while (true) {
          switch (this.getCode()) {
            case q:
              this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
              this.name = this.text = "";
              this.q = null;
              this.state = S_ATTRIB_VALUE_CLOSED;
              return;
            case AMP:
              this.text += chunk.slice(start, this.prevI);
              this.state = S_ENTITY;
              this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
              return;
            case NL:
            case NL_LIKE:
            case TAB:
              this.text += `${chunk.slice(start, this.prevI)} `;
              start = this.i;
              break;
            case LESS:
              this.text += chunk.slice(start, this.prevI);
              this.fail("disallowed character.");
              return;
            case EOC:
              this.text += chunk.slice(start);
              return;
            default:
          }
        }
      }
      sAttribValueClosed() {
        const c = this.getCodeNorm();
        if (isS(c)) {
          this.state = S_ATTRIB;
        } else if (c === GREATER) {
          this.openTag();
        } else if (c === FORWARD_SLASH) {
          this.state = S_OPEN_TAG_SLASH;
        } else if (isNameStartChar(c)) {
          this.fail("no whitespace between attributes.");
          this.unget();
          this.state = S_ATTRIB_NAME;
        } else {
          this.fail("disallowed character in attribute name.");
        }
      }
      sAttribValueUnquoted() {
        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
        switch (c) {
          case AMP:
            this.state = S_ENTITY;
            this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
            break;
          case LESS:
            this.fail("disallowed character.");
            break;
          case EOC:
            break;
          default:
            if (this.text.includes("]]>")) {
              this.fail('the string "]]>" is disallowed in char data.');
            }
            this.pushAttrib(this.name, this.text);
            this.name = this.text = "";
            if (c === GREATER) {
              this.openTag();
            } else {
              this.state = S_ATTRIB;
            }
        }
      }
      sCloseTag() {
        const c = this.captureNameChars();
        if (c === GREATER) {
          this.closeTag();
        } else if (isS(c)) {
          this.state = S_CLOSE_TAG_SAW_WHITE;
        } else if (c !== EOC) {
          this.fail("disallowed character in closing tag.");
        }
      }
      sCloseTagSawWhite() {
        switch (this.skipSpaces()) {
          case GREATER:
            this.closeTag();
            break;
          case EOC:
            break;
          default:
            this.fail("disallowed character in closing tag.");
        }
      }
      // END OF STATE ENGINE METHODS
      handleTextInRoot() {
        let { i: start, forbiddenState } = this;
        const { chunk, textHandler: handler } = this;
        scanLoop:
          while (true) {
            switch (this.getCode()) {
              case LESS: {
                this.state = S_OPEN_WAKA;
                if (handler !== void 0) {
                  const { text } = this;
                  const slice = chunk.slice(start, this.prevI);
                  if (text.length !== 0) {
                    handler(text + slice);
                    this.text = "";
                  } else if (slice.length !== 0) {
                    handler(slice);
                  }
                }
                forbiddenState = FORBIDDEN_START;
                break scanLoop;
              }
              case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_TEXT;
                if (handler !== void 0) {
                  this.text += chunk.slice(start, this.prevI);
                }
                forbiddenState = FORBIDDEN_START;
                break scanLoop;
              case CLOSE_BRACKET:
                switch (forbiddenState) {
                  case FORBIDDEN_START:
                    forbiddenState = FORBIDDEN_BRACKET;
                    break;
                  case FORBIDDEN_BRACKET:
                    forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                    break;
                  case FORBIDDEN_BRACKET_BRACKET:
                    break;
                  default:
                    throw new Error("impossible state");
                }
                break;
              case GREATER:
                if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                  this.fail('the string "]]>" is disallowed in char data.');
                }
                forbiddenState = FORBIDDEN_START;
                break;
              case NL_LIKE:
                if (handler !== void 0) {
                  this.text += `${chunk.slice(start, this.prevI)}
`;
                }
                start = this.i;
                forbiddenState = FORBIDDEN_START;
                break;
              case EOC:
                if (handler !== void 0) {
                  this.text += chunk.slice(start);
                }
                break scanLoop;
              default:
                forbiddenState = FORBIDDEN_START;
            }
          }
        this.forbiddenState = forbiddenState;
      }
      handleTextOutsideRoot() {
        let { i: start } = this;
        const { chunk, textHandler: handler } = this;
        let nonSpace = false;
        outRootLoop:
          while (true) {
            const code = this.getCode();
            switch (code) {
              case LESS: {
                this.state = S_OPEN_WAKA;
                if (handler !== void 0) {
                  const { text } = this;
                  const slice = chunk.slice(start, this.prevI);
                  if (text.length !== 0) {
                    handler(text + slice);
                    this.text = "";
                  } else if (slice.length !== 0) {
                    handler(slice);
                  }
                }
                break outRootLoop;
              }
              case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_TEXT;
                if (handler !== void 0) {
                  this.text += chunk.slice(start, this.prevI);
                }
                nonSpace = true;
                break outRootLoop;
              case NL_LIKE:
                if (handler !== void 0) {
                  this.text += `${chunk.slice(start, this.prevI)}
`;
                }
                start = this.i;
                break;
              case EOC:
                if (handler !== void 0) {
                  this.text += chunk.slice(start);
                }
                break outRootLoop;
              default:
                if (!isS(code)) {
                  nonSpace = true;
                }
            }
          }
        if (!nonSpace) {
          return;
        }
        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextBeforeRoot = true;
        }
        if (this.closedRoot && !this.reportedTextAfterRoot) {
          this.fail("text data outside of root node.");
          this.reportedTextAfterRoot = true;
        }
      }
      pushAttribNS(name, value) {
        var _a;
        const { prefix, local } = this.qname(name);
        const attr = { name, prefix, local, value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
        if (prefix === "xmlns") {
          const trimmed = value.trim();
          if (this.currentXMLVersion === "1.0" && trimmed === "") {
            this.fail("invalid attempt to undefine prefix in XML 1.0");
          }
          this.topNS[local] = trimmed;
          nsPairCheck(this, local, trimmed);
        } else if (name === "xmlns") {
          const trimmed = value.trim();
          this.topNS[""] = trimmed;
          nsPairCheck(this, "", trimmed);
        }
      }
      pushAttribPlain(name, value) {
        var _a;
        const attr = { name, value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
      }
      /**
       * End parsing. This performs final well-formedness checks and resets the
       * parser to a clean state.
       *
       * @returns this
       */
      end() {
        var _a, _b;
        if (!this.sawRoot) {
          this.fail("document must contain a root element.");
        }
        const { tags } = this;
        while (tags.length > 0) {
          const tag = tags.pop();
          this.fail(`unclosed tag: ${tag.name}`);
        }
        if (this.state !== S_BEGIN && this.state !== S_TEXT) {
          this.fail("unexpected end.");
        }
        const { text } = this;
        if (text.length !== 0) {
          (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
          this.text = "";
        }
        this._closed = true;
        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
        this._init();
        return this;
      }
      /**
       * Resolve a namespace prefix.
       *
       * @param prefix The prefix to resolve.
       *
       * @returns The namespace URI or ``undefined`` if the prefix is not defined.
       */
      resolve(prefix) {
        var _a, _b;
        let uri = this.topNS[prefix];
        if (uri !== void 0) {
          return uri;
        }
        const { tags } = this;
        for (let index = tags.length - 1; index >= 0; index--) {
          uri = tags[index].ns[prefix];
          if (uri !== void 0) {
            return uri;
          }
        }
        uri = this.ns[prefix];
        if (uri !== void 0) {
          return uri;
        }
        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
      }
      /**
       * Parse a qname into its prefix and local name parts.
       *
       * @param name The name to parse
       *
       * @returns
       */
      qname(name) {
        const colon = name.indexOf(":");
        if (colon === -1) {
          return { prefix: "", local: name };
        }
        const local = name.slice(colon + 1);
        const prefix = name.slice(0, colon);
        if (prefix === "" || local === "" || local.includes(":")) {
          this.fail(`malformed name: ${name}.`);
        }
        return { prefix, local };
      }
      processAttribsNS() {
        var _a;
        const { attribList } = this;
        const tag = this.tag;
        {
          const { prefix, local } = this.qname(tag.name);
          tag.prefix = prefix;
          tag.local = local;
          const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
          if (prefix !== "") {
            if (prefix === "xmlns") {
              this.fail('tags may not have "xmlns" as prefix.');
            }
            if (uri === "") {
              this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
              tag.uri = prefix;
            }
          }
        }
        if (attribList.length === 0) {
          return;
        }
        const { attributes } = tag;
        const seen = /* @__PURE__ */ new Set();
        for (const attr of attribList) {
          const { name, prefix, local } = attr;
          let uri;
          let eqname;
          if (prefix === "") {
            uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
            eqname = name;
          } else {
            uri = this.resolve(prefix);
            if (uri === void 0) {
              this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
              uri = prefix;
            }
            eqname = `{${uri}}${local}`;
          }
          if (seen.has(eqname)) {
            this.fail(`duplicate attribute: ${eqname}.`);
          }
          seen.add(eqname);
          attr.uri = uri;
          attributes[name] = attr;
        }
        this.attribList = [];
      }
      processAttribsPlain() {
        const { attribList } = this;
        const attributes = this.tag.attributes;
        for (const { name, value } of attribList) {
          if (attributes[name] !== void 0) {
            this.fail(`duplicate attribute: ${name}.`);
          }
          attributes[name] = value;
        }
        this.attribList = [];
      }
      /**
       * Handle a complete open tag. This parser code calls this once it has seen
       * the whole tag. This method checks for well-formeness and then emits
       * ``onopentag``.
       */
      openTag() {
        var _a;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = false;
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        tags.push(tag);
        this.state = S_TEXT;
        this.name = "";
      }
      /**
       * Handle a complete self-closing tag. This parser code calls this once it has
       * seen the whole tag. This method checks for well-formeness and then emits
       * ``onopentag`` and ``onclosetag``.
       */
      openSelfClosingTag() {
        var _a, _b, _c;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = true;
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
        if (top === null) {
          this.closedRoot = true;
        }
        this.state = S_TEXT;
        this.name = "";
      }
      /**
       * Handle a complete close tag. This parser code calls this once it has seen
       * the whole tag. This method checks for well-formeness and then emits
       * ``onclosetag``.
       */
      closeTag() {
        const { tags, name } = this;
        this.state = S_TEXT;
        this.name = "";
        if (name === "") {
          this.fail("weird empty close tag.");
          this.text += "</>";
          return;
        }
        const handler = this.closeTagHandler;
        let l = tags.length;
        while (l-- > 0) {
          const tag = this.tag = tags.pop();
          this.topNS = tag.ns;
          handler === null || handler === void 0 ? void 0 : handler(tag);
          if (tag.name === name) {
            break;
          }
          this.fail("unexpected close tag.");
        }
        if (l === 0) {
          this.closedRoot = true;
        } else if (l < 0) {
          this.fail(`unmatched closing tag: ${name}.`);
          this.text += `</${name}>`;
        }
      }
      /**
       * Resolves an entity. Makes any necessary well-formedness checks.
       *
       * @param entity The entity to resolve.
       *
       * @returns The parsed entity.
       */
      parseEntity(entity) {
        if (entity[0] !== "#") {
          const defined = this.ENTITIES[entity];
          if (defined !== void 0) {
            return defined;
          }
          this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
          return `&${entity};`;
        }
        let num = NaN;
        if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
          num = parseInt(entity.slice(2), 16);
        } else if (/^#[0-9]+$/.test(entity)) {
          num = parseInt(entity.slice(1), 10);
        }
        if (!this.isChar(num)) {
          this.fail("malformed character entity.");
          return `&${entity};`;
        }
        return String.fromCodePoint(num);
      }
    };
    exports.SaxesParser = SaxesParser;
  }
});

// node_modules/@jscad/amf-deserializer/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/helpers.js"(exports, module) {
    var amfMesh = (element) => {
      const obj = { type: "mesh" };
      obj.objects = [];
      return obj;
    };
    var amfVertices = (element) => {
      const obj = { type: "vertices" };
      obj.objects = [];
      return obj;
    };
    var amfCoordinates = (element) => {
      const obj = { type: "coordinates" };
      obj.objects = [];
      return obj;
    };
    var amfNormal = (element) => {
      const obj = { type: "normal" };
      obj.objects = [];
      return obj;
    };
    var amfX = (element) => ({ type: "x", value: "0" });
    var amfY = (element) => ({ type: "y", value: "0" });
    var amfZ = (element) => ({ type: "z", value: "0" });
    var amfVolume = (element) => {
      const obj = { type: "volume" };
      if (element.materialid) {
        obj.materialid = element.materialid;
      }
      obj.objects = [];
      return obj;
    };
    var amfTriangle = (element) => {
      const obj = { type: "triangle" };
      obj.objects = [];
      return obj;
    };
    var amfV1 = (element) => ({ type: "v1", value: "0" });
    var amfV2 = (element) => ({ type: "v2", value: "0" });
    var amfV3 = (element) => ({ type: "v3", value: "0" });
    var amfVertex = (element) => {
      const obj = { type: "vertex" };
      obj.objects = [];
      return obj;
    };
    var amfEdge = (element) => {
      const obj = { type: "edge" };
      obj.objects = [];
      return obj;
    };
    var amfMetadata = (element) => {
      const obj = { type: "metadata" };
      if (element.type) {
        obj.mtype = element.type;
      }
      if (element.id) {
        obj.id = element.id;
      }
      return obj;
    };
    var amfMaterial = (element) => {
      const obj = { type: "material" };
      if (element.id) {
        obj.id = element.id;
      }
      obj.objects = [];
      return obj;
    };
    var amfColor = (element) => {
      const obj = { type: "color" };
      obj.objects = [];
      return obj;
    };
    var amfR = (element) => ({ type: "r", value: "1" });
    var amfG = (element) => ({ type: "g", value: "1" });
    var amfB = (element) => ({ type: "b", value: "1" });
    var amfA = (element) => ({ type: "a", value: "1" });
    var amfMap = (element) => {
      const obj = { type: "map" };
      if (element.gtexid) {
        obj.gtexid = element.gtexid;
      }
      if (element.btexid) {
        obj.btexid = element.btexid;
      }
      if (element.rtexid) {
        obj.rtexid = element.rtexid;
      }
      obj.objects = [];
      return obj;
    };
    var amfU1 = (element) => ({ type: "u1", value: "0" });
    var amfU2 = (element) => ({ type: "u2", value: "0" });
    var amfU3 = (element) => ({ type: "u3", value: "0" });
    module.exports = {
      amfMesh,
      amfVertices,
      amfCoordinates,
      amfX,
      amfY,
      amfZ,
      amfNormal,
      amfVolume,
      amfTriangle,
      amfV1,
      amfV2,
      amfV3,
      amfVertex,
      amfEdge,
      amfMetadata,
      amfMaterial,
      amfColor,
      amfR,
      amfG,
      amfB,
      amfA,
      amfMap,
      amfU1,
      amfU2,
      amfU3
    };
  }
});

// node_modules/@jscad/amf-deserializer/src/constants.js
var require_constants = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/constants.js"(exports, module) {
    var inchMM = 1 / 0.03937;
    module.exports = {
      inchMM
    };
  }
});

// node_modules/@jscad/amf-deserializer/src/parse.js
var require_parse = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/parse.js"(exports, module) {
    var saxes = require_saxes();
    var {
      amfMesh,
      amfVertices,
      amfCoordinates,
      amfX,
      amfY,
      amfZ,
      amfNormal,
      amfVolume,
      amfTriangle,
      amfV1,
      amfV2,
      amfV3,
      amfVertex,
      amfEdge,
      amfMetadata,
      amfMaterial,
      amfColor,
      amfR,
      amfG,
      amfB,
      amfA,
      amfMap,
      amfU1,
      amfU2,
      amfU3
    } = require_helpers();
    var { inchMM } = require_constants();
    var amfLast = null;
    var amfDefinition = 0;
    var amfObjects = [];
    var amfMaterials = [];
    var amfTextures = [];
    var amfConstels = [];
    var amfObj = null;
    var amfAmf = (element) => {
      const obj = { type: "amf", unit: "mm", scale: 1 };
      if (element.unit) {
        obj.unit = element.unit.toLowerCase();
      }
      switch (obj.unit.toLowerCase()) {
        case "inch":
          obj.scale = inchMM;
          break;
        case "foot":
          obj.scale = inchMM * 12;
          break;
        case "meter":
          obj.scale = 1e3;
          break;
        case "micron":
          obj.scale = 1e-3;
          break;
        case "millimeter":
        default:
          break;
      }
      obj.objects = [];
      return obj;
    };
    var amfObject = (element) => {
      const obj = { type: "object", id: `JSCAD${amfObjects.length}` };
      if (element.id) {
        obj.id = element.id;
      }
      obj.objects = [];
      return obj;
    };
    var createAmfParser = (src, pxPmm) => {
      const parser = new saxes.SaxesParser();
      parser.on("error", (e) => {
        console.log(`ERROR: AMF file line ${e.line}, column ${e.column}, bad character [${e.c}]`);
      });
      parser.on("opentag", (node) => {
        const objMap = {
          AMF: amfAmf,
          OBJECT: (node2) => {
            const tmp = amfObject(node2);
            if (amfDefinition === 0)
              amfDefinition = 1;
            return tmp;
          },
          //
          MESH: amfMesh,
          VERTICES: amfVertices,
          VERTEX: amfVertex,
          EDGE: amfEdge,
          VOLUME: amfVolume,
          MATERIAL: (node2) => {
            const tmp = amfMaterial(node2);
            if (amfDefinition === 0)
              amfDefinition = 2;
            return tmp;
          },
          TEXTURE: (node2) => {
            if (amfDefinition === 0)
              amfDefinition = 3;
          },
          CONSTELLATION: (node2) => {
            if (amfDefinition === 0)
              amfDefinition = 4;
          },
          METADATA: (node2) => {
            const tmp = amfMetadata(node2);
            if (amfDefinition === 0)
              amfDefinition = 5;
            return tmp;
          },
          COORDINATES: amfCoordinates,
          NORMAL: amfNormal,
          NX: amfX,
          X: amfX,
          NY: amfY,
          Y: amfY,
          NZ: amfZ,
          Z: amfZ,
          TRIANGLE: amfTriangle,
          V1: amfV1,
          VTEX1: amfV1,
          V2: amfV2,
          VTEX2: amfV2,
          V3: amfV3,
          VTEX3: amfV3,
          COLOR: amfColor,
          R: amfR,
          G: amfG,
          B: amfB,
          A: amfA,
          MAP: amfMap,
          TEXMAP: amfMap,
          U1: amfU1,
          UTEX1: amfU1,
          WTEX1: amfU1,
          U2: amfU2,
          UTEX2: amfU2,
          WTEX2: amfU2,
          U3: amfU3,
          UTEX3: amfU3,
          WTEX3: amfU3,
          COMPOSITE: () => void 0,
          // ignored by design
          undefined: () => console.log(`WARNING: unsupported AMF element: ${node.name}`)
        };
        const elementName = node.name.toUpperCase();
        const obj = objMap[elementName] ? objMap[elementName](node.attributes, { amfObjects }) : null;
        if (obj) {
          switch (amfDefinition) {
            case 0:
              if ("objects" in obj) {
                amfObjects.push(obj);
              }
              break;
            case 1:
              if (amfObjects.length > 0) {
                const group = amfObjects.pop();
                if ("objects" in group) {
                  group.objects.push(obj);
                }
                amfObjects.push(group);
                if ("objects" in obj) {
                  amfObjects.push(obj);
                }
              }
              break;
            case 2:
              if (obj.type === "material") {
                amfMaterials.push(obj);
              } else {
                if (amfMaterials.length > 0) {
                  const group = amfMaterials.pop();
                  if ("objects" in group) {
                    group.objects.push(obj);
                  }
                  amfMaterials.push(group);
                  if ("objects" in obj) {
                    amfMaterials.push(obj);
                  }
                }
              }
              break;
            case 3:
              break;
            case 4:
              break;
            case 5:
              break;
            default:
              console.log("WARNING: invalid AMF definition");
              break;
          }
          amfLast = obj;
        }
      });
      parser.on("closetag", (node) => {
        const elementName = node.name.toUpperCase();
        switch (elementName) {
          case "AMF":
          case "OBJECT":
          case "MESH":
          case "VERTICES":
          case "VERTEX":
          case "EDGE":
          case "COORDINATES":
          case "NORMAL":
          case "VOLUME":
          case "TRIANGLE":
          case "MATERIAL":
          case "COLOR":
          case "MAP":
          case "TEXMAP":
            break;
          case "TEXTURE":
            if (amfDefinition === 3) {
              amfDefinition = 0;
            }
            return;
          case "CONSTELLATION":
            if (amfDefinition === 4) {
              amfDefinition = 0;
            }
            return;
          case "METADATA":
            if (amfDefinition === 5) {
              amfDefinition = 0;
            }
            return;
          default:
            return;
        }
        let obj = null;
        switch (amfDefinition) {
          case 0:
          case 1:
            if (amfObjects.length > 0) {
              obj = amfObjects.pop();
              if (obj.type === "object") {
                amfDefinition = 0;
              }
            }
            if (amfObjects.length === 0) {
              amfObj = obj;
            }
            break;
          case 2:
            if (amfMaterials.length > 0) {
              obj = amfMaterials.pop();
              if (obj.type === "material") {
                amfMaterials.push(obj);
                amfDefinition = 0;
              }
            }
            break;
          case 3:
            amfDefinition = 0;
            break;
          case 4:
            amfDefinition = 0;
            break;
          case 5:
            amfDefinition = 0;
            break;
          default:
            break;
        }
      });
      parser.on("text", (value) => {
        if (value !== null) {
          value = value.trim();
          if (value.length > 0 && amfLast && amfDefinition !== 0) {
            amfLast.value = value;
            amfLast = null;
          }
        }
      });
      parser.on("end", () => {
      });
      parser.write(src).close();
    };
    var parse = (src, pxPmm) => {
      createAmfParser(src, pxPmm);
      return { amfObj, amfMaterials, amfTextures, amfConstels };
    };
    module.exports = parse;
  }
});

// node_modules/@jscad/amf-deserializer/src/translate.js
var require_translate = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/translate.js"(exports, module) {
    var createObject = require_objectBuilder();
    var parse = require_parse();
    var translate = (options, src) => {
      const defaults = {
        pxPmm: require_constants().pxPmm
      };
      options = Object.assign({}, defaults, options);
      const { version, pxPmm, addMetaData, filename } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      const { amfObj, amfMaterials, amfTextures, amfConstels } = parse(src, pxPmm);
      let code = addMetaData ? `//
// Produced by JSCAD IO Library : AMF Deserializer (${version})
// date: ${/* @__PURE__ */ new Date()}
// source: ${filename}
//
` : "";
      if (!amfObj) {
        throw new Error("AMF parsing failed, no valid AMF data retrieved");
      }
      options && options.statusCallback && options.statusCallback({ progress: 50 });
      code += codify(amfObj, { amfMaterials, amfTextures, amfConstels });
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return code;
    };
    var codify = (amf, data) => {
      if (amf.type !== "amf" || !amf.objects)
        throw new Error("AMF parsing failed, malformed");
      let code = "";
      const objects = amf.objects;
      const materials = data.amfMaterials;
      const createDefinition = (object, index) => {
        switch (object.type) {
          case "object":
            code += createObject(object, index, data, { instantiate: false, scale: amf.scale });
            break;
          case "metadata":
            break;
          case "material":
            break;
          default:
            console.log("WARNING: unknown object type: " + object.type);
            break;
        }
      };
      code = `// Objects  : ${objects.length}
// Materials: ${materials.length}
// Scale    : ${amf.scale} from Units (${amf.unit})

const {colors, geometries, transforms} = require('@jscad/modeling')

const main = () => {
  let objects = []
`;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        if (obj.type === "object") {
          code += `  objects.push(createObject${obj.id}())
`;
        }
      }
      code += "  return objects\n}\n";
      objects.forEach(createDefinition);
      code += "module.exports = {main}\n";
      return code;
    };
    module.exports = translate;
  }
});

// node_modules/@jscad/amf-deserializer/src/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/deserialize.js"(exports, module) {
    var createObject = require_objectBuilder();
    var parse = require_parse();
    var instantiate = (options, src) => {
      const defaults = {
        pxPmm: require_constants().pxPmm
      };
      options = Object.assign({}, defaults, options);
      const { pxPmm } = options;
      const { amfObj, amfMaterials, amfTextures, amfConstels } = parse(src, pxPmm);
      if (!amfObj) {
        throw new Error("AMF parsing failed, no valid AMF data retrieved");
      }
      return objectify(amfObj, { amfMaterials, amfTextures, amfConstels });
    };
    var objectify = (amf, data) => {
      const objects = amf.objects.filter((o) => o.type === "object");
      return objects.map((object, index) => createObject(object, index, data, { amf, instantiate: true }));
    };
    module.exports = instantiate;
  }
});

// node_modules/@jscad/amf-deserializer/src/index.js
var require_src5 = __commonJS({
  "node_modules/@jscad/amf-deserializer/src/index.js"(exports, module) {
    var version = require_package2().version;
    var translate = require_translate();
    var instantiate = require_deserialize();
    var deserialize = (options, input) => {
      const defaults = {
        filename: "amf",
        output: "script",
        version,
        addMetaData: true
      };
      options = Object.assign({}, defaults, options);
      return options.output === "script" ? translate(options, input) : instantiate(options, input);
    };
    var extension = "amf";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/dxf-deserializer/package.json
var require_package3 = __commonJS({
  "node_modules/@jscad/dxf-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/dxf-deserializer",
      version: "2.3.22",
      description: "DXF Deserializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m './tests/test*.js'"
      },
      contributors: [
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "dxf"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/modeling": "2.12.0"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/dxf-deserializer/autocad.js
var require_autocad = __commonJS({
  "node_modules/@jscad/dxf-deserializer/autocad.js"(exports, module) {
    var dxfTLA = [
      [0, "etyp"],
      [1, "text"],
      [2, "name"],
      [3, "nam1"],
      [5, "hdle"],
      [6, "ltyp"],
      [7, "lsty"],
      [8, "lnam"],
      [9, "vari"],
      [10, "pptx"],
      [11, "sptx"],
      [12, "tptx"],
      [13, "fptx"],
      [20, "ppty"],
      [21, "spty"],
      [22, "tpty"],
      [23, "fpty"],
      [30, "pptz"],
      [31, "sptz"],
      [32, "tptz"],
      [33, "fptz"],
      [38, "elev"],
      [39, "lthk"],
      [40, "swid"],
      [41, "ewid"],
      [42, "bulg"],
      [43, "cwid"],
      [48, "lscl"],
      [50, "ang0"],
      [51, "ang1"],
      [60, "visb"],
      [62, "cnmb"],
      [67, "spac"],
      [70, "lflg"],
      [71, "fvia"],
      [72, "fvib"],
      [73, "fvic"],
      [74, "fvid"],
      [75, "cflg"],
      [90, "vlen"],
      [91, "slen"],
      [92, "plen"],
      [93, "flen"],
      [94, "elen"],
      [95, "clen"],
      [100, "sbnm"],
      [210, "etrx"],
      [220, "etry"],
      [230, "etrz"]
    ];
    var dxfMap = new Map(dxfTLA);
    var getTLA = (group) => dxfMap.get(group);
    var drawingUnits = [
      [0, "none"],
      [1, "inches"],
      [2, "feet"],
      [3, "miles"],
      [4, "millimeters"],
      [5, "centimeters"],
      [6, "meters"],
      [7, "kilometers"],
      [8, "microinches"],
      [9, "mils"],
      [10, "yards"],
      [11, "angstroms"],
      [12, "nanometers"],
      [13, "microns"],
      [14, "decimeters"],
      [15, "dekameters"],
      [16, "hectometers"],
      [17, "gigameters"],
      [18, "astrounits"],
      [19, "lightyears"],
      [20, "parsecs"]
    ];
    var BYBLOCK = 0;
    var BYLAYER = 256;
    module.exports = {
      drawingUnits,
      BYBLOCK,
      BYLAYER,
      getTLA
    };
  }
});

// node_modules/@jscad/dxf-deserializer/colorindex2017.js
var require_colorindex20172 = __commonJS({
  "node_modules/@jscad/dxf-deserializer/colorindex2017.js"(exports, module) {
    var colorIndex = [
      [0, 0, 0, 255],
      // index 0, added for easy maintenance
      // 1
      [255, 0, 0, 255],
      [255, 255, 0, 255],
      [0, 255, 0, 255],
      [0, 255, 255, 255],
      [0, 0, 255, 255],
      [255, 0, 255, 255],
      [255, 255, 255, 255],
      [128, 128, 128, 255],
      [192, 192, 192, 255],
      [255, 0, 0, 255],
      // 11
      [255, 127, 127, 255],
      [165, 0, 0, 255],
      [165, 82, 82, 255],
      [127, 0, 0, 255],
      [127, 63, 63, 255],
      [76, 0, 0, 255],
      [76, 38, 38, 255],
      [38, 0, 0, 255],
      [38, 19, 19, 255],
      [255, 63, 0, 255],
      // 21
      [255, 159, 127, 255],
      [165, 41, 0, 255],
      [165, 103, 82, 255],
      [127, 31, 0, 255],
      [127, 79, 63, 255],
      [76, 19, 0, 255],
      [76, 47, 38, 255],
      [38, 9, 0, 255],
      [38, 28, 19, 255],
      [255, 127, 0, 255],
      // 31
      [255, 191, 127, 255],
      [165, 82, 0, 255],
      [165, 124, 82, 255],
      [127, 63, 0, 255],
      [127, 95, 63, 255],
      [76, 38, 0, 255],
      [76, 57, 38, 255],
      [38, 19, 0, 255],
      [38, 28, 19, 255],
      [255, 191, 0, 255],
      // 41
      [255, 223, 127, 255],
      [165, 124, 0, 255],
      [165, 145, 82, 255],
      [127, 95, 0, 255],
      [127, 111, 63, 255],
      [76, 57, 0, 255],
      [76, 66, 38, 255],
      [38, 28, 0, 255],
      [38, 33, 19, 255],
      [255, 255, 0, 255],
      // 51
      [255, 255, 127, 255],
      [165, 165, 0, 255],
      [165, 165, 82, 255],
      [127, 127, 0, 255],
      [127, 127, 63, 255],
      [76, 76, 0, 255],
      [76, 76, 38, 255],
      [38, 38, 0, 255],
      [38, 38, 19, 255],
      [191, 255, 0, 255],
      // 61
      [223, 255, 127, 255],
      [124, 165, 0, 255],
      [145, 165, 82, 255],
      [95, 127, 0, 255],
      [111, 127, 63, 255],
      [57, 76, 0, 255],
      [66, 76, 38, 255],
      [28, 38, 0, 255],
      [33, 38, 19, 255],
      [127, 255, 0, 255],
      // 71
      [191, 255, 127, 255],
      [82, 165, 0, 255],
      [124, 165, 82, 255],
      [63, 127, 0, 255],
      [95, 127, 63, 255],
      [38, 76, 0, 255],
      [57, 76, 38, 255],
      [19, 38, 0, 255],
      [28, 38, 19, 255],
      [63, 255, 0, 255],
      // 81
      [159, 255, 127, 255],
      [41, 165, 0, 255],
      [103, 165, 82, 255],
      [31, 127, 0, 255],
      [79, 127, 63, 255],
      [19, 76, 0, 255],
      [47, 76, 38, 255],
      [9, 38, 0, 255],
      [23, 38, 19, 255],
      [0, 255, 0, 255],
      // 91
      [125, 255, 127, 255],
      [0, 165, 0, 255],
      [82, 165, 82, 255],
      [0, 127, 0, 255],
      [63, 127, 63, 255],
      [0, 76, 0, 255],
      [38, 76, 38, 255],
      [0, 38, 0, 255],
      [19, 38, 19, 255],
      [0, 255, 63, 255],
      // 101
      [127, 255, 159, 255],
      [0, 165, 41, 255],
      [82, 165, 103, 255],
      [0, 127, 31, 255],
      [63, 127, 79, 255],
      [0, 76, 19, 255],
      [38, 76, 47, 255],
      [0, 38, 9, 255],
      [19, 88, 23, 255],
      [0, 255, 127, 255],
      // 111
      [127, 255, 191, 255],
      [0, 165, 82, 255],
      [82, 165, 124, 255],
      [0, 127, 63, 255],
      [63, 127, 95, 255],
      [0, 76, 38, 255],
      [38, 76, 57, 255],
      [0, 38, 19, 255],
      [19, 88, 28, 255],
      [0, 255, 191, 255],
      // 121
      [127, 255, 223, 255],
      [0, 165, 124, 255],
      [82, 165, 145, 255],
      [0, 127, 95, 255],
      [63, 127, 111, 255],
      [0, 76, 57, 255],
      [38, 76, 66, 255],
      [0, 38, 28, 255],
      [19, 88, 88, 255],
      [0, 255, 255, 255],
      // 131
      [127, 255, 255, 255],
      [0, 165, 165, 255],
      [82, 165, 165, 255],
      [0, 127, 127, 255],
      [63, 127, 127, 255],
      [0, 76, 76, 255],
      [38, 76, 76, 255],
      [0, 38, 38, 255],
      [19, 88, 88, 255],
      [0, 191, 255, 255],
      // 141
      [127, 223, 255, 255],
      [0, 124, 165, 255],
      [82, 145, 165, 255],
      [0, 95, 127, 255],
      [63, 111, 217, 255],
      [0, 57, 76, 255],
      [38, 66, 126, 255],
      [0, 28, 38, 255],
      [19, 88, 88, 255],
      [0, 127, 255, 255],
      // 151
      [127, 191, 255, 255],
      [0, 82, 165, 255],
      [82, 124, 165, 255],
      [0, 63, 127, 255],
      [63, 95, 127, 255],
      [0, 38, 76, 255],
      [38, 57, 126, 255],
      [0, 19, 38, 255],
      [19, 28, 88, 255],
      [0, 63, 255, 255],
      // 161
      [127, 159, 255, 255],
      [0, 41, 165, 255],
      [82, 103, 165, 255],
      [0, 31, 127, 255],
      [63, 79, 127, 255],
      [0, 19, 76, 255],
      [38, 47, 126, 255],
      [0, 9, 38, 255],
      [19, 23, 88, 255],
      [0, 0, 255, 255],
      // 171
      [127, 127, 255, 255],
      [0, 0, 165, 255],
      [82, 82, 165, 255],
      [0, 0, 127, 255],
      [63, 63, 127, 255],
      [0, 0, 76, 255],
      [38, 38, 126, 255],
      [0, 0, 38, 255],
      [19, 19, 88, 255],
      [63, 0, 255, 255],
      // 181
      [159, 127, 255, 255],
      [41, 0, 165, 255],
      [103, 82, 165, 255],
      [31, 0, 127, 255],
      [79, 63, 127, 255],
      [19, 0, 76, 255],
      [47, 38, 126, 255],
      [9, 0, 38, 255],
      [23, 19, 88, 255],
      [127, 0, 255, 255],
      // 191
      [191, 127, 255, 255],
      [165, 0, 82, 255],
      [124, 82, 165, 255],
      [63, 0, 127, 255],
      [95, 63, 127, 255],
      [38, 0, 76, 255],
      [57, 38, 126, 255],
      [19, 0, 38, 255],
      [28, 19, 88, 255],
      [191, 0, 255, 255],
      // 201
      [223, 127, 255, 255],
      [124, 0, 165, 255],
      [142, 82, 165, 255],
      [95, 0, 127, 255],
      [111, 63, 127, 255],
      [57, 0, 76, 255],
      [66, 38, 76, 255],
      [28, 0, 38, 255],
      [88, 19, 88, 255],
      [255, 0, 255, 255],
      // 211
      [255, 127, 255, 255],
      [165, 0, 165, 255],
      [165, 82, 165, 255],
      [127, 0, 127, 255],
      [127, 63, 127, 255],
      [76, 0, 76, 255],
      [76, 38, 76, 255],
      [38, 0, 38, 255],
      [88, 19, 88, 255],
      [255, 0, 191, 255],
      // 221
      [255, 127, 223, 255],
      [165, 0, 124, 255],
      [165, 82, 145, 255],
      [127, 0, 95, 255],
      [127, 63, 111, 255],
      [76, 0, 57, 255],
      [76, 38, 66, 255],
      [38, 0, 28, 255],
      [88, 19, 88, 255],
      [255, 0, 127, 255],
      // 231
      [255, 127, 191, 255],
      [165, 0, 82, 255],
      [165, 82, 124, 255],
      [127, 0, 63, 255],
      [127, 63, 95, 255],
      [76, 0, 38, 255],
      [76, 38, 57, 255],
      [38, 0, 19, 255],
      [88, 19, 28, 255],
      [255, 0, 63, 255],
      // 241
      [255, 127, 159, 255],
      [165, 0, 41, 255],
      [165, 82, 103, 255],
      [127, 0, 31, 255],
      [127, 63, 79, 255],
      [76, 0, 19, 255],
      [76, 38, 47, 255],
      [38, 0, 9, 255],
      [88, 19, 23, 255],
      [0, 0, 0, 255],
      // 251
      [101, 101, 101, 255],
      [102, 102, 102, 255],
      [153, 153, 153, 255],
      [204, 204, 204, 255],
      [255, 255, 255, 255]
    ];
    module.exports = colorIndex;
  }
});

// node_modules/@jscad/dxf-deserializer/DxfReader.js
var require_DxfReader = __commonJS({
  "node_modules/@jscad/dxf-deserializer/DxfReader.js"(exports) {
    (function(dxf) {
      dxf.reader = function(options) {
        return new DxfReader(options);
      };
      dxf.STATES = [
        "start",
        "end",
        "error"
      ];
      function DxfReader(options) {
        const reader = this;
        reader.options = options || {};
        reader.trackPosition = reader.options.track !== false;
        if (reader.trackPosition) {
          reader.line = reader.column = reader.c = 0;
        }
      }
      DxfReader.prototype = {
        // set a handler for the given state
        // see dxf.STATES above
        on: function(state, callback) {
          const reader = this;
          reader["on" + state] = callback;
        },
        // set a handler for the given group and value
        absorb: function(group, callback) {
          if (this.absorbers === void 0) {
            this.absorbers = /* @__PURE__ */ new Map();
          }
          this.absorbers.set(group, callback);
        },
        // write the given data into the reader, initiating parsing
        write: function(data) {
          const reader = this;
          parse(reader, data);
          return reader;
        },
        // close and clear all state
        close: function() {
          const reader = this;
          reader.isclosed = true;
          return reader;
        }
      };
      const emitstart = (reader) => emitstate(reader, "onstart", reader.data);
      const emitgroup = (reader, group, value) => {
        if (reader.absorbers !== void 0) {
          const absorber = reader.absorbers.get(group);
          if (absorber !== void 0) {
            absorber(reader, group, value);
          }
        }
      };
      const emiterror = (reader, er) => {
        if (reader.trackPosition) {
          er += `
Line: ${reader.line}
Column: ${reader.column}
Char: ${reader.c}`;
        }
        er = new Error(er);
        reader.error = er;
        return emitstate(reader, "onerror", er);
      };
      const emitend = (reader) => emitstate(reader, "onend", reader.data);
      const emitstate = (reader, state, data) => {
        const onhandler = state.toString();
        reader[onhandler] && reader[onhandler](reader, data);
        return reader;
      };
      const parse = (reader, data) => {
        if (reader.error) {
          throw reader.error;
        }
        if (reader.isclosed) {
          return emiterror(reader, "Cannot write after close");
        }
        emitstart(reader);
        if (data === null) {
          return emitend(reader);
        }
        reader.group = null;
        reader.value = null;
        reader.error = null;
        reader.position = 0;
        reader.line = 0;
        reader.column = 0;
        let i = 0;
        let c = "";
        let l = "";
        while (reader.error === null) {
          c = charAt(data, i++);
          if (!c) {
            break;
          }
          if (reader.trackPosition) {
            reader.position++;
            if (c === "\n") {
              reader.line++;
              reader.column = 0;
            } else {
              reader.column++;
            }
          }
          if (c === "\n") {
            parseLine(reader, l);
            l = "";
          } else {
            l += c;
          }
        }
        emitend(reader);
        return reader;
      };
      const parseLine = (reader, line) => {
        line = line.trim();
        if (reader.group === null) {
          setDxfGroup(reader, line);
          reader.value = null;
        } else {
          setDxfValue(reader, line);
        }
        if (reader.group !== null && reader.value !== null) {
          emitgroup(reader, reader.group, reader.value);
          reader.group = null;
          reader.value = null;
        }
      };
      const setDxfGroup = (reader, line) => {
        const code = parseInt(line);
        if (isNaN(code)) {
          emiterror(reader, "Invalid group (int)");
          reader.group = null;
        } else {
          reader.group = code;
        }
      };
      const setDxfValue = (reader, line) => {
        if (reader.options.strict) {
          reader.value = line;
        } else {
          reader.value = line;
        }
      };
      const charAt = (data, i) => {
        if (data && data.length > i) {
          return data.charAt(i);
        }
        return "";
      };
    })(typeof exports === "undefined" ? exports.dxf = {} : exports);
  }
});

// node_modules/@jscad/dxf-deserializer/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@jscad/dxf-deserializer/helpers.js"(exports, module) {
    var { BYBLOCK, BYLAYER } = require_autocad();
    var findLayer = (obj, layers) => {
      const lname = obj.lnam || "0";
      for (const layer of layers) {
        if (layer.name === lname) {
          return layer;
        }
      }
      return null;
    };
    var getColorNumber = (obj, layers) => {
      let cn = obj.cnmb || -1;
      if (cn === BYLAYER) {
        cn = -1;
        const layer = findLayer(obj, layers);
        if (layer !== null) {
          cn = layer.cnmb || -1;
        }
      } else if (cn === BYBLOCK) {
      }
      return cn;
    };
    var mod = (num, mod2) => {
      const remain = num % mod2;
      return Math.floor(remain >= 0 ? remain : remain + mod2);
    };
    var getColor = (index, colorindex) => {
      if (index < 1) {
        return null;
      }
      index = mod(index, colorindex.length);
      const color = colorindex[index];
      const rgba = [color[0] / 255, color[1] / 255, color[2] / 255, color[3] / 255];
      return rgba;
    };
    module.exports = {
      findLayer,
      getColor,
      getColorNumber
    };
  }
});

// node_modules/@jscad/dxf-deserializer/instantiate.js
var require_instantiate = __commonJS({
  "node_modules/@jscad/dxf-deserializer/instantiate.js"(exports, module) {
    var { geometries, maths, primitives } = require_src();
    var EPS = 1e-5;
    var { getColor, getColorNumber } = require_helpers2();
    var instantiatePolygon = (obj, layers, options) => {
      const vertices = [];
      vertices.push(maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz));
      vertices.push(maths.vec3.fromValues(obj.sptx, obj.spty, obj.sptz));
      vertices.push(maths.vec3.fromValues(obj.tptx, obj.tpty, obj.tptz));
      if (obj.fptx) {
        let pushit = false;
        if (obj.tptx !== obj.fptx) {
          pushit = true;
        }
        if (obj.tpty !== obj.fpty) {
          pushit = true;
        }
        if (obj.tptz !== obj.fptz) {
          pushit = true;
        }
        if (pushit) {
          vertices.push(maths.vec3.fromValues(obj.fptx, obj.fpty, obj.fptz));
        }
      }
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const polygon = geometries.poly3.create(vertices);
      if (color)
        polygon.color = color;
      return polygon;
    };
    var instantiateLine = (obj, layers, options) => {
      if (obj.pptz === obj.sptz && obj.pptz === 0) {
        const p12 = maths.vec2.fromValues(obj.pptx, obj.ppty);
        const p22 = maths.vec2.fromValues(obj.sptx, obj.spty);
        return primitives.line([p12, p22]);
      }
      const p1 = maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz);
      const p2 = maths.vec3.fromValues(obj.sptx, obj.spty, obj.sptz);
      return primitives.line([p1, p2]);
    };
    var instantiateVector = (obj) => {
      const d3line = parseInt("00000000000100000", 2);
      const d3mesh = parseInt("00000000001000000", 2);
      const d3face = parseInt("00000000010000000", 2);
      const flags = obj.lflg;
      const vtype = {};
      if ((flags & d3line) === d3line) {
        vtype.vec = maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz);
      } else if ((flags & d3mesh) === d3mesh) {
        vtype.vec = maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz);
      } else if ((flags & d3face) === d3face) {
        vtype.vec = maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz);
        vtype.fvia = obj.fvia;
        vtype.fvib = obj.fvib;
        vtype.fvic = obj.fvic;
        vtype.fvid = obj.fvid;
      } else {
        vtype.vec = maths.vec2.fromValues(obj.pptx, obj.ppty);
        vtype.bulg = obj.bulg;
      }
      return vtype;
    };
    var addSection = (path, x1, y1, bulg) => {
      if (bulg === 0) {
        path = geometries.path2.appendPoints([[x1, y1]], path);
      } else {
        const points = geometries.path2.toPoints(path);
        const prev = points[points.length - 1];
        const curr = maths.vec2.fromValues(x1, y1);
        const u = maths.vec2.distance(prev, curr);
        const r = u * ((1 + Math.pow(bulg, 2)) / (4 * bulg));
        const clockwise = bulg < 0;
        const large = false;
        const d = Math.atan(bulg) * 4;
        const res = 16;
        path = geometries.path2.appendArc({ endpoint: [x1, y1], radius: [r, r], xaxisrotation: d, clockwise, large, segments: res }, path);
      }
      return path;
    };
    var instantiatePath2D = (obj, layers, options) => {
      const closed = parseInt("00000000000000001", 2);
      const vlen = obj.vlen;
      const pptxs = obj.pptxs;
      const pptys = obj.pptys;
      const bulgs = obj.bulgs;
      const flags = obj.lflg;
      let path = geometries.path2.create();
      const isclosed = (flags & closed) === closed;
      if (vlen === pptxs.length && vlen === pptys.length && vlen === bulgs.length) {
        pptxs.forEach((item, index, array) => {
          let bulg = 0;
          if (index > 0) {
            bulg = bulgs[index - 1];
          }
          path = addSection(path, pptxs[index], pptys[index], bulg);
        });
      } else {
        return path;
      }
      if (isclosed && !path.isClosed) {
        path = addSection(path, pptxs[0], pptys[0], bulgs[vlen - 1]);
        path = geometries.path2.close(path);
      }
      return path;
    };
    var instantiateArc = (obj, layers, options) => {
      const lthk = obj.lthk;
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const swid = obj.swid;
      let ang0 = obj.ang0;
      ang0 = ang0 * 0.017453292519943295;
      let ang1 = obj.ang1;
      ang1 = ang1 * 0.017453292519943295;
      const res = 16;
      if (lthk === 0) {
        return primitives.arc({ center: [pptx, ppty], radius: swid, startAngle: ang0, endAngle: ang1, segments: res });
      }
      return primitives.arc({ center: [pptx, ppty], radius: swid, startAngle: ang0, endAngle: ang1, segments: res });
    };
    var instantiateCircle = (obj, layers, options) => {
      const lthk = obj.lthk;
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const swid = obj.swid;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const res = 16;
      if (lthk === 0) {
        const cag2 = primitives.circle({ center: [pptx, ppty], radius: swid, segments: res });
        if (color)
          cag2.color = color;
        return cag2;
      }
      const cag = primitives.circle({ center: [pptx, ppty], radius: swid, segments: res });
      const csg = cag.extrude({ offset: [0, 0, lthk] });
      if (color)
        csg.color = color;
      return csg;
    };
    var instantiateEllipse = (obj, layers, options) => {
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const pptz = obj.pptz;
      const sptx = obj.sptx;
      const spty = obj.spty;
      const sptz = obj.sptz;
      const swid = obj.swid;
      const res = 16;
      if (pptz === 0 && sptz === 0) {
        const center = maths.vec2.fromValues(0, 0);
        const mjaxis = maths.vec2.fromValues(sptx, spty);
        const rx = maths.vec2.distance(center, mjaxis);
        const ry = rx * swid;
        let angle = Math.atan2(spty, sptx) * 180 / Math.PI;
        if (angle < EPS)
          angle = 0;
        angle = angle * 0.017453292519943295;
        const cag = primitives.ellipse({ center: [0, 0], radius: [rx, ry], segments: res });
        const matrix = maths.mat4.fromZRotation(maths.mat4.create(), angle);
        maths.mat4.multiply(matrix, matrix, maths.mat4.fromTranslation(maths.mat4.create(), [pptx, ppty, 0]));
        return geometries.geom2.transform(matrix, cag);
      }
    };
    var instantiateFaces = (fvals) => {
      const faces = [];
      let vi = 0;
      while (vi < fvals.length) {
        let fi = fvals[vi++];
        const face = [];
        while (fi > 0) {
          face.push(fvals[vi++]);
          fi--;
        }
        faces.push(face);
      }
      return faces;
    };
    var instantiatePoints = (pptxs, pptys, pptzs) => {
      const points = [];
      let vi = 0;
      while (vi < pptxs.length) {
        const x = pptxs[vi];
        const y = pptys[vi];
        const z = pptzs[vi];
        points.push([x, y, z]);
        vi++;
      }
      return points;
    };
    var instantiateMesh = (obj, layers, options) => {
      const vlen = obj.vlen;
      const pptxs = obj.pptxs;
      const pptys = obj.pptys;
      const pptzs = obj.pptzs;
      const flen = obj.flen;
      const fvals = obj.fvals;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const polygons = [];
      if (vlen === pptxs.length && vlen === pptys.length && vlen === pptzs.length) {
        if (flen === fvals.length) {
          const faces = instantiateFaces(fvals);
          const points = instantiatePoints(pptxs, pptys, pptzs);
          let fi = 0;
          while (fi < faces.length) {
            const face = faces[fi];
            let vertices = [];
            let vi = 0;
            while (vi < face.length) {
              const pi = face[vi];
              const vertex = maths.vec3.clone(points[pi]);
              vertices.push(vertex);
              vi++;
            }
            if (options.dxf.angdir === 1) {
              vertices = vertices.reverse();
            }
            const poly = geometries.poly3.create(vertices);
            if (color)
              poly.color = color;
            polygons.push(poly);
            fi++;
          }
        } else {
        }
      } else {
      }
      return geometries.geom3.create(polygons);
    };
    var getPolyType = (obj) => {
      const closedM = parseInt("00000000000000001", 2);
      const d3line = parseInt("00000000000001000", 2);
      const d3mesh = parseInt("00000000000010000", 2);
      const closedN = parseInt("00000000000100000", 2);
      const d3face = parseInt("00000000001000000", 2);
      const flags = obj.lflg;
      let ptype = null;
      if ((flags & d3line) === d3line) {
        ptype = null;
      } else if ((flags & d3mesh) === d3mesh) {
        ptype = geometries.geom3.create();
        ptype.closedM = (flags & closedM) === closedM;
        ptype.closedN = (flags & closedN) === closedN;
      } else if ((flags & d3face) === d3face) {
        ptype = geometries.geom3.create();
        ptype.closedM = (flags & closedM) === closedM;
        ptype.closedN = (flags & closedN) === closedN;
      } else {
        ptype = geometries.path2.create();
        ptype.closedM = (flags & closedM) === closedM;
      }
      if ("cnmb" in obj) {
        ptype.cnmb = obj.cnmb;
      }
      return ptype;
    };
    var completeCurrent = (objects, baseobj, polygons, vectors, options) => {
      if (geometries.path2.isA(baseobj)) {
        const points = vectors.map((vector) => vector.vec);
        objects.push(geometries.path2.fromPoints({ closed: baseobj.closed }, points));
      }
      if (geometries.geom3.isA(baseobj)) {
        objects.push(geometries.geom3.create(polygons));
      }
      return null;
    };
    var instantiateAsciiDxf = (reader, options) => {
      const layers = [];
      let current = null;
      const polygons = [];
      const objects = [];
      const vectors = [];
      let p = null;
      for (const obj of reader.objstack) {
        p = null;
        if (!("type" in obj)) {
          continue;
        }
        switch (obj.type) {
          case "dxf":
            break;
          case "layer":
            current = completeCurrent(objects, current, polygons, vectors, options);
            layers.push(obj);
            break;
          case "variable":
            current = completeCurrent(objects, current, polygons, vectors, options);
            break;
          case "3dface":
            p = instantiatePolygon(obj, layers, options);
            if (current === null) {
              current = geometries.geom3.create();
            }
            break;
          case "mesh":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiateMesh(obj, layers, options));
            break;
          case "arc":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiateArc(obj, layers, options));
            break;
          case "circle":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiateCircle(obj, layers, options));
            break;
          case "ellipse":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiateEllipse(obj, layers, options));
            break;
          case "line":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiateLine(obj, layers, options));
            break;
          case "polyline":
            current = completeCurrent(objects, current, polygons, vectors, options);
            if (current === null) {
              current = getPolyType(obj);
            }
            break;
          case "vertex":
            p = instantiateVector(obj);
            break;
          case "seqend":
            current = completeCurrent(objects, current, polygons, vectors, options);
            break;
          case "lwpolyline":
            current = completeCurrent(objects, current, polygons, vectors, options);
            objects.push(instantiatePath2D(obj, layers, options));
            break;
          default:
            break;
        }
        if (geometries.poly3.isA(p)) {
          polygons.push(p);
        }
        if (p && "vec" in p && p.vec.length === 3) {
          vectors.push(p);
        }
        if (p && "vec" in p && p.vec.length === 2) {
          vectors.push(p);
        }
      }
      current = completeCurrent(objects, current, polygons, vectors, options);
      return objects;
    };
    module.exports = {
      instantiatePolygon,
      instantiateVector,
      instantiateAsciiDxf
    };
  }
});

// node_modules/@jscad/dxf-deserializer/translate.js
var require_translate2 = __commonJS({
  "node_modules/@jscad/dxf-deserializer/translate.js"(exports, module) {
    var { maths, geometries } = require_src();
    var { instantiatePolygon, instantiateVector } = require_instantiate();
    var { findLayer, getColor, getColorNumber } = require_helpers2();
    var translateVector2D = (vector) => {
      const script = `${vector[0]},${vector[1]}`;
      return script;
    };
    var translateVector3D = (vector) => {
      const script = `${vector[0]},${vector[1]},${vector[2]}`;
      return script;
    };
    var translatePolygon = (polygon) => {
      const vertices = geometries.poly3.toPoints(polygon);
      let script = "createPolygon([";
      vertices.forEach((vertice) => {
        script += `[${translateVector3D(vertice)}],`;
      });
      script += `],${translateColor(polygon)})`;
      return script;
    };
    var translateColor = (polygon) => {
      let script = "null";
      if ("color" in polygon) {
        const rgb = polygon.color;
        script = `[${rgb[0]},${rgb[1]},${rgb[2]},${rgb[3]}]`;
      }
      return script;
    };
    var translateLine = (obj, layers, options) => {
      const name = obj.name;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      let script = "";
      if (!obj.pptz || obj.pptz === obj.sptz && obj.pptz === 0) {
        const p1 = maths.vec2.fromValues(obj.pptx, obj.ppty);
        const p2 = maths.vec2.fromValues(obj.sptx, obj.spty);
        script = `  let ${name} = primitives.line([[${translateVector2D(p1)}],[${translateVector2D(p2)}]])
`;
      } else {
        const p1 = maths.vec3.fromValues(obj.pptx, obj.ppty, obj.pptz);
        const p2 = maths.vec3.fromValues(obj.sptx, obj.spty, obj.sptz);
        script = `  let ${name} = primitives.line([[${translateVector3D(p1)}],[${translateVector3D(p2)}]])
`;
      }
      if (color) {
        script += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
      }
      obj.script = script;
      addToLayer(obj, layers);
    };
    var translateSection = (name, x1, y1, bulg, px, py) => {
      if (bulg === 0) {
        return `geometries.path2.appendPoints([[${x1},${y1}]], ${name})
`;
      }
      const prev = maths.vec2.fromValues(px, py);
      const curr = maths.vec2.fromValues(x1, y1);
      const u = maths.vec2.distance(prev, curr);
      const r = u * ((1 + Math.pow(bulg, 2)) / (4 * bulg));
      const clockwise = bulg < 0;
      const large = false;
      const d = Math.atan(bulg) * 4;
      const res = 16;
      return `geometries.path2.appendArc({endpoint: [${x1},${y1}],radius: [${r},${r}],xaxisrotation: ${d},clockwise: ${clockwise},large: ${large},segments: ${res}}, ${name})
`;
    };
    var translatePath2D = (obj, layers, options) => {
      const closed = parseInt("00000000000000001", 2);
      const vlen = obj.vlen;
      const pptxs = obj.pptxs;
      const pptys = obj.pptys;
      const bulgs = obj.bulgs;
      const flags = obj.lflg;
      const name = obj.name;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      let script = `  let ${name} = geometries.path2.create()
`;
      const isclosed = (flags & closed) === closed;
      if (vlen === pptxs.length && vlen === pptys.length && vlen === bulgs.length) {
        script += `  ${name} = geometries.path2.appendPoints([[${pptxs[0]}, ${pptys[0]}]], ${name})
`;
        for (let i = 0; i < pptxs.length; i++) {
          const j = (i + 1) % pptxs.length;
          const cx = pptxs[j];
          const cy = pptys[j];
          const px = pptxs[i];
          const py = pptys[i];
          const bulg = bulgs[i];
          if (j !== 0) {
            script += `  ${name} = ${translateSection(name, cx, cy, bulg, px, py)}`;
          } else {
            if (bulg !== 0) {
              script += `  ${name} = ${translateSection(name, cx, cy, bulg, px, py)}`;
            }
          }
        }
      } else {
        return;
      }
      if (isclosed) {
        script += `  ${name} = geometries.path2.close(${name})
`;
      } else {
        script += "\n";
      }
      if (color) {
        script += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
      }
      obj.script = script;
      addToLayer(obj, layers);
    };
    var translateArc = (obj, layers, options) => {
      const lthk = obj.lthk;
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const swid = obj.swid;
      let ang0 = obj.ang0;
      let ang1 = obj.ang1;
      const name = obj.name;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      ang0 *= 0.017453292519943295;
      ang1 *= 0.017453292519943295;
      const res = 16;
      if (lthk === 0) {
        let script2 = `  let ${name} = primitives.arc({center: [${pptx}, ${ppty}], radius: ${swid}, startAngle: ${ang0}, endAngle: ${ang1}, segements: ${res}})
`;
        if (color) {
          script2 += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
        }
        obj.script = script2;
        addToLayer(obj, layers);
        return;
      }
      let script = `  let ${name} = primitives.arc({center: [${pptx}, ${ppty}], radius: ${swid}, startAngle: ${ang0}, endAngle: ${ang1}, segements: ${res}})
`;
      if (color) {
        script += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
      }
      obj.script = script;
      addToLayer(obj, layers);
    };
    var translateCircle = (obj, layers, options) => {
      const lthk = obj.lthk;
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const swid = obj.swid;
      const name = obj.name;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const res = 16;
      if (lthk === 0) {
        let script2 = `  let ${name} = primitives.circle({center: [${pptx}, ${ppty}], radius: ${swid}, segments: ${res}})
`;
        if (color) {
          script2 += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
        }
        obj.script = script2;
        addToLayer(obj, layers);
        return;
      }
      let script = `  let ${name} = primitives.circle({center: [${pptx}, ${ppty}], radius: ${swid}, segments: ${res}}).extrude({offset: [0,0,${lthk}]}))
`;
      if (color) {
        script += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
      }
      obj.script = script;
      addToLayer(obj, layers);
    };
    var translateEllipse = (obj, layers, options) => {
      const pptx = obj.pptx;
      const ppty = obj.ppty;
      const pptz = obj.pptz;
      const sptx = obj.sptx;
      const spty = obj.spty;
      const sptz = obj.sptz;
      const swid = obj.swid;
      const name = obj.name;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const res = 16;
      if (pptz === 0 && sptz === 0) {
        const center = maths.vec2.fromValues(0, 0);
        const mjaxis = maths.vec2.fromValues(sptx, spty);
        const rx = maths.vec2.distance(center, mjaxis);
        const ry = rx * swid;
        const angle = Math.atan2(spty, sptx);
        let script = `  let ${name} = primitives.ellipse({center: [0, 0, 0], radius: [${rx}, ${ry}], segments: ${res}})
  let ${name}matrix = maths.mat4.multiply(maths.mat4.create(), maths.mat4.fromTranslation(maths.mat4.create(), [${pptx}, ${ppty}, 0]), maths.mat4.fromZRotation(maths.mat4.create(), ${angle}))
  ${name} = geometries.geom2.transform(${name}matrix, ${name})
`;
        if (color) {
          script += `  ${name} = colors.colorize([${color[0]}, ${color[1]}, ${color[2]}, 1], ${name})
`;
        }
        obj.script = script;
        addToLayer(obj, layers);
      }
    };
    var instantiateFaces = (fvals) => {
      const faces = [];
      let vi = 0;
      while (vi < fvals.length) {
        let fi = fvals[vi++];
        const face = [];
        while (fi > 0) {
          face.push(fvals[vi++]);
          fi--;
        }
        faces.push(face);
      }
      return faces;
    };
    var instantiatePoints = (pptxs, pptys, pptzs) => {
      const points = [];
      let vi = 0;
      while (vi < pptxs.length) {
        const x = pptxs[vi];
        const y = pptys[vi];
        const z = pptzs[vi];
        points.push([x, y, z]);
        vi++;
      }
      return points;
    };
    var translateMesh = (obj, layers, options) => {
      const vlen = obj.vlen;
      const pptxs = obj.pptxs;
      const pptys = obj.pptys;
      const pptzs = obj.pptzs;
      const flen = obj.flen;
      const fvals = obj.fvals;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      const polygons = [];
      if (vlen === pptxs.length && vlen === pptys.length && vlen === pptzs.length) {
        if (flen === fvals.length) {
          const faces = instantiateFaces(fvals);
          const points = instantiatePoints(pptxs, pptys, pptzs);
          let fi = 0;
          while (fi < faces.length) {
            const face = faces[fi];
            let vertices = [];
            let vi = 0;
            while (vi < face.length) {
              const pi = face[vi];
              const vector = maths.vec3.clone(points[pi]);
              vertices.push(vector);
              vi++;
            }
            if (options.dxf.angdir === 1) {
              vertices = vertices.reverse();
            }
            const poly = geometries.poly3.create(vertices);
            if (color)
              poly.color = color;
            polygons.push(poly);
            fi++;
          }
        } else {
          console.warn("invalid mesh: faces");
        }
      } else {
        console.warn("invalid mesh: vertices");
      }
      const name = obj.name;
      let script = `  const ${name}_polygons = [
`;
      for (const polygon of polygons) {
        script += "    " + translatePolygon(polygon) + ",\n";
      }
      script += `  ]
  let ${name} = geometries.geom3.create(${name}_polygons)
`;
      obj.script = script;
      addToLayer(obj, layers);
      return null;
    };
    var findLayer0 = (layers) => {
      for (const layer2 of layers) {
        if (layer2.name === "0") {
          return layer2;
        }
      }
      const layer = { type: "layer" };
      layer.lnam = "layer0";
      layer.name = "0";
      layer.lscl = 1;
      layer.visb = 0;
      layer.spac = 0;
      layer.objects = [];
      layers.push(layer);
      return layer;
    };
    var addToLayer = (obj, layers) => {
      let layer = findLayer(obj, layers);
      if (layer === null) {
        layer = findLayer0(layers);
      }
      if (!("objects" in layer)) {
        layer.objects = [];
      }
      layer.objects.push(obj);
    };
    var getPolyType = (obj) => {
      const closedM = parseInt("00000000000000001", 2);
      const d3line = parseInt("00000000000001000", 2);
      const d3mesh = parseInt("00000000000010000", 2);
      const closedN = parseInt("00000000000100000", 2);
      const d3face = parseInt("00000000001000000", 2);
      const flags = obj.lflg;
      let ptype = null;
      if ((flags & d3line) === d3line) {
        const isclosed = (flags & closedM) === closedM;
        ptype = { type: "3dline", isclosed };
      } else if ((flags & d3mesh) === d3mesh) {
        ptype = { type: "3dpolymesh" };
        ptype.fvia = obj.fvia;
        ptype.fvib = obj.fvib;
        ptype.closedM = (flags & closedM) === closedM;
        ptype.closedN = (flags & closedN) === closedN;
      } else if ((flags & d3face) === d3face) {
        ptype = { type: "3dpolyfaces" };
        ptype.fvia = obj.fvia;
        ptype.fvib = obj.fvib;
      } else {
        const isclosed = (flags & closedM) === closedM;
        ptype = { type: "2dline", isclosed };
      }
      if ("cnmb" in obj) {
        ptype.cnmb = obj.cnmb;
      }
      if ("lnam" in obj) {
        ptype.lnam = obj.lnam;
      }
      return ptype;
    };
    var instantiateFacets = (meshM, meshN, parts, color, options) => {
      const getVector = (x, y) => {
        const n = (x - 1) * meshN + (y - 1);
        const part = parts[n];
        return part.vec;
      };
      const facets = [];
      const fcount = meshM * meshN;
      if (fcount !== parts.length) {
        return facets;
      }
      if (meshM < 2 | meshN < 2) {
        return facets;
      }
      let i = 1;
      while (i < meshM) {
        let j = 1;
        while (j < meshN) {
          const v0 = getVector(i, j);
          const v1 = getVector(i + 1, j);
          const v2 = getVector(i + 1, j + 1);
          const v3 = getVector(i, j + 1);
          let facet = [v0, v1, v2, v3];
          if (options.dxf.angdir === 1) {
            facet = facet.reverse();
          }
          const polygon = geometries.poly3.create(facet);
          const plane = geometries.poly3.plane(polygon);
          if (Number.isFinite(plane[3])) {
            if (color)
              polygon.color = color;
            facets.push(polygon);
          }
          j++;
        }
        i++;
      }
      return facets;
    };
    var instantiatePolyFaces = (meshM, meshN, parts, color, options) => {
      const faces = [];
      if (meshM + meshN !== parts.length) {
        return faces;
      }
      let i = meshM;
      while (i < parts.length) {
        let part = parts[i];
        const indexes = [Math.abs(part.fvia), Math.abs(part.fvib), Math.abs(part.fvic), Math.abs(part.fvid)];
        let vertices = [];
        if (indexes[0] > 0) {
          part = parts[indexes[0] - 1];
          vertices.push(part.vec);
          if (indexes[1] > 0) {
            part = parts[indexes[1] - 1];
            vertices.push(part.vec);
            if (indexes[2] > 0) {
              part = parts[indexes[2] - 1];
              vertices.push(part.vec);
              if (indexes[3] > 0) {
                part = parts[indexes[3] - 1];
                vertices.push(part.vec);
              }
            }
          }
        }
        if (vertices.length > 2) {
          if (options.dxf.angdir === 1) {
            vertices = vertices.reverse();
          }
          const polygon = geometries.poly3.create(vertices);
          faces.push(polygon);
        }
        i++;
      }
      return faces;
    };
    var translateAs2Dline = (obj, layers, parts, options) => {
      obj.vlen = parts.length;
      obj.pptxs = [];
      obj.pptys = [];
      obj.bulgs = [];
      for (const part of parts) {
        obj.pptxs.push(part.vec[0]);
        obj.pptys.push(part.vec[1]);
        obj.bulgs.push(part.bulg);
      }
      if (obj.isclosed) {
        obj.lflg = parseInt("00000000000000001", 2);
      } else {
        obj.lflg = 0;
      }
      translatePath2D(obj, layers, options);
      return null;
    };
    var translateCurrent = (obj, layers, parts, options) => {
      if (obj === null)
        return null;
      const type = obj.type;
      const cn = getColorNumber(obj, layers);
      const color = getColor(cn, options.colorindex);
      if (type === "2dline") {
        return translateAs2Dline(obj, layers, parts, options);
      }
      if (type === "3dline") {
        return null;
      }
      if (type === "3dpolymesh") {
        const m = obj.fvia;
        const n = obj.fvib;
        const facets = instantiateFacets(m, n, parts, color, options);
        parts = facets;
      }
      if (type === "3dpolyfaces") {
        if ("fvia" in obj) {
          const m = obj.fvia;
          const n = obj.fvib;
          const faces = instantiatePolyFaces(m, n, parts, color, options);
          parts = faces;
        }
      }
      const name = obj.name;
      let script = `  const ${name}_polygons = [
`;
      for (const polygon of parts) {
        script += "    " + translatePolygon(polygon) + ",\n";
      }
      script += `  ]
  let ${name} = geometries.geom3.create(${name}_polygons)
`;
      if (color) {
        script += `  ${name}.color = [${color}]
`;
      }
      obj.script = script;
      addToLayer(obj, layers);
      return null;
    };
    var translateLayer = (layer) => {
      const name = layer.lnam || "Unknown";
      let script = `function ${name}() {
`;
      for (const object of layer.objects) {
        script += object.script;
      }
      script += "  return [";
      for (const object of layer.objects) {
        script += object.name + ",";
      }
      script += "]\n}\n";
      return script;
    };
    var saveVariable = (obj, options) => {
      const name = obj.name || "Unknown";
      switch (name) {
        case "$ANGDIR":
          if ("lflg" in obj) {
            options.dxf.angdir = obj.lflg;
          }
          break;
        default:
          break;
      }
    };
    var translateAsciiDxf = (reader, options) => {
      const layers = [];
      let current = null;
      let parts = [];
      let numobjs = 0;
      let p = null;
      for (const obj of reader.objstack) {
        p = null;
        if (!("type" in obj)) {
          continue;
        }
        if (!("name" in obj)) {
          obj.name = "jscad" + numobjs;
          numobjs = numobjs + 1;
        } else {
          let name = obj.name;
          name = name.replace(/ /g, "_");
          name = name.replace(/-/g, "_");
          name = name.replace(/\./g, "_");
          obj.name = name;
        }
        switch (obj.type) {
          case "dxf":
            break;
          case "layer":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            obj.objects = [];
            obj.lnam = "layer" + layers.length;
            layers.push(obj);
            break;
          case "variable":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            saveVariable(obj, options);
            break;
          case "3dface":
            p = instantiatePolygon(obj, layers, options);
            if (current === null) {
              current = { type: "3dfaces" };
              current.name = "jscad" + numobjs;
              numobjs = numobjs + 1;
            }
            break;
          case "mesh":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translateMesh(obj, layers, options);
            break;
          case "arc":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translateArc(obj, layers, options);
            break;
          case "circle":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translateCircle(obj, layers, options);
            break;
          case "ellipse":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translateEllipse(obj, layers, options);
            break;
          case "line":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translateLine(obj, layers, options);
            break;
          case "polyline":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            if (current === null) {
              current = getPolyType(obj);
              current.name = "jscad" + numobjs;
              numobjs = numobjs + 1;
            }
            break;
          case "vertex":
            p = instantiateVector(obj);
            break;
          case "seqend":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            break;
          case "lwpolyline":
            current = translateCurrent(current, layers, parts, options);
            parts = [];
            translatePath2D(obj, layers, options);
            break;
          default:
            break;
        }
        if (geometries.poly3.isA(p)) {
          parts.push(p);
        }
        if (p && "vec" in p && p.vec.length === 3) {
          parts.push(p);
        }
        if (p && "vec" in p && p.vec.length === 2) {
          parts.push(p);
        }
      }
      current = translateCurrent(current, layers, parts, options);
      let script = `const {colors, geometries, maths, primitives, transforms} = require('@jscad/modeling')

const main = () => {
  let layers = []
  return layers.concat(`;
      layers.forEach((layer) => {
        const name = layer.lnam || "Unknown";
        script += `${name}(),`;
      });
      script += "[])\n}\n";
      script += `
function createPolygon(listofpoints, color) {
  let polygon = geometries.poly3.fromPoints(listofpoints)
  if (color) polygon.color = color
  return polygon
}
`;
      layers.forEach((layer) => {
        script += translateLayer(layer);
      });
      script += "module.exports = {main}\n";
      return script;
    };
    module.exports = translateAsciiDxf;
  }
});

// node_modules/@jscad/dxf-deserializer/index.js
var require_dxf_deserializer = __commonJS({
  "node_modules/@jscad/dxf-deserializer/index.js"(exports, module) {
    var version = require_package3().version;
    var { BYLAYER, getTLA } = require_autocad();
    var colorIndex = require_colorindex20172();
    var dxf = require_DxfReader();
    var { instantiateAsciiDxf } = require_instantiate();
    var translateAsciiDxf = require_translate2();
    var handleError = (reader, error) => {
      if (reader.options.strict === true) {
        throw error;
      } else {
        console.log(`error: line ${error.line}, column ${error.column}, bad character [${error.c}]`);
      }
    };
    var handleStart = (reader, data) => {
    };
    var handleEnd = (reader, data) => {
    };
    var handleEntity = (reader, group, value) => {
      let obj = null;
      switch (value) {
        case "LAYER":
          obj = { type: "layer" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(67)] = 0;
          reader.objstack.push(obj);
          break;
        case "LINE":
          obj = { type: "line" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 0;
          reader.objstack.push(obj);
          break;
        case "LWPOLYLINE":
          obj = { type: "lwpolyline" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(38)] = 0;
          obj[getTLA(39)] = 0;
          obj[getTLA(43)] = 0;
          obj[getTLA(70)] = 0;
          obj[getTLA(90)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 1;
          reader.objstack.push(obj);
          break;
        case "MESH":
          obj = { type: "mesh" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(91)] = 0;
          obj[getTLA(92)] = 0;
          obj[getTLA(93)] = 0;
          obj[getTLA(94)] = 0;
          obj[getTLA(95)] = 0;
          obj.state = 0;
          reader.objstack.push(obj);
          break;
        case "POLYLINE":
          obj = { type: "polyline" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(10)] = 0;
          obj[getTLA(20)] = 0;
          obj[getTLA(30)] = 0;
          obj[getTLA(39)] = 0;
          obj[getTLA(40)] = 0;
          obj[getTLA(41)] = 0;
          obj[getTLA(70)] = 0;
          obj[getTLA(71)] = 0;
          obj[getTLA(72)] = 0;
          obj[getTLA(73)] = 0;
          obj[getTLA(74)] = 0;
          obj[getTLA(75)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 1;
          reader.objstack.push(obj);
          break;
        case "ARC":
          obj = { type: "arc" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(39)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 1;
          reader.objstack.push(obj);
          break;
        case "CIRCLE":
          obj = { type: "circle" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(39)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 1;
          reader.objstack.push(obj);
          break;
        case "ELLIPSE":
          obj = { type: "ellipse" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(210)] = 0;
          obj[getTLA(220)] = 0;
          obj[getTLA(230)] = 1;
          reader.objstack.push(obj);
          break;
        case "VERTEX":
          obj = { type: "vertex" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(10)] = 0;
          obj[getTLA(20)] = 0;
          obj[getTLA(30)] = 0;
          obj[getTLA(40)] = 0;
          obj[getTLA(41)] = 0;
          obj[getTLA(42)] = 0;
          obj[getTLA(70)] = 0;
          obj[getTLA(71)] = 0;
          obj[getTLA(72)] = 0;
          obj[getTLA(73)] = 0;
          obj[getTLA(74)] = 0;
          reader.objstack.push(obj);
          break;
        case "3DFACE":
          obj = { type: "3dface" };
          obj[getTLA(48)] = 1;
          obj[getTLA(60)] = 0;
          obj[getTLA(62)] = BYLAYER;
          obj[getTLA(67)] = 0;
          obj[getTLA(70)] = 0;
          reader.objstack.push(obj);
          break;
        case "SEQEND":
          obj = { type: "seqend" };
          reader.objstack.push(obj);
          break;
        default:
          obj = {};
          reader.objstack.push(obj);
          break;
      }
    };
    var handleVariable = (reader, group, value) => {
      const obj = { type: "variable", name: value };
      reader.objstack.push(obj);
    };
    var handleInt = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        obj[getTLA(group)] = parseFloat(value);
      }
      reader.objstack.push(obj);
    };
    var handleDouble = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        obj[getTLA(group)] = parseFloat(value);
      }
      reader.objstack.push(obj);
    };
    var handleXcoord = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "lwpolyline") {
          if (obj.pptxs === void 0) {
            obj.pptxs = [];
            obj.bulgs = [];
          }
          obj.pptxs.push(parseFloat(value));
          obj.bulgs.push(0);
        } else {
          if (obj.type === "mesh") {
            if (obj.pptxs === void 0) {
              obj.pptxs = [];
            }
            obj.pptxs.push(parseFloat(value));
          } else {
            obj[getTLA(group)] = parseFloat(value);
          }
        }
      }
      reader.objstack.push(obj);
    };
    var handleYcoord = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "lwpolyline" || obj.type === "mesh") {
          if (obj.pptys === void 0) {
            obj.pptys = [];
          }
          obj.pptys.push(parseFloat(value));
        } else {
          obj[getTLA(group)] = parseFloat(value);
        }
      }
      reader.objstack.push(obj);
    };
    var handleZcoord = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "mesh") {
          if (obj.pptzs === void 0) {
            obj.pptzs = [];
          }
          obj.pptzs.push(parseFloat(value));
        } else {
          obj[getTLA(group)] = parseFloat(value);
        }
      }
      reader.objstack.push(obj);
    };
    var handleBulge = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "lwpolyline") {
          const bulgs = obj.bulgs;
          if (bulgs !== void 0) {
            const pptxs = obj.pptxs;
            if (pptxs.length === bulgs.length) {
              bulgs[bulgs.length - 1] = parseFloat(value);
            }
          }
        } else {
          obj[getTLA(group)] = parseFloat(value);
        }
      }
      reader.objstack.push(obj);
    };
    var handleLen = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "mesh") {
          const state = obj.state;
          switch (group) {
            case 91:
              obj[getTLA(group)] = parseFloat(value);
              obj.state = 1;
              break;
            case 92:
              if (state === 1) {
                obj.vlen = parseFloat(value);
                obj.state = 2;
              } else {
                obj.plen = parseFloat(value);
                obj.state = 6;
              }
              break;
            case 93:
              obj[getTLA(group)] = parseFloat(value);
              obj.state = 3;
              break;
            case 94:
              obj[getTLA(group)] = parseFloat(value);
              obj.state = 4;
              break;
            case 95:
              obj[getTLA(group)] = parseFloat(value);
              obj.state = 5;
              break;
            default:
              obj.state = 7;
              break;
          }
        } else {
          obj[getTLA(group)] = parseFloat(value);
        }
      }
      reader.objstack.push(obj);
    };
    var handleValue = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj.type === "mesh") {
          const state = obj.state;
          switch (state) {
            case 3:
              if (obj.fvals === void 0) {
                obj.fvals = [];
              }
              obj.fvals.push(parseFloat(value));
              break;
            case 4:
              if (obj.evals === void 0) {
                obj.evals = [];
              }
              obj.evals.push(parseFloat(value));
              break;
            default:
              break;
          }
        } else {
          obj[getTLA(group)] = parseFloat(value);
        }
      }
      reader.objstack.push(obj);
    };
    var handleString = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        obj[getTLA(group)] = value;
      }
      reader.objstack.push(obj);
    };
    var handleName = (reader, group, value) => {
      const obj = reader.objstack.pop();
      if ("type" in obj) {
        if (obj[getTLA(group)] === void 0) {
          obj[getTLA(group)] = value;
        }
      }
      reader.objstack.push(obj);
    };
    var createReader = (src, options) => {
      const reader = dxf.reader(options);
      reader.on("error", handleError);
      reader.on("start", handleStart);
      reader.on("end", handleEnd);
      reader.absorb(0, handleEntity);
      reader.absorb(1, handleString);
      reader.absorb(2, handleName);
      reader.absorb(3, handleName);
      reader.absorb(6, handleString);
      reader.absorb(7, handleString);
      reader.absorb(8, handleString);
      reader.absorb(9, handleVariable);
      reader.absorb(10, handleXcoord);
      reader.absorb(11, handleDouble);
      reader.absorb(12, handleDouble);
      reader.absorb(13, handleDouble);
      reader.absorb(20, handleYcoord);
      reader.absorb(21, handleDouble);
      reader.absorb(22, handleDouble);
      reader.absorb(23, handleDouble);
      reader.absorb(30, handleZcoord);
      reader.absorb(31, handleDouble);
      reader.absorb(32, handleDouble);
      reader.absorb(33, handleDouble);
      reader.absorb(39, handleDouble);
      reader.absorb(40, handleDouble);
      reader.absorb(41, handleDouble);
      reader.absorb(42, handleBulge);
      reader.absorb(50, handleDouble);
      reader.absorb(51, handleDouble);
      reader.absorb(62, handleInt);
      reader.absorb(70, handleInt);
      reader.absorb(71, handleInt);
      reader.absorb(72, handleInt);
      reader.absorb(73, handleInt);
      reader.absorb(74, handleInt);
      reader.absorb(75, handleInt);
      reader.absorb(90, handleValue);
      reader.absorb(91, handleLen);
      reader.absorb(92, handleLen);
      reader.absorb(93, handleLen);
      reader.absorb(94, handleLen);
      reader.absorb(95, handleLen);
      reader.absorb(210, handleInt);
      reader.absorb(220, handleInt);
      reader.absorb(230, handleInt);
      reader.objstack = [];
      reader.objstack.push({ type: "dxf" });
      reader.write(src).close();
      return reader;
    };
    var instantiate = (src, options) => {
      const reader = createReader(src, options);
      const objs = instantiateAsciiDxf(reader, options);
      return objs;
    };
    var translate = (src, options) => {
      const reader = createReader(src, options);
      let code = `// Produced by JSCAD IO Library : DXF Deserializer (${options.version})

`;
      code += translateAsciiDxf(reader, options);
      return code;
    };
    var deserialize = (options, src) => {
      const defaults = {
        filename: "dxf",
        version,
        output: "script",
        strict: true,
        colorindex: colorIndex,
        dxf: {
          angdir: 0,
          // counter clockwise
          insunits: 4,
          // millimeters
          pfacevmax: 4
          // number of vertices per face
        }
      };
      options = Object.assign({}, defaults, options);
      return options.output === "script" ? translate(src, options) : instantiate(src, options);
    };
    var extension = "dxf";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/json-deserializer/package.json
var require_package4 = __commonJS({
  "node_modules/@jscad/json-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/json-deserializer",
      version: "2.0.26",
      description: "JSON Deserializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava 'tests/*.test.js' --verbose --timeout 2m"
      },
      contributors: [
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "json"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/array-utils": "2.1.4"
      },
      devDependencies: {
        "@jscad/modeling": "2.12.0",
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/json-deserializer/index.js
var require_json_deserializer = __commonJS({
  "node_modules/@jscad/json-deserializer/index.js"(exports, module) {
    var { flatten, toArray } = require_src2();
    var version = require_package4().version;
    var deserialize = (options, input) => {
      const defaults = {
        filename: "json",
        output: "script",
        version,
        addMetaData: true
      };
      options = Object.assign({}, defaults, options);
      let objects = JSON.parse(input);
      objects = flatten(toArray(objects));
      return options.output === "script" ? translate(options, objects) : objects;
    };
    var translate = (options, objects) => {
      const { addMetaData, filename, version: version2 } = options;
      let script = addMetaData ? `//
// Produced by JSCAD IO Library : JSON Deserializer (${version2})
// date: ${/* @__PURE__ */ new Date()}
// source: ${filename}
//
` : "";
      script += `
const { geometries } = require('@jscad/modeling')

const main = () => {
  const objects = [${translateToList(objects)} ]
  return objects
}

${translateToObjects(objects)}

module.exports = { main }
`;
      return script;
    };
    var translateToList = (objects) => objects.reduce((script, object, index) => script + ` json${index},`, "");
    var translateToObjects = (objects) => objects.reduce((script, object, index) => script + translateToObject(object, index), "");
    var translateToObject = (object, index) => `const json${index} = ${JSON.stringify(object)}
`;
    var extension = "json";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/obj-deserializer/package.json
var require_package5 = __commonJS({
  "node_modules/@jscad/obj-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/obj-deserializer",
      version: "2.0.25",
      description: "OBJ Deserializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m './tests/*.test.js'"
      },
      contributors: [
        {
          name: "Rene K. Mueller",
          url: "http://renekmueller.com"
        },
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "obj"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/modeling": "2.12.0"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/obj-deserializer/index.js
var require_obj_deserializer = __commonJS({
  "node_modules/@jscad/obj-deserializer/index.js"(exports, module) {
    var { colors, primitives } = require_src();
    var version = require_package5().version;
    var deserialize = (options, input) => {
      const defaults = {
        filename: "obj",
        output: "script",
        orientation: "outward",
        version,
        addMetaData: true
      };
      options = Object.assign({}, defaults, options);
      const { output } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      const { positions, groups } = getGroups(input, options);
      const result = output === "script" ? stringify(positions, groups, options) : objectify(positions, groups, options);
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return result;
    };
    var getGroups = (data, options) => {
      let groups = [];
      const positions = [];
      let material = null;
      groups.push({ faces: [], colors: [], name: "default", line: 0 });
      const handleG = (command, values) => {
        const group = { faces: [], colors: [], name: "" };
        if (values && values.length > 0)
          group.name = values.join(" ");
        groups.push(group);
      };
      const handleV = (command, values) => {
        const x = parseFloat(values[0]);
        const y = parseFloat(values[1]);
        const z = parseFloat(values[2]);
        positions.push([x, y, z]);
      };
      const handleF = (command, values) => {
        const facerefs = values.map((value) => {
          const refs = value.match(/[0-9+\-eE]+/g);
          let ref = parseInt(refs[0]);
          if (ref < 0) {
            ref = positions.length + ref;
          } else {
            ref--;
          }
          return ref;
        });
        const group = groups.pop();
        group.faces.push(facerefs);
        group.colors.push(material);
        groups.push(group);
      };
      const handleMtl = (command, values) => {
        material = null;
        if (values && values.length > 0) {
          const c = colors.colorNameToRgb(values[0]);
          if (c)
            material = [c[0], c[1], c[2], 1];
        }
      };
      const lines = data.split(/\n/);
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line && line.length > 0) {
          let values = line.match(/\S+/g);
          if (values) {
            const command = values[0];
            values = values.slice(1);
            switch (command) {
              case "g":
                handleG(command, values);
                break;
              case "v":
                handleV(command, values);
                break;
              case "f":
                handleF(command, values);
                break;
              case "usemtl":
                handleMtl(command, values);
                break;
            }
          }
        }
      }
      groups = groups.filter((group) => group.faces.length > 0);
      return { positions, groups };
    };
    var objectify = (points, groups, options) => {
      const geometries = groups.map((group) => primitives.polyhedron({ orientation: options.orientation, points, faces: group.faces, colors: group.colors }));
      return geometries;
    };
    var translatePoints = (points) => {
      let code = "  let points = [\n";
      points.forEach((point) => code += `    [${point}],
`);
      code += "  ]";
      return code;
    };
    var translateFaces = (faces) => {
      let code = "  let faces = [\n";
      faces.forEach((face) => code += `    [${face}],
`);
      code += "  ]";
      return code;
    };
    var translateColors = (colors2) => {
      let code = "  let colors = [\n";
      colors2.forEach((c) => {
        if (c) {
          code += `    [${c}],
`;
        } else {
          code += "    null,\n";
        }
      });
      code += "  ]";
      return code;
    };
    var translateGroupsToCalls = (groups) => {
      let code = "";
      groups.forEach((group, index) => code += `    group${index}(points), // ${group.name}
`);
      return code;
    };
    var translateGroupsToFunctions = (groups, options) => {
      let code = "";
      groups.forEach((group, index) => {
        const faces = group.faces;
        const colors2 = group.colors;
        code += `
// group : ${group.name}
// faces: ${faces.length}
`;
        code += `const group${index} = (points) => {
${translateFaces(faces)}
${translateColors(colors2)}
  return primitives.polyhedron({ orientation: '${options.orientation}', points, faces, colors })
}
`;
      });
      return code;
    };
    var stringify = (positions, groups, options) => {
      const { filename, addMetaData, version: version2 } = options;
      let code = addMetaData ? `//
// Produced by JSCAD IO Library : OBJ Deserializer (${version2})
// date: ${/* @__PURE__ */ new Date()}
// source: ${filename}
//
  ` : "";
      code += `const {primitives} = require('@jscad/modeling')

// groups: ${groups.length}
// points: ${positions.length}
const main = () => {
  // points are common to all geometries
${translatePoints(positions)}

  let geometries = [
${translateGroupsToCalls(groups)}  ]
  return geometries
}

${translateGroupsToFunctions(groups, options)}
module.exports = {main}
`;
      return code;
    };
    var extension = "obj";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/stl-deserializer/package.json
var require_package6 = __commonJS({
  "node_modules/@jscad/stl-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/stl-deserializer",
      version: "2.1.22",
      description: "STL Deserializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m './tests/*.test.js'"
      },
      contributors: [
        {
          name: "Rene K. Mueller",
          url: "http://renekmueller.com"
        },
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "stl"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/io-utils": "2.0.25",
        "@jscad/modeling": "2.12.0"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/stl-deserializer/index.js
var require_stl_deserializer = __commonJS({
  "node_modules/@jscad/stl-deserializer/index.js"(exports, module) {
    var { maths, primitives } = require_src();
    var { BinaryReader } = require_io_utils();
    var packageVersion = require_package6().version;
    var deserialize = (options, stl) => {
      const defaults = {
        filename: "stl",
        version: packageVersion,
        addMetaData: true,
        output: "script"
      };
      options = Object.assign({}, defaults, options);
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      const { filename, version, output, addMetaData } = options;
      stl = isBuffer(stl) ? bufferToBinaryString(stl) : stl;
      const isBinary = isDataBinaryRobust(stl);
      options && options.statusCallback && options.statusCallback({ progress: 33 });
      const elementFormatterJscad = ({ vertices, triangles, normals, colors, index }) => toScript(vertices, triangles, null, colors, index);
      const elementFormatterObject = ({ vertices, triangles, normals, colors }) => toPolyhedron(vertices, triangles, null, colors);
      options && options.statusCallback && options.statusCallback({ progress: 66 });
      const deserializer = isBinary ? deserializeBinarySTL : deserializeAsciiSTL;
      const elementFormatter = output === "script" ? elementFormatterJscad : elementFormatterObject;
      const outputFormatter = output === "script" ? formatAsJscad : formatAsCsg;
      const result = outputFormatter(deserializer(stl, filename, version, elementFormatter), addMetaData, version, filename);
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return result;
    };
    var bufferToBinaryString = (buffer) => {
      let binary = "";
      const bytes = new Uint8Array(buffer);
      const length = bytes.byteLength;
      for (let i = 0; i < length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return binary;
    };
    var isBuffer = (obj) => obj.byteLength !== void 0 && typeof obj.slice === "function";
    var ensureString = (buf) => {
      if (typeof buf !== "string") {
        const arrayBuffer = new Uint8Array(buf);
        let str = "";
        for (let i = 0; i < buf.byteLength; i++) {
          str += String.fromCharCode(arrayBuffer[i]);
        }
        return str;
      }
      return buf;
    };
    var isDataBinaryRobust = (data) => {
      const patternVertex = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
      const text = ensureString(data);
      const isBinary = patternVertex.exec(text);
      return isBinary === null;
    };
    var formatAsJscad = (data, addMetaData, version, filename) => {
      let code = "";
      if (addMetaData) {
        code = `
  //
  // producer: JSCAD STL Deserializer ${version}
  // date: ${/* @__PURE__ */ new Date()}
  // source: ${filename}
  // objects: ${data.length}
  //
  `;
      }
      code += "const {primitives} = require('@jscad/modeling')\n";
      code += data.join("\n");
      code += `
const main = () => {
 return [${data.map((d, i) => `solid${i + 1}()`)}]
}

module.exports = {main}
`;
      return code;
    };
    var formatAsCsg = (data) => data;
    var deserializeBinarySTL = (stl, filename, version, elementFormatter) => {
      const vertices = [];
      const triangles = [];
      const normals = [];
      const colors = [];
      let vertexIndex = 0;
      let err = 0;
      let mcolor = null;
      const umask = parseInt("01000000000000000", 2);
      const rmask = parseInt("00000000000011111", 2);
      const gmask = parseInt("00000001111100000", 2);
      const bmask = parseInt("00111110000000000", 2);
      const br = new BinaryReader(stl);
      let m = 0;
      let c = 0;
      let r = 0;
      let g = 0;
      let b = 0;
      let a = 0;
      for (let i = 0; i < 80; i++) {
        switch (m) {
          case 6:
            r = br.readUInt8();
            m += 1;
            continue;
          case 7:
            g = br.readUInt8();
            m += 1;
            continue;
          case 8:
            b = br.readUInt8();
            m += 1;
            continue;
          case 9:
            a = br.readUInt8();
            m += 1;
            continue;
          default:
            c = br.readChar();
            switch (c) {
              case "C":
              case "O":
              case "L":
              case "R":
              case "=":
                m += 1;
                break;
              default:
                break;
            }
            break;
        }
      }
      if (m === 10) {
        mcolor = [r / 255, g / 255, b / 255, a / 255];
      }
      const totalTriangles = br.readUInt32();
      for (let tr = 0; tr < totalTriangles; tr++) {
        const no = [];
        no.push(br.readFloat());
        no.push(br.readFloat());
        no.push(br.readFloat());
        let v1 = [];
        v1.push(br.readFloat());
        v1.push(br.readFloat());
        v1.push(br.readFloat());
        const v2 = [];
        v2.push(br.readFloat());
        v2.push(br.readFloat());
        v2.push(br.readFloat());
        let v3 = [];
        v3.push(br.readFloat());
        v3.push(br.readFloat());
        v3.push(br.readFloat());
        let skip = 0;
        for (let i = 0; i < 3; i++) {
          if (isNaN(v1[i]))
            skip++;
          if (isNaN(v2[i]))
            skip++;
          if (isNaN(v3[i]))
            skip++;
          if (isNaN(no[i]))
            skip++;
        }
        if (skip > 0) {
          console.log("bad triangle vertice coords/normal: ", skip);
        }
        err += skip;
        const triangle = [];
        triangle.push(vertexIndex++);
        triangle.push(vertexIndex++);
        triangle.push(vertexIndex++);
        const abc = br.readUInt16();
        let color = null;
        if (m === 10) {
          const u = abc & umask;
          const r2 = (abc & rmask) / 31;
          const g2 = ((abc & gmask) >>> 5) / 31;
          const b2 = ((abc & bmask) >>> 10) / 31;
          const a2 = 255;
          if (u === 0) {
            color = [r2, g2, b2, a2];
          } else {
            color = mcolor;
          }
          colors.push(color);
        }
        if (skip === 0) {
          const e1 = maths.vec3.subtract(maths.vec3.create(), v2, v1);
          const e2 = maths.vec3.subtract(maths.vec3.create(), v3, v1);
          const cr = maths.vec3.cross(maths.vec3.create(), e1, e2);
          const t = maths.vec3.dot(no, cr);
          if (t > 0) {
            const tmp = v3;
            v3 = v1;
            v1 = tmp;
          }
        }
        vertices.push(v1);
        vertices.push(v2);
        vertices.push(v3);
        triangles.push(triangle);
        normals.push(no);
      }
      if (err) {
        console.warn(`WARNING: import errors: ${err} (some triangles might be misaligned or missing)`);
      }
      return [elementFormatter({ vertices, triangles, normals, colors, index: 1 })];
    };
    var deserializeAsciiSTL = (stl, filename, version, elementFormatter) => {
      let converted = 0;
      const objects = stl.split("endsolid");
      const elements = [];
      for (let o = 1; o < objects.length; o++) {
        const patt = /\bfacet[\s\S]*?endloop/mgi;
        const vertices = [];
        const triangles = [];
        const normals = [];
        const colors = [];
        let vertexIndex = 0;
        let err = 0;
        const match = stl.match(patt);
        if (match == null)
          continue;
        for (let i = 0; i < match.length; i++) {
          const vpatt = /\bfacet\s+normal\s+(\S+)\s+(\S+)\s+(\S+)\s+outer\s+loop\s+vertex\s+(\S+)\s+(\S+)\s+(\S+)\s+vertex\s+(\S+)\s+(\S+)\s+(\S+)\s+vertex\s+(\S+)\s+(\S+)\s+(\S+)\s*/mgi;
          const v = vpatt.exec(match[i]);
          if (v == null)
            continue;
          if (v.length !== 13) {
            console.log("Failed to parse " + match[i]);
            break;
          }
          let skip = 0;
          for (let k = 0; k < v.length; k++) {
            if (v[k] === "NaN") {
              console.log("bad normal or triangle vertice #" + converted + " " + k + ": '" + v[k] + "', skipped");
              skip++;
            }
          }
          err += skip;
          if (skip) {
            continue;
          }
          let j = 1;
          const no = [];
          no.push(parseFloat(v[j++]));
          no.push(parseFloat(v[j++]));
          no.push(parseFloat(v[j++]));
          let v1 = [];
          v1.push(parseFloat(v[j++]));
          v1.push(parseFloat(v[j++]));
          v1.push(parseFloat(v[j++]));
          const v2 = [];
          v2.push(parseFloat(v[j++]));
          v2.push(parseFloat(v[j++]));
          v2.push(parseFloat(v[j++]));
          let v3 = [];
          v3.push(parseFloat(v[j++]));
          v3.push(parseFloat(v[j++]));
          v3.push(parseFloat(v[j++]));
          const triangle = [];
          triangle.push(vertexIndex++);
          triangle.push(vertexIndex++);
          triangle.push(vertexIndex++);
          if (skip === 0) {
            const e1 = maths.vec3.subtract(maths.vec3.create(), v2, v1);
            const e2 = maths.vec3.subtract(maths.vec3.create(), v3, v1);
            const cr = maths.vec3.cross(maths.vec3.create(), e1, e2);
            const t = maths.vec3.dot(no, cr);
            if (t > 0) {
              const tmp = v3;
              v3 = v1;
              v1 = tmp;
            }
          }
          vertices.push(v1);
          vertices.push(v2);
          vertices.push(v3);
          normals.push(no);
          triangles.push(triangle);
          converted++;
        }
        if (err) {
          console.warn(`WARNING: import errors: ${err} (some triangles might be misaligned or missing)`);
        }
        elements.push(
          elementFormatter({ vertices, triangles, colors, index: o })
        );
      }
      return elements;
    };
    var toPolyhedron = (points, faces, normals, colors) => {
      if (colors && faces.length !== colors.length)
        colors = void 0;
      const options = {
        orientation: "inward",
        points,
        faces,
        colors
      };
      return primitives.polyhedron(options);
    };
    var toScript = (points, faces, normals, colors, index) => {
      let src = `
//
// solid ${index} : ${points.length} points, ${faces.length} faces, ${colors.length} colors
//
const solid${index} = () => {
`;
      src += "  const points = [\n";
      for (let i = 0; i < points.length; i++) {
        src += `    [${points[i]}],
`;
      }
      src += "  ]\n";
      src += "  const faces = [\n";
      for (let i = 0; i < faces.length; i++) {
        src += `    [${faces[i]}],
`;
      }
      src += "  ]\n";
      if (colors && faces.length === colors.length) {
        src += "  const colors = [\n";
        for (let i = 0; i < colors.length; i++) {
          src += `    [${colors[i]}],
`;
        }
        src += "  ]\n";
      } else {
        src += "  const colors = null\n";
      }
      src += "  return primitives.polyhedron({points, faces, colors, orientation: 'inside'})\n}\n";
      return src;
    };
    var extension = "stl";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/svg-deserializer/package.json
var require_package7 = __commonJS({
  "node_modules/@jscad/svg-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/svg-deserializer",
      version: "2.5.6",
      description: "SVG Deserializer for JSCAD",
      homepage: "https://openjscad.xyz/",
      repository: "https://github.com/jscad/OpenJSCAD.org",
      main: "src/index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m './tests/*.test.js'"
      },
      contributors: [
        {
          name: "Rene K. Mueller",
          url: "http://renekmueller.com"
        },
        {
          name: "z3dev",
          url: "http://www.z3d.jp"
        },
        {
          name: "Mark 'kaosat-dev' Moissette",
          url: "http://kaosat.net"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "svg"
      ],
      license: "MIT",
      dependencies: {
        "@jscad/array-utils": "2.1.4",
        "@jscad/modeling": "2.12.0",
        saxes: "5.0.1"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/constants.js
var require_constants2 = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/constants.js"(exports, module) {
    var pxPmm = 1 / 0.2822222;
    var inchMM = 1 / (1 / 0.03937);
    var ptMM = 1 / (1 / 0.03937 / 72);
    var pcMM = 1 / (1 / 0.03937 / 72 * 12);
    var cssPxUnit = 0.2822222;
    var svgColors = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      grey: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    module.exports = {
      pxPmm,
      inchMM,
      ptMM,
      pcMM,
      cssPxUnit,
      svgColors
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/helpers.js"(exports, module) {
    var { inchMM, ptMM, pcMM, svgColors } = require_constants2();
    var svg2cag = (vec, svgUnitsPmm) => [
      vec[0] / svgUnitsPmm[0],
      0 - vec[1] / svgUnitsPmm[1]
    ];
    var cagLengthX = (css, svgUnitsPmm, svgUnitsX) => {
      if (css.indexOf("%") < 0) {
        return css2cag(css, svgUnitsPmm[0]);
      }
      let v = parseFloat(css);
      if (isNaN(v)) {
        return 0;
      }
      if (v === 0)
        return v;
      v = v / 100 * svgUnitsX;
      v = v / svgUnitsPmm[0];
      return Math.round(v * 1e5) / 1e5;
    };
    var cagLengthY = (css, svgUnitsPmm, svgUnitsY) => {
      if (css.indexOf("%") < 0) {
        return css2cag(css, svgUnitsPmm[1]);
      }
      let v = parseFloat(css);
      if (isNaN(v)) {
        return 0;
      }
      if (v === 0)
        return v;
      v = v / 100 * svgUnitsY;
      v = v / svgUnitsPmm[1];
      return Math.round(v * 1e5) / 1e5;
    };
    var cagLengthP = (css, svgUnitsPmm, svgUnitsV) => {
      if (css.indexOf("%") < 0) {
        return css2cag(css, svgUnitsPmm[1]);
      }
      let v = parseFloat(css);
      if (isNaN(v)) {
        return 0;
      }
      if (v === 0)
        return v;
      v = v / 100 * svgUnitsV;
      v = v / svgUnitsPmm[0];
      return v;
    };
    var css2cag = (css, unit) => {
      let v = parseFloat(css);
      if (isNaN(v)) {
        return 0;
      }
      if (v === 0)
        return v;
      if (css.search(/EM/i) > 0) {
      } else if (css.search(/EX/i) > 0) {
      } else if (css.search(/MM/i) > 0) {
      } else if (css.search(/CM/i) > 0) {
        v = v * 10;
      } else if (css.search(/IN/i) > 0) {
        v = v / inchMM;
      } else if (css.search(/PT/i) > 0) {
        v = v / ptMM;
      } else if (css.search(/PC/i) > 0) {
        v = v / pcMM;
      } else {
        v = v / unit;
      }
      return v;
    };
    var cagColor = (value) => {
      let rgb;
      value = value.toLowerCase();
      if (value in svgColors) {
        rgb = svgColors[value];
        rgb = [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];
      } else {
        if (value[0] === "#") {
          if (value.length === 4) {
            value = "#" + value[1] + value[1] + value[2] + value[2] + value[3] + value[3];
          }
          if (value.length === 7) {
            rgb = [
              parseInt("0x" + value.slice(1, 3)) / 255,
              parseInt("0x" + value.slice(3, 5)) / 255,
              parseInt("0x" + value.slice(5, 7)) / 255
            ];
          }
        } else {
          const pat = /rgb\(.+,.+,.+\)/;
          let s = pat.exec(value);
          if (s !== null) {
            s = s[0];
            s = s.slice(s.indexOf("(") + 1, s.indexOf(")"));
            rgb = s.split(",");
            if (s.indexOf("%") > 0) {
              rgb = [parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2])];
              rgb = [rgb[0] / 100, rgb[1] / 100, rgb[2] / 100];
            } else {
              rgb = [parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2])];
              rgb = [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];
            }
          }
        }
      }
      return rgb;
    };
    var cssStyle = (element, name) => {
      if ("style" in element) {
        const list = element.style + ";";
        const pat = name + "\\s*:\\s*(\\S+);";
        const exp = new RegExp(pat, "i");
        let v = exp.exec(list);
        if (v !== null) {
          v = v[0];
          let i = v.indexOf(":") + 1;
          while (v[i] === " ")
            i++;
          v = v.slice(i, v.indexOf(";"));
          return v;
        }
      }
      return void 0;
    };
    var reflect = (x, y, px, py) => {
      const ox = x - px;
      const oy = y - py;
      if (x === px && y === px)
        return [x, y];
      if (x === px)
        return [x, py + -oy];
      if (y === py)
        return [px + -ox, y];
      return [px + -ox, py + -oy];
    };
    var groupValue = (svgGroups, name) => {
      let i = svgGroups.length;
      while (i > 0) {
        const g = svgGroups[i - 1];
        if (name in g) {
          return g[name];
        }
        i--;
      }
      return void 0;
    };
    var svgColorForTarget = (target, svgObject) => {
      let color = null;
      if (target === "path") {
        if (svgObject.stroke) {
          color = [svgObject.stroke[0], svgObject.stroke[1], svgObject.stroke[2], 1];
        } else {
          if (svgObject.fill) {
            color = [svgObject.fill[0], svgObject.fill[1], svgObject.fill[2], 1];
          }
        }
      } else {
        if (svgObject.fill) {
          color = [svgObject.fill[0], svgObject.fill[1], svgObject.fill[2], 1];
        } else {
          if (svgObject.stroke) {
            color = [svgObject.stroke[0], svgObject.stroke[1], svgObject.stroke[2], 1];
          }
        }
      }
      return color;
    };
    module.exports = {
      svg2cag,
      cagLengthX,
      cagLengthY,
      cagLengthP,
      css2cag,
      cagColor,
      cssStyle,
      reflect,
      groupValue,
      svgColorForTarget
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/svgElementHelpers.js
var require_svgElementHelpers = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/svgElementHelpers.js"(exports, module) {
    var { cagColor, cssStyle, css2cag } = require_helpers3();
    var { pxPmm } = require_constants2();
    var svgCore = (obj, element) => {
      if ("id" in element) {
        obj.id = element.id;
      }
      if ("position" in element) {
        obj.position = element.position;
      }
    };
    var svgPresentation = (obj, element) => {
      if ("display" in element) {
        obj.visible = element.display;
      }
      if ("color" in element) {
        obj.fill = cagColor(element.color);
        obj.stroke = obj.fill;
      }
      if ("opacity" in element) {
        obj.opacity = element.opacity;
      }
      if ("fill" in element) {
        obj.fill = cagColor(element.fill);
      } else {
        const s = cssStyle(element, "fill");
        if (s) {
          obj.fill = cagColor(s);
        }
      }
      if ("fill-opacity" in element) {
        obj.opacity = element["fill-opacity"];
      }
      if ("stroke-width" in element) {
        obj.strokeWidth = element["stroke-width"];
      } else {
        const sw = cssStyle(element, "stroke-width");
        if (sw) {
          obj.strokeWidth = sw;
        }
      }
      if ("stroke" in element) {
        obj.stroke = cagColor(element.stroke);
      } else {
        const s = cssStyle(element, "stroke");
        if (s) {
          obj.stroke = cagColor(s);
        }
      }
      if ("stroke-opacity" in element) {
        obj.strokeOpacity = element["stroke-opacity"];
      }
    };
    var svgTransformsRegExp = /\w+\(.+\)/i;
    var svgTransforms = (cag, element) => {
      let list = null;
      if ("transform" in element) {
        list = element.transform;
      } else {
        const s = cssStyle(element, "transform");
        if (s) {
          list = s;
        }
      }
      if (list !== null) {
        cag.transforms = [];
        let v = svgTransformsRegExp.exec(list);
        while (v !== null) {
          const s = svgTransformsRegExp.lastIndex;
          const e = list.indexOf(")") + 1;
          let t = list.slice(s, e);
          t = t.trim();
          const n = t.slice(0, t.indexOf("("));
          let a = t.slice(t.indexOf("(") + 1, t.indexOf(")")).trim();
          if (a.indexOf(",") > 0) {
            a = a.split(",");
          } else {
            a = a.split(" ");
          }
          let o;
          switch (n) {
            case "translate":
              if (a.length === 1)
                a.push(0);
              o = { translate: [a[0], a[1]] };
              cag.transforms.push(o);
              break;
            case "scale":
              if (a.length === 1)
                a.push(a[0]);
              o = { scale: [a[0], a[1]] };
              cag.transforms.push(o);
              break;
            case "rotate":
              o = { rotate: a };
              cag.transforms.push(o);
              break;
            default:
              break;
          }
          list = list.slice(e, list.length);
          v = svgTransformsRegExp.exec(list);
        }
      }
    };
    var viewBoxRegExp = /([\d.-]+)[\s,]+([\d.-]+)[\s,]+([\d.-]+)[\s,]+([\d.-]+)/i;
    var svgSvg = (element, { customPxPmm }) => {
      const obj = { type: "svg", x: 0, y: 0, width: "100%", height: "100%", strokeWidth: "1" };
      obj.unitsPmm = [pxPmm, pxPmm];
      if ("pxpmm" in element) {
        obj.pxPmm = element.pxpmm;
        obj.unitsPmm = [obj.pxPmm, obj.pxPmm];
      }
      if ("width" in element) {
        obj.width = element.width;
      }
      if ("height" in element) {
        obj.height = element.height;
      }
      if ("viewBox" in element) {
        const list = element.viewBox.trim();
        const v = viewBoxRegExp.exec(list);
        if (v !== null) {
          obj.viewX = parseFloat(v[1]);
          obj.viewY = parseFloat(v[2]);
          obj.viewW = parseFloat(v[3]);
          obj.viewH = parseFloat(v[4]);
        }
        if (obj.width.indexOf("%") < 0) {
          let s = css2cag(obj.width, customPxPmm);
          s = obj.viewW / s;
          obj.unitsPmm[0] = s;
        } else {
          const u = obj.unitsPmm[0] * (parseFloat(obj.width) / 100);
          obj.unitsPmm[0] = u;
        }
        if (obj.height.indexOf("%") < 0) {
          let s = css2cag(obj.height, pxPmm);
          s = obj.viewH / s;
          obj.unitsPmm[1] = s;
        } else {
          const u = obj.unitsPmm[1] * (parseFloat(obj.height) / 100);
          obj.unitsPmm[1] = u;
        }
      } else {
        obj.viewX = 0;
        obj.viewY = 0;
        obj.viewW = 1920 / obj.unitsPmm[0];
        obj.viewH = 1080 / obj.unitsPmm[1];
      }
      obj.viewP = Math.sqrt(obj.viewW * obj.viewW + obj.viewH * obj.viewH) / Math.SQRT2;
      svgCore(obj, element);
      svgPresentation(obj, element);
      obj.objects = [];
      return obj;
    };
    var svgEllipse = (element) => {
      const obj = { type: "ellipse", cx: "0", cy: "0", rx: "0", ry: "0" };
      if ("cx" in element) {
        obj.cx = element.cx;
      }
      if ("cy" in element) {
        obj.cy = element.cy;
      }
      if ("rx" in element) {
        obj.rx = element.rx;
      }
      if ("ry" in element) {
        obj.ry = element.ry;
      }
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      return obj;
    };
    var svgLine = (element) => {
      const obj = { type: "line", x1: "0", y1: "0", x2: "0", y2: "0" };
      if ("x1" in element) {
        obj.x1 = element.x1;
      }
      if ("y1" in element) {
        obj.y1 = element.y1;
      }
      if ("x2" in element) {
        obj.x2 = element.x2;
      }
      if ("y2" in element) {
        obj.y2 = element.y2;
      }
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      return obj;
    };
    var svgListOfPoints = (list) => {
      const points = [];
      const exp = /([\d\-+.]+)[\s,]+([\d\-+.]+)[\s,]*/i;
      list = list.trim();
      let v = exp.exec(list);
      while (v !== null) {
        let point = v[0];
        const next = exp.lastIndex + point.length;
        point = { x: v[1], y: v[2] };
        points.push(point);
        list = list.slice(next, list.length);
        v = exp.exec(list);
      }
      return points;
    };
    var svgPolyline = (element) => {
      const obj = { type: "polyline" };
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      if ("points" in element) {
        obj.points = svgListOfPoints(element.points);
      }
      return obj;
    };
    var svgPolygon = (element) => {
      const obj = { type: "polygon" };
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      if ("points" in element) {
        obj.points = svgListOfPoints(element.points);
      }
      return obj;
    };
    var svgRect = (element) => {
      const obj = { type: "rect", x: "0", y: "0", rx: "0", ry: "0", width: "0", height: "0" };
      if ("x" in element) {
        obj.x = element.x;
      }
      if ("y" in element) {
        obj.y = element.y;
      }
      if ("rx" in element) {
        obj.rx = element.rx;
        if (!("ry" in element)) {
          obj.ry = obj.rx;
        }
      }
      if ("ry" in element) {
        obj.ry = element.ry;
        if (!("rx" in element)) {
          obj.rx = obj.ry;
        }
      }
      if (obj.rx !== obj.ry) {
        console.log("Warning: Unsupported RECT with rx and ry radius");
      }
      if ("width" in element) {
        obj.width = element.width;
      }
      if ("height" in element) {
        obj.height = element.height;
      }
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      return obj;
    };
    var svgCircle = (element) => {
      const obj = { type: "circle", x: "0", y: "0", radius: "0" };
      if ("cx" in element) {
        obj.x = element.cx;
      }
      if ("cy" in element) {
        obj.y = element.cy;
      }
      if ("r" in element) {
        obj.radius = element.r;
      }
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      return obj;
    };
    var svgGroup = (element) => {
      const obj = { type: "group" };
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      if ("x" in element || "y" in element) {
        let x = "0";
        let y = "0";
        if ("x" in element)
          x = element.x;
        if ("y" in element)
          y = element.y;
        if (!("transforms" in obj))
          obj.transforms = [];
        const o = { translate: [x, y] };
        obj.transforms.push(o);
      }
      obj.objects = [];
      return obj;
    };
    var svgPath = (element) => {
      const obj = { type: "path" };
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      obj.commands = [];
      if ("d" in element) {
        let co = null;
        let bf = "";
        let i = 0;
        const l = element.d.length;
        const offset = element.position[1] - l - 2;
        while (i < l) {
          const c = element.d[i];
          switch (c) {
            case "-":
              if (bf.length > 0) {
                co.p.push(bf);
                bf = "";
              }
              bf += c;
              break;
            case ".":
              if (bf.length > 0) {
                if (bf.indexOf(".") >= 0) {
                  co.p.push(bf);
                  bf = "";
                }
              }
              bf += c;
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              bf += c;
              break;
            case "a":
            case "A":
            case "c":
            case "C":
            case "h":
            case "H":
            case "l":
            case "L":
            case "v":
            case "V":
            case "m":
            case "M":
            case "q":
            case "Q":
            case "s":
            case "S":
            case "t":
            case "T":
            case "z":
            case "Z":
              if (co !== null) {
                if (bf.length > 0) {
                  co.p.push(bf);
                  bf = "";
                }
                obj.commands.push(co);
              }
              co = { c, p: [], pos: i + offset };
              break;
            case ",":
            case " ":
            case "\n":
              if (co !== null) {
                if (bf.length > 0) {
                  co.p.push(bf);
                  bf = "";
                }
              }
              break;
            default:
              break;
          }
          i++;
        }
        if (i === l && co !== null) {
          if (bf.length > 0) {
            co.p.push(bf);
          }
          obj.commands.push(co);
        }
      }
      return obj;
    };
    var svgUse = (element, { svgObjects }) => {
      const obj = { type: "group" };
      svgTransforms(obj, element);
      svgCore(obj, element);
      svgPresentation(obj, element);
      if ("x" in element || "y" in element) {
        let x = "0";
        let y = "0";
        if ("x" in element)
          x = element.x;
        if ("y" in element)
          y = element.y;
        if (!("transforms" in obj))
          obj.transforms = [];
        const o = { translate: [x, y] };
        obj.transforms.push(o);
      }
      obj.objects = [];
      if ("xlink:href" in element) {
        let ref = element["xlink:href"];
        if (ref[0] === "#") {
          ref = ref.slice(1, ref.length);
        }
        if (svgObjects[ref] !== void 0) {
          ref = svgObjects[ref];
          ref = JSON.parse(JSON.stringify(ref));
          obj.objects.push(ref);
        }
      }
      return obj;
    };
    module.exports = {
      svgCore,
      svgPresentation,
      svgSvg,
      svgRect,
      svgCircle,
      svgEllipse,
      svgLine,
      svgPolyline,
      svgPolygon,
      svgGroup,
      svgPath,
      svgUse
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/shapesMapGeometry.js
var require_shapesMapGeometry = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/shapesMapGeometry.js"(exports, module) {
    var { geometries, primitives } = require_src();
    var { svg2cag, cagLengthX, cagLengthY, cagLengthP, reflect } = require_helpers3();
    var shapesMapGeometry = (obj, objectify, params) => {
      const { svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, svgGroups, target, segments, pathSelfClosed } = params;
      const types = {
        group: (obj2) => objectify({ target, segments }, obj2),
        rect: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, svgGroups2, segments2) => {
          let x = cagLengthX(obj2.x, svgUnitsPmm2, svgUnitsX2);
          let y = 0 - cagLengthY(obj2.y, svgUnitsPmm2, svgUnitsY2);
          const w = cagLengthX(obj2.width, svgUnitsPmm2, svgUnitsX2);
          const h = cagLengthY(obj2.height, svgUnitsPmm2, svgUnitsY2);
          const rx = cagLengthX(obj2.rx, svgUnitsPmm2, svgUnitsX2);
          let shape;
          if (w > 0 && h > 0) {
            x = x + w / 2;
            y = y - h / 2;
            if (rx === 0) {
              shape = primitives.rectangle({ center: [x, y], size: [w, h] });
            } else {
              shape = primitives.roundedRectangle({ center: [x, y], segments: segments2, size: [w, h], roundRadius: rx });
            }
            if (target === "path") {
              shape = geometries.path2.fromPoints({ closed: true }, geometries.geom2.toPoints(shape));
            }
          }
          return shape;
        },
        circle: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, svgGroups2, segments2) => {
          const x = cagLengthX(obj2.x, svgUnitsPmm2, svgUnitsX2);
          const y = 0 - cagLengthY(obj2.y, svgUnitsPmm2, svgUnitsY2);
          const r = cagLengthP(obj2.radius, svgUnitsPmm2, svgUnitsV2);
          let shape;
          if (r > 0) {
            shape = primitives.circle({ center: [x, y], segments: segments2, radius: r });
            if (target === "path") {
              shape = geometries.path2.fromPoints({ closed: true }, geometries.geom2.toPoints(shape));
            }
          }
          return shape;
        },
        ellipse: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, svgGroups2, segments2) => {
          const rx = cagLengthX(obj2.rx, svgUnitsPmm2, svgUnitsX2);
          const ry = cagLengthY(obj2.ry, svgUnitsPmm2, svgUnitsY2);
          const cx = cagLengthX(obj2.cx, svgUnitsPmm2, svgUnitsX2);
          const cy = 0 - cagLengthY(obj2.cy, svgUnitsPmm2, svgUnitsY2);
          let shape;
          if (rx > 0 && ry > 0) {
            shape = primitives.ellipse({ center: [cx, cy], segments: segments2, radius: [rx, ry] });
            if (target === "path") {
              shape = geometries.path2.fromPoints({ closed: true }, geometries.geom2.toPoints(shape));
            }
          }
          return shape;
        },
        line: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2) => {
          const x1 = cagLengthX(obj2.x1, svgUnitsPmm2, svgUnitsX2);
          const y1 = 0 - cagLengthY(obj2.y1, svgUnitsPmm2, svgUnitsY2);
          const x2 = cagLengthX(obj2.x2, svgUnitsPmm2, svgUnitsX2);
          const y2 = 0 - cagLengthY(obj2.y2, svgUnitsPmm2, svgUnitsY2);
          const shape = primitives.line([[x1, y1], [x2, y2]]);
          if (target === "geom2") {
          }
          return shape;
        },
        polygon: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2) => {
          const points = [];
          for (let j = 0; j < obj2.points.length; j++) {
            const p = obj2.points[j];
            if ("x" in p && "y" in p) {
              const x = cagLengthX(p.x, svgUnitsPmm2, svgUnitsX2);
              const y = 0 - cagLengthY(p.y, svgUnitsPmm2, svgUnitsY2);
              points.push([x, y]);
            }
          }
          if (target === "geom2") {
            return geometries.geom2.fromPoints(points);
          }
          return geometries.path2.fromPoints({}, points);
        },
        polyline: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2) => {
          const points = [];
          for (let j = 0; j < obj2.points.length; j++) {
            const p = obj2.points[j];
            if ("x" in p && "y" in p) {
              const x = cagLengthX(p.x, svgUnitsPmm2, svgUnitsX2);
              const y = 0 - cagLengthY(p.y, svgUnitsPmm2, svgUnitsY2);
              points.push([x, y]);
            }
          }
          const shape = primitives.line(points);
          if (target === "geom2") {
          }
          return shape;
        },
        path: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, svgGroups2, segments2) => {
          const listofpaths = expandPath(obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, svgGroups2, segments2, pathSelfClosed);
          const listofentries = Object.entries(listofpaths).sort((a, b) => a[0].localeCompare(b[0]));
          const shapes = listofentries.map((entry) => {
            const path = entry[1];
            if (target === "geom2" && path.isClosed) {
              const points = geometries.path2.toPoints(path).slice();
              points.push(points[0]);
              return geometries.geom2.fromPoints(points);
            }
            return path;
          });
          return shapes;
        }
      };
      return types[obj.type](obj, svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, svgGroups, segments);
    };
    module.exports = shapesMapGeometry;
    var appendPoints = (points, geometry) => {
      if (geometry)
        return geometries.path2.appendPoints(points, geometry);
      return geometries.path2.fromPoints({}, points);
    };
    var expandPath = (obj, svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, svgGroups, segments, pathSelfClosed) => {
      const paths = {};
      const on = "path";
      let sx = 0;
      let sy = 0;
      let cx = 0;
      let cy = 0;
      let pi = 0;
      let pathName = on + pi;
      let pc = false;
      let bx = 0;
      let by = 0;
      let qx = 0;
      let qy = 0;
      const newPath = () => {
        pi++;
        pathName = on + pi;
        pc = false;
      };
      const ensurePath = () => {
        if (!paths[pathName])
          paths[pathName] = geometries.path2.fromPoints({}, []);
      };
      for (let j = 0; j < obj.commands.length; j++) {
        const co = obj.commands[j];
        const pts = co.p;
        let i = 0;
        switch (co.c) {
          case "m":
            if (j === 0) {
              cx = 0;
              cy = 0;
            }
            if (pi > 0 && pc === false) {
            }
            if (pts.length >= i + 2) {
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              newPath();
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)]);
              sx = cx;
              sy = cy;
            }
            while (pts.length >= i + 2) {
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "M":
            if (pi > 0 && pc === false) {
            }
            if (pts.length >= i + 2) {
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              newPath();
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)]);
              sx = cx;
              sy = cy;
            }
            while (pts.length >= i + 2) {
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "a":
            while (pts.length >= i + 7) {
              const rx = parseFloat(pts[i++]);
              const ry = parseFloat(pts[i++]);
              const ro = 0 - parseFloat(pts[i++]) * 0.017453292519943295;
              const lf = pts[i++] === "1";
              const sf = pts[i++] === "1";
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendArc({
                segments,
                endpoint: svg2cag([cx, cy], svgUnitsPmm),
                radius: svg2cag([rx, ry], svgUnitsPmm),
                xaxisrotation: ro,
                clockwise: sf,
                large: lf
              }, paths[pathName]);
            }
            break;
          case "A":
            while (pts.length >= i + 7) {
              const rx = parseFloat(pts[i++]);
              const ry = parseFloat(pts[i++]);
              const ro = 0 - parseFloat(pts[i++]) * 0.017453292519943295;
              const lf = pts[i++] === "1";
              const sf = pts[i++] === "1";
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendArc({
                segments,
                endpoint: svg2cag([cx, cy], svgUnitsPmm),
                radius: svg2cag([rx, ry], svgUnitsPmm),
                xaxisrotation: ro,
                clockwise: sf,
                large: lf
              }, paths[pathName]);
            }
            break;
          case "c":
            while (pts.length >= i + 6) {
              const x1 = cx + parseFloat(pts[i++]);
              const y1 = cy + parseFloat(pts[i++]);
              bx = cx + parseFloat(pts[i++]);
              by = cy + parseFloat(pts[i++]);
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag([x1, y1], svgUnitsPmm),
                  svg2cag([bx, by], svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "C":
            while (pts.length >= i + 6) {
              const x1 = parseFloat(pts[i++]);
              const y1 = parseFloat(pts[i++]);
              bx = parseFloat(pts[i++]);
              by = parseFloat(pts[i++]);
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag([x1, y1], svgUnitsPmm),
                  svg2cag([bx, by], svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "q":
            while (pts.length >= i + 4) {
              const p0 = [cx, cy];
              qx = cx + parseFloat(pts[i++]);
              qy = cy + parseFloat(pts[i++]);
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag(q1, svgUnitsPmm),
                  svg2cag(q2, svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "Q":
            while (pts.length >= i + 4) {
              const p0 = [cx, cy];
              qx = parseFloat(pts[i++]);
              qy = parseFloat(pts[i++]);
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag(q1, svgUnitsPmm),
                  svg2cag(q2, svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "t":
            while (pts.length >= i + 2) {
              const p0 = [cx, cy];
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag(q1, svgUnitsPmm),
                  svg2cag(q2, svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "T":
            while (pts.length >= i + 2) {
              const p0 = [cx, cy];
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag(q1, svgUnitsPmm),
                  svg2cag(q2, svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "s":
            while (pts.length >= i + 4) {
              const x1 = bx;
              const y1 = by;
              bx = cx + parseFloat(pts[i++]);
              by = cy + parseFloat(pts[i++]);
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag([x1, y1], svgUnitsPmm),
                  svg2cag([bx, by], svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "S":
            while (pts.length >= i + 4) {
              const x1 = bx;
              const y1 = by;
              bx = parseFloat(pts[i++]);
              by = parseFloat(pts[i++]);
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              ensurePath();
              paths[pathName] = geometries.path2.appendBezier({
                segments,
                controlPoints: [
                  svg2cag([x1, y1], svgUnitsPmm),
                  svg2cag([bx, by], svgUnitsPmm),
                  svg2cag([cx, cy], svgUnitsPmm)
                ]
              }, paths[pathName]);
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "h":
            while (pts.length >= i + 1) {
              cx = cx + parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "H":
            while (pts.length >= i + 1) {
              cx = parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "l":
            while (pts.length >= i + 2) {
              cx = cx + parseFloat(pts[i++]);
              cy = cy + parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "L":
            while (pts.length >= i + 2) {
              cx = parseFloat(pts[i++]);
              cy = parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "v":
            while (pts.length >= i + 1) {
              cy = cy + parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "V":
            while (pts.length >= i + 1) {
              cy = parseFloat(pts[i++]);
              paths[pathName] = appendPoints([svg2cag([cx, cy], svgUnitsPmm)], paths[pathName]);
            }
            break;
          case "z":
          case "Z":
            paths[pathName] = geometries.path2.close(paths[pathName]);
            cx = sx;
            cy = sy;
            pc = true;
            break;
          default:
            console.log("Warning: Unknow PATH command [" + co.c + "]");
            break;
        }
        const isCloseCmd = (cmd) => cmd === "z" || cmd === "Z";
        if (pc !== true && paths[pathName] && paths[pathName].isClosed) {
          let coNext = obj.commands[j + 1];
          if (coNext && !isCloseCmd(coNext.c)) {
            if (pathSelfClosed === "trim") {
              while (coNext && !isCloseCmd(coNext.c)) {
                j++;
                coNext = obj.commands[j + 1];
              }
            } else if (pathSelfClosed === "split") {
              newPath();
            } else {
              throw new Error(`Malformed svg path at ${obj.position[0]}:${co.pos}. Path closed itself with command #${j} ${co.c}${pts.join(" ")}`);
            }
          }
        }
      }
      return paths;
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/shapesMapJscad.js
var require_shapesMapJscad = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/shapesMapJscad.js"(exports, module) {
    var { svg2cag, cagLengthX, cagLengthY, cagLengthP, reflect } = require_helpers3();
    var shapesMap = (obj, codify, params) => {
      const { level, indent, on, svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, svgGroups, target, segments } = params;
      const types = {
        group: (obj2) => {
          let code = codify({ target, segments }, obj2);
          code += `${indent}${on} = levels.l${level + 1}
`;
          return code;
        },
        rect: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, params2, svgGroups2, segments2) => {
          let x = cagLengthX(obj2.x, svgUnitsPmm2, svgUnitsX2);
          let y = 0 - cagLengthY(obj2.y, svgUnitsPmm2, svgUnitsY2);
          const w = cagLengthX(obj2.width, svgUnitsPmm2, svgUnitsX2);
          const h = cagLengthY(obj2.height, svgUnitsPmm2, svgUnitsY2);
          const rx = cagLengthX(obj2.rx, svgUnitsPmm2, svgUnitsX2);
          let code;
          if (w > 0 && h > 0) {
            x = (x + w / 2).toFixed(4);
            y = (y - h / 2).toFixed(4);
            if (rx === 0) {
              code = `${indent}${on} = primitives.rectangle({center: [${x}, ${y}], size: [${w}, ${h}]}) // line ${obj2.position}
`;
            } else {
              code = `${indent}${on} = primitives.roundedRectangle({center: [${x}, ${y}], segments: ${segments2}, size: [${w}, ${h}], roundRadius: ${rx}}) // line ${obj2.position}
`;
            }
            if (target === "path") {
              code += `${indent}${on} = geometries.path2.fromPoints({closed: true}, geometries.geom2.toPoints(${on}))
`;
            }
          }
          return code;
        },
        circle: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, params2, svgGroups2, segments2) => {
          const x = cagLengthX(obj2.x, svgUnitsPmm2, svgUnitsX2);
          const y = 0 - cagLengthY(obj2.y, svgUnitsPmm2, svgUnitsY2);
          const r = cagLengthP(obj2.radius, svgUnitsPmm2, svgUnitsV2);
          let code;
          if (r > 0) {
            code = `${indent}${on} = primitives.circle({center: [${x}, ${y}], segments: ${segments2}, radius: ${r}}) // line ${obj2.position}
`;
            if (target === "path") {
              code += `${indent}${on} = geometries.path2.fromPoints({closed: true}, geometries.geom2.toPoints(${on}))
`;
            }
          }
          return code;
        },
        ellipse: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2, params2, svgGroups2, segments2) => {
          const rx = cagLengthX(obj2.rx, svgUnitsPmm2, svgUnitsX2);
          const ry = cagLengthY(obj2.ry, svgUnitsPmm2, svgUnitsY2);
          const cx = cagLengthX(obj2.cx, svgUnitsPmm2, svgUnitsX2);
          const cy = 0 - cagLengthY(obj2.cy, svgUnitsPmm2, svgUnitsY2);
          let code;
          if (rx > 0 && ry > 0) {
            code = `${indent}${on} = primitives.ellipse({center: [${cx}, ${cy}], segments: ${segments2}, radius: [${rx}, ${ry}]}) // line ${obj2.position}
`;
            if (target === "path") {
              code += `${indent}${on} = geometries.path2.fromPoints({closed: true}, geometries.geom2.toPoints(${on}))
`;
            }
          }
          return code;
        },
        line: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2) => {
          const x1 = cagLengthX(obj2.x1, svgUnitsPmm2, svgUnitsX2);
          const y1 = 0 - cagLengthY(obj2.y1, svgUnitsPmm2, svgUnitsY2);
          const x2 = cagLengthX(obj2.x2, svgUnitsPmm2, svgUnitsX2);
          const y2 = 0 - cagLengthY(obj2.y2, svgUnitsPmm2, svgUnitsY2);
          const code = `${indent}${on} = primitives.line([[${x1}, ${y1}], [${x2}, ${y2}]]) // line ${obj2.position}
`;
          if (target === "geom2") {
          }
          return code;
        },
        polygon: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2) => {
          let code = `${indent}${on} = primitives.polygon({points: [
`;
          for (let j = 0; j < obj2.points.length; j++) {
            const p = obj2.points[j];
            if ("x" in p && "y" in p) {
              const x = cagLengthX(p.x, svgUnitsPmm2, svgUnitsX2);
              const y = 0 - cagLengthY(p.y, svgUnitsPmm2, svgUnitsY2);
              code += `${indent}  [${x}, ${y}],
`;
            }
          }
          code += `${indent}]}) // line ${obj2.position}
`;
          if (target === "path") {
            code += `${indent}${on} = geometries.path2.fromPoints({closed: true}, geometries.geom2.toPoints(${on}))
`;
          }
          return code;
        },
        polyline: (obj2, svgUnitsPmm2, svgUnitsX2, svgUnitsY2, svgUnitsV2) => {
          let code = `${indent}${on} = geometries.path2.fromPoints({}, [
`;
          for (let j = 0; j < obj2.points.length; j++) {
            const p = obj2.points[j];
            if ("x" in p && "y" in p) {
              const x = cagLengthX(p.x, svgUnitsPmm2, svgUnitsX2);
              const y = 0 - cagLengthY(p.y, svgUnitsPmm2, svgUnitsY2);
              code += `${indent}  [${x}, ${y}],
`;
            }
          }
          code += `${indent}]) // line ${obj2.position}
`;
          if (target === "geom2") {
          }
          return code;
        },
        path
      };
      return types[obj.type](obj, svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, params, svgGroups, segments);
    };
    module.exports = shapesMap;
    var path = (obj, svgUnitsPmm, svgUnitsX, svgUnitsY, svgUnitsV, params, svgGroups, segments) => {
      const { indent, on, target } = params;
      let tmpCode = `${indent}parts = [] // line ${obj.position}
`;
      let sx = 0;
      let sy = 0;
      let cx = 0;
      let cy = 0;
      let pi = 0;
      let pathName = on + pi;
      let pc = false;
      let bx = 0;
      let by = 0;
      let qx = 0;
      let qy = 0;
      for (let j = 0; j < obj.commands.length; j++) {
        const co = obj.commands[j];
        const pts = co.p;
        switch (co.c) {
          case "m":
            if (j === 0) {
              cx = 0;
              cy = 0;
            }
            if (pi > 0 && pc === false) {
              tmpCode += `${indent}parts.push(${pathName})
`;
            }
            if (pts.length >= 2) {
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              pi++;
              pc = false;
              pathName = on + pi;
              tmpCode += `${indent}${pathName} = geometries.path2.fromPoints({}, [[${svg2cag([cx, cy], svgUnitsPmm)}]])
`;
              sx = cx;
              sy = cy;
            }
            while (pts.length >= 2) {
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([${svg2cag([cx, cy], svgUnitsPmm)}], ${pathName})
`;
            }
            break;
          case "M":
            if (pi > 0 && pc === false) {
              tmpCode += `${indent}parts.push(${pathName})
`;
            }
            if (pts.length >= 2) {
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              pi++;
              pc = false;
              pathName = on + pi;
              tmpCode += `${indent}${pathName} = geometries.path2.fromPoints({}, [[${svg2cag([cx, cy], svgUnitsPmm)}]])
`;
              sx = cx;
              sy = cy;
            }
            while (pts.length >= 2) {
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([${svg2cag([cx, cy], svgUnitsPmm)}], ${pathName})
`;
            }
            break;
          case "a":
            while (pts.length >= 7) {
              const rx = parseFloat(pts.shift());
              const ry = parseFloat(pts.shift());
              const ro = 0 - parseFloat(pts.shift()) * 0.017453292519943295;
              const lf = pts.shift() === "1";
              const sf = pts.shift() === "1";
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendArc({segments: ${segments}, endpoint: [${svg2cag([cx, cy], svgUnitsPmm)}], radius: [${svg2cag([rx, ry], svgUnitsPmm)}], xaxisrotation: ${ro}, clockwise: ${sf}, large: ${lf}}, ${pathName})
`;
            }
            break;
          case "A":
            while (pts.length >= 7) {
              const rx = parseFloat(pts.shift());
              const ry = parseFloat(pts.shift());
              const ro = 0 - parseFloat(pts.shift()) * 0.017453292519943295;
              const lf = pts.shift() === "1";
              const sf = pts.shift() === "1";
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendArc({segments: ${segments}, endpoint: [${svg2cag([cx, cy], svgUnitsPmm)}], radius: [${svg2cag([rx, ry], svgUnitsPmm)}], xaxisrotation: ${ro}, clockwise: ${sf}, large: ${lf}}, ${pathName})
`;
            }
            break;
          case "c":
            while (pts.length >= 6) {
              const x1 = cx + parseFloat(pts.shift());
              const y1 = cy + parseFloat(pts.shift());
              bx = cx + parseFloat(pts.shift());
              by = cy + parseFloat(pts.shift());
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag([x1, y1], svgUnitsPmm)}], [${svg2cag([bx, by], svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "C":
            while (pts.length >= 6) {
              const x1 = parseFloat(pts.shift());
              const y1 = parseFloat(pts.shift());
              bx = parseFloat(pts.shift());
              by = parseFloat(pts.shift());
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag([x1, y1], svgUnitsPmm)}], [${svg2cag([bx, by], svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "q":
            while (pts.length >= 4) {
              const p0 = [cx, cy];
              qx = cx + parseFloat(pts.shift());
              qy = cy + parseFloat(pts.shift());
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag(q1, svgUnitsPmm)}], [${svg2cag(q2, svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "Q":
            while (pts.length >= 4) {
              const p0 = [cx, cy];
              qx = parseFloat(pts.shift());
              qy = parseFloat(pts.shift());
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag(q1, svgUnitsPmm)}], [${svg2cag(q2, svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "t":
            while (pts.length >= 2) {
              const p0 = [cx, cy];
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[[${svg2cag(q1, svgUnitsPmm)}], [${svg2cag(q2, svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "T":
            while (pts.length >= 2) {
              const p0 = [cx, cy];
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              const q1 = [p0[0] + 2 / 3 * (qx - p0[0]), p0[1] + 2 / 3 * (qy - p0[1])];
              const q2 = [q1[0] + 1 / 3 * (cx - p0[0]), q1[1] + 1 / 3 * (cy - p0[1])];
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[[${svg2cag(q1, svgUnitsPmm)}], [${svg2cag(q2, svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(qx, qy, cx, cy);
              qx = rf[0];
              qy = rf[1];
            }
            break;
          case "s":
            while (pts.length >= 4) {
              const x1 = bx;
              const y1 = by;
              bx = cx + parseFloat(pts.shift());
              by = cy + parseFloat(pts.shift());
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag([x1, y1], svgUnitsPmm)}], [${svg2cag([bx, by], svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "S":
            while (pts.length >= 4) {
              const x1 = bx;
              const y1 = by;
              bx = parseFloat(pts.shift());
              by = parseFloat(pts.shift());
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendBezier({segments: ${segments}, controlPoints: [[${svg2cag([x1, y1], svgUnitsPmm)}], [${svg2cag([bx, by], svgUnitsPmm)}], [${svg2cag([cx, cy], svgUnitsPmm)}]]}, ${pathName})
`;
              const rf = reflect(bx, by, cx, cy);
              bx = rf[0];
              by = rf[1];
            }
            break;
          case "h":
            while (pts.length >= 1) {
              cx = cx + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "H":
            while (pts.length >= 1) {
              cx = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "l":
            while (pts.length >= 2) {
              cx = cx + parseFloat(pts.shift());
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "L":
            while (pts.length >= 2) {
              cx = parseFloat(pts.shift());
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "v":
            while (pts.length >= 1) {
              cy = cy + parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "V":
            while (pts.length >= 1) {
              cy = parseFloat(pts.shift());
              tmpCode += `${indent}${pathName} = geometries.path2.appendPoints([[${svg2cag([cx, cy], svgUnitsPmm)}]], ${pathName})
`;
            }
            break;
          case "z":
          case "Z":
            tmpCode += `${indent}${pathName} = geometries.path2.close(${pathName})
`;
            if (target === "geom2") {
              tmpCode += `${indent}${pathName} = geometries.geom2.fromPoints(geometries.path2.toPoints(${pathName}))
`;
            }
            tmpCode += `${indent}parts.push(${pathName})
`;
            cx = sx;
            cy = sy;
            pc = true;
            break;
          default:
            console.log("Warning: Unknow PATH command [" + co.c + "]");
            break;
        }
      }
      if (pi > 0 && pc === false) {
        tmpCode += `${indent}parts.push(${pathName})
`;
      }
      tmpCode += `${indent}${on} = parts
`;
      return tmpCode;
    };
  }
});

// node_modules/@jscad/svg-deserializer/src/index.js
var require_src6 = __commonJS({
  "node_modules/@jscad/svg-deserializer/src/index.js"(exports, module) {
    var saxes = require_saxes();
    var { colors, transforms } = require_src();
    var { toArray } = require_src2();
    var version = require_package7().version;
    var { cagLengthX, cagLengthY, svgColorForTarget } = require_helpers3();
    var { svgSvg, svgRect, svgCircle, svgGroup, svgLine, svgPath, svgEllipse, svgPolygon, svgPolyline, svgUse } = require_svgElementHelpers();
    var shapesMapGeometry = require_shapesMapGeometry();
    var shapesMapJscad = require_shapesMapJscad();
    var deserialize = (options, input) => {
      const defaults = {
        addMetaData: true,
        filename: "svg",
        output: "script",
        pxPmm: require_constants2().pxPmm,
        segments: 32,
        target: "path",
        // target - 'geom2' or 'path'
        pathSelfClosed: "error",
        version
      };
      options = Object.assign({}, defaults, options);
      return options.output === "script" ? translate(input, options) : instantiate(input, options);
    };
    var instantiate = (src, options) => {
      const { pxPmm } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      createSvgParser(src, pxPmm);
      if (!svgObj) {
        throw new Error("SVG parsing failed, no valid SVG data retrieved");
      }
      options && options.statusCallback && options.statusCallback({ progress: 50 });
      const result = objectify(options, svgObj);
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return result;
    };
    var translate = (src, options) => {
      const { filename, version: version2, pxPmm, addMetaData } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      createSvgParser(src, pxPmm);
      if (!svgObj) {
        throw new Error("SVG parsing failed, no valid SVG data retrieved");
      }
      let code = addMetaData ? `//
  // producer: JSCAD SVG Deserializer ${version2}
  // date: ${/* @__PURE__ */ new Date()}
  // source: ${filename}
  //
` : "";
      code += "const { colors, geometries, primitives, transforms } = require('@jscad/modeling')\n\n";
      options && options.statusCallback && options.statusCallback({ progress: 50 });
      const scadCode = codify(options, svgObj);
      code += scadCode;
      code += "\nmodule.exports = { main }";
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return code;
    };
    var svgUnitsX;
    var svgUnitsY;
    var svgUnitsV;
    var svgObjects = [];
    var svgGroups = [];
    var svgDefs = [];
    var svgInDefs = false;
    var svgObj;
    var svgUnitsPmm = [1, 1];
    var objectify = (options, group) => {
      const { target, segments, pathSelfClosed } = options;
      const level = svgGroups.length;
      svgGroups.push(group);
      let i = level;
      while (i > 0) {
        i--;
      }
      let geometries = [];
      const params = {
        svgUnitsPmm,
        svgUnitsX,
        svgUnitsY,
        svgUnitsV,
        level,
        target,
        svgGroups,
        segments,
        pathSelfClosed
      };
      for (i = 0; i < group.objects.length; i++) {
        const obj = group.objects[i];
        let shapes = toArray(shapesMapGeometry(obj, objectify, params));
        shapes = shapes.map((shape) => {
          if ("transforms" in obj) {
            let rotateAttribute = null;
            let scaleAttribute = null;
            let translateAttribute = null;
            for (let j = 0; j < obj.transforms.length; j++) {
              const t = obj.transforms[j];
              if ("rotate" in t) {
                rotateAttribute = t;
              }
              if ("scale" in t) {
                scaleAttribute = t;
              }
              if ("translate" in t) {
                translateAttribute = t;
              }
            }
            if (scaleAttribute !== null) {
              let x = Math.abs(scaleAttribute.scale[0]);
              let y = Math.abs(scaleAttribute.scale[1]);
              shape = transforms.scale([x, y, 1], shape);
              x = scaleAttribute.scale[0];
              y = scaleAttribute.scale[1];
              if (x < 0) {
                shape = transforms.mirrorX(shape);
              }
              if (y < 0) {
                shape = transforms.mirrorY(shape);
              }
            }
            if (rotateAttribute !== null) {
              const z = 0 - rotateAttribute.rotate * 0.017453292519943295;
              shape = transforms.rotateZ(z, shape);
            }
            if (translateAttribute !== null) {
              const x = cagLengthX(translateAttribute.translate[0], svgUnitsPmm, svgUnitsX);
              const y = 0 - cagLengthY(translateAttribute.translate[1], svgUnitsPmm, svgUnitsY);
              shape = transforms.translate([x, y, 0], shape);
            }
          }
          const color = svgColorForTarget(target, obj);
          if (color)
            shape = colors.colorize(color, shape);
          return shape;
        });
        geometries = geometries.concat(shapes);
      }
      svgGroups.pop();
      return geometries;
    };
    var codify = (options, group) => {
      const { target, segments } = options;
      const level = svgGroups.length;
      svgGroups.push(group);
      let indent = "  ";
      let i = level;
      while (i > 0) {
        indent += "  ";
        i--;
      }
      let code = "";
      if (level === 0) {
        code += "function main(params) {\n  let levels = {}\n  let paths = {}\n  let parts\n";
      }
      const ln = "levels.l" + level;
      code += `${indent}${ln} = []
`;
      for (i = 0; i < group.objects.length; i++) {
        const obj = group.objects[i];
        const on = "paths.p" + i;
        const params = {
          level,
          indent,
          ln,
          on,
          svgUnitsPmm,
          svgUnitsX,
          svgUnitsY,
          svgUnitsV,
          svgGroups,
          target,
          segments
        };
        const tmpCode = shapesMapJscad(obj, codify, params);
        code += tmpCode;
        if ("transforms" in obj) {
          let rotateAttribute = null;
          let scaleAttribute = null;
          let translateAttribute = null;
          for (let j = 0; j < obj.transforms.length; j++) {
            const t = obj.transforms[j];
            if ("rotate" in t) {
              rotateAttribute = t;
            }
            if ("scale" in t) {
              scaleAttribute = t;
            }
            if ("translate" in t) {
              translateAttribute = t;
            }
          }
          if (scaleAttribute !== null) {
            let x = Math.abs(scaleAttribute.scale[0]);
            let y = Math.abs(scaleAttribute.scale[1]);
            code += `${indent}${on} = transforms.scale([${x}, ${y}, 1], ${on})
`;
            x = scaleAttribute.scale[0];
            y = scaleAttribute.scale[1];
            if (x < 0) {
              code += `${indent}${on} = transforms.mirrorX(${on})
`;
            }
            if (y < 0) {
              code += `${indent}${on} = transforms.mirrorY(${on})
`;
            }
          }
          if (rotateAttribute !== null) {
            const z = 0 - rotateAttribute.rotate * 0.017453292519943295;
            code += `${indent}${on} = transforms.rotateZ(${z}, ${on})
`;
          }
          if (translateAttribute !== null) {
            const x = cagLengthX(translateAttribute.translate[0], svgUnitsPmm, svgUnitsX);
            const y = 0 - cagLengthY(translateAttribute.translate[1], svgUnitsPmm, svgUnitsY);
            code += `${indent}${on} = transforms.translate([${x}, ${y}, 0], ${on})
`;
          }
        }
        const color = svgColorForTarget(target, obj);
        if (color) {
          code += `${indent}${on} = colors.colorize([${color}], ${on})
`;
        }
        code += `${indent}${ln} = ${ln}.concat(${on})

`;
      }
      if (level === 0) {
        code += indent + "return " + ln + "\n";
        code += "}\n";
      }
      svgGroups.pop();
      return code;
    };
    var createSvgParser = (src, pxPmm) => {
      const parser = new saxes.SaxesParser();
      if (pxPmm !== void 0 && pxPmm > parser.pxPmm) {
        parser.pxPmm = pxPmm;
      }
      parser.on("error", (e) => {
        console.log(`ERROR: SVG file, line ${parser.line}, column ${parser.column}`);
        console.log(e);
      });
      parser.on("opentag", (node) => {
        const objMap = {
          SVG: svgSvg,
          G: svgGroup,
          RECT: svgRect,
          CIRCLE: svgCircle,
          ELLIPSE: svgEllipse,
          LINE: svgLine,
          POLYLINE: svgPolyline,
          POLYGON: svgPolygon,
          PATH: svgPath,
          USE: svgUse,
          DEFS: () => {
            svgInDefs = true;
            return void 0;
          },
          DESC: () => void 0,
          // ignored by design
          TITLE: () => void 0,
          // ignored by design
          STYLE: () => void 0,
          // ignored by design
          undefined: () => console.log("WARNING: unsupported SVG element: " + node.name)
        };
        node.attributes.position = [parser.line + 1, parser.column + 1];
        const elementName = node.name.toUpperCase();
        const obj = objMap[elementName] ? objMap[elementName](node.attributes, { svgObjects, customPxPmm: pxPmm }) : void 0;
        if (obj) {
          if ("id" in obj) {
            svgObjects[obj.id] = obj;
          }
          if (obj.type === "svg") {
            svgGroups.push(obj);
            svgUnitsPmm = obj.unitsPmm;
            svgUnitsX = obj.viewW;
            svgUnitsY = obj.viewH;
            svgUnitsV = obj.viewP;
          } else {
            if (svgInDefs === true) {
              if (svgDefs.length > 0) {
                const group = svgDefs.pop();
                if ("objects" in group) {
                  group.objects.push(obj);
                }
                svgDefs.push(group);
              }
              if (obj.type === "group") {
                svgDefs.push(obj);
              }
            } else {
              if (svgGroups.length > 0) {
                const group = svgGroups.pop();
                if ("objects" in group) {
                  group.objects.push(obj);
                }
                svgGroups.push(group);
              }
              if (obj.type === "group") {
                svgGroups.push(obj);
              }
            }
          }
        }
      });
      parser.on("closetag", (node) => {
        const popGroup = () => {
          if (svgInDefs === true) {
            return svgDefs.pop();
          } else {
            return svgGroups.pop();
          }
        };
        const objMap = {
          SVG: popGroup,
          DEFS: () => {
            svgInDefs = false;
          },
          USE: popGroup,
          G: popGroup,
          undefined: () => {
          }
        };
        const elementName = node.name.toUpperCase();
        const obj = objMap[elementName] ? objMap[elementName]() : void 0;
        if (svgGroups.length === 0) {
          svgObj = obj;
        }
      });
      parser.on("end", () => {
      });
      parser.write(src).close();
      return parser;
    };
    var extension = "svg";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/x3d-deserializer/package.json
var require_package8 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/package.json"(exports, module) {
    module.exports = {
      name: "@jscad/x3d-deserializer",
      version: "2.2.5",
      description: "X3D Deserializer for JSCAD",
      repository: "https://github.com/jscad/OpenJSCAD.org/",
      main: "src/index.js",
      scripts: {
        coverage: "nyc --all --reporter=html --reporter=text npm test",
        test: "ava --verbose --timeout 2m 'tests/**/*.test.js'"
      },
      contributors: [
        {
          name: "z3dev",
          url: "https://github.com/z3dev"
        }
      ],
      keywords: [
        "openjscad",
        "jscad",
        "import",
        "deserializer",
        "x3d"
      ],
      license: "MIT",
      publishConfig: {
        access: "public"
      },
      dependencies: {
        "@jscad/array-utils": "2.1.4",
        "@jscad/modeling": "2.12.0",
        saxes: "5.0.1"
      },
      devDependencies: {
        ava: "3.15.0",
        nyc: "15.1.0"
      },
      gitHead: "e269f212db5a00cda740d2f7ad3e5206d1eb839f"
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/createTransform.js
var require_createTransform = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/createTransform.js"(exports, module) {
    var { maths } = require_src();
    var createTransform = (center, rotation, scale, scaleOrientation, translation) => {
      const matrix = maths.mat4.create();
      const temp = maths.mat4.create();
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromTranslation(temp, translation));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromTranslation(temp, center));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromRotation(temp, rotation[3], rotation));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromRotation(temp, scaleOrientation[3], scaleOrientation));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromScaling(temp, scale));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromRotation(temp, scaleOrientation[3], maths.vec3.negate(maths.vec3.create(), scaleOrientation)));
      maths.mat4.multiply(matrix, matrix, maths.mat4.fromTranslation(temp, maths.vec3.negate(maths.vec3.create(), center)));
      return matrix;
    };
    module.exports = createTransform;
  }
});

// node_modules/@jscad/x3d-deserializer/src/objects.js
var require_objects = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/objects.js"(exports, module) {
    var { maths } = require_src();
    var x3dTypes = {
      X3D: 0,
      UNIT: 1,
      META: 2,
      SCENE: 3,
      TRANSFORM: 4,
      SHAPE: 5,
      GROUP: 6,
      APPEARANCE: 7,
      // shapes with data nodes
      TRIANGLESET: 10,
      TRIANGLEFANSET: 11,
      TRIANGLESTRIPSET: 12,
      QUADSET: 13,
      INDEXEDTRIANGLESET: 14,
      INDEXEDTRIANGLEFANSET: 15,
      INDEXEDTRIANGLESTRIPSET: 16,
      INDEXEDQUADSET: 17,
      ELEVATIONGRID: 18,
      INDEXEDFACESET: 19,
      LINESET: 20,
      INDEXEDLINESET: 21,
      // 3D primitives
      BOX: 50,
      CONE: 51,
      CYLINDER: 52,
      SPHERE: 53,
      EXTRUSION: 54,
      // 2D primitives
      ARC2D: 61,
      ARCCLOSE2D: 62,
      CIRCLE2D: 63,
      DISK2D: 64,
      POLYLINE2D: 65,
      RECTANGLE2D: 66,
      TRIANGLESET2D: 67,
      // data nodes
      COLOR: 91,
      COORDINATE: 92,
      MATERIAL: 93
    };
    var x3dX3D = (element) => {
      const obj = { definition: x3dTypes.X3D };
      obj.objects = [];
      return obj;
    };
    var x3dUnit = (element) => {
      const obj = { definition: x3dTypes.UNIT, category: "", name: "", conversionFactor: 1 };
      if (element.category)
        obj.category = element.category;
      if (element.name)
        obj.name = element.name;
      if (element.conversionfactor)
        obj.conversionFactor = element.conversionfactor;
      return obj;
    };
    var x3dMeta = (element) => {
      const obj = { definition: x3dTypes.META, content: "", name: "" };
      if (element.content)
        obj.content = element.content;
      if (element.name)
        obj.name = element.name;
      return obj;
    };
    var x3dScene = (element) => {
      const obj = { definition: x3dTypes.SCENE };
      obj.objects = [];
      return obj;
    };
    var x3dTransform = (element) => {
      const obj = {
        definition: x3dTypes.TRANSFORM,
        center: [0, 0, 0],
        rotation: [0, 0, 1, 0],
        scale: [1, 1, 1],
        scaleOrientation: [0, 0, 1, 0],
        translation: [0, 0, 0]
      };
      if (element.center) {
        const values = element.center.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          obj.center = values;
        }
      }
      if (element.rotation) {
        const values = element.rotation.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 3) {
          obj.rotation = values;
        }
      }
      if (element.scale) {
        const values = element.scale.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          obj.scale = values;
        }
      }
      if (element.scaleorientation) {
        const values = element.scaleorientation.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 3) {
          obj.scaleOrientation = values;
        }
      }
      if (element.translation) {
        const values = element.translation.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          obj.translation = values;
        }
      }
      obj.objects = [];
      return obj;
    };
    var x3dShape = (element) => {
      const obj = { definition: x3dTypes.SHAPE };
      obj.objects = [];
      return obj;
    };
    var x3dBox = (element) => {
      const obj = { definition: x3dTypes.BOX, size: [2, 2, 2] };
      if (element.size) {
        const values = element.size.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          obj.size = values;
        }
      }
      return obj;
    };
    var x3dCone = (element) => {
      const NEAR0 = 1e-5;
      const obj = { definition: x3dTypes.CONE, bottomRadius: 1, height: 2, subdivision: 32, topRadius: NEAR0 };
      if (element.bottomRadius) {
        obj.bottomRadius = Math.max(parseFloat(element.bottomRadius), NEAR0);
      }
      if (element.height) {
        obj.height = parseFloat(element.height);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      if (element.topRadius) {
        obj.topRadius = Math.max(parseFloat(element.topRadius), NEAR0);
      }
      return obj;
    };
    var x3dCylinder = (element) => {
      const obj = { definition: x3dTypes.CYLINDER, height: 2, radius: 1, subdivision: 32 };
      if (element.height) {
        obj.height = parseFloat(element.height);
      }
      if (element.radius) {
        obj.radius = parseFloat(element.radius);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      return obj;
    };
    var x3dSphere = (element) => {
      const obj = { definition: x3dTypes.SPHERE, radius: 1, subdivision: 24 };
      if (element.radius) {
        obj.radius = parseFloat(element.radius);
      }
      if (element.subdivision) {
        const values = element.subdivision.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 1) {
          obj.subdivision = Math.max(...values);
        }
      }
      return obj;
    };
    var x3dExtrusion = (element) => {
      const obj = {
        definition: x3dTypes.EXTRUSION,
        ccw: true,
        beginCap: true,
        endCap: true,
        crossSection: [[1, 1], [1, -1], [-1, -1], [-1, 1], [1, 1]],
        orientations: [[0, 0, 1, 0]],
        scales: [[1, 1]],
        spine: [[0, 0, 0], [0, 1, 0]]
      };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.beginCap) {
        obj.beginCap = element.beginCap.includes("TRUE") || element.beginCap.includes("true");
      }
      if (element.endCap) {
        obj.endCap = element.endCap.includes("TRUE") || element.endCap.includes("true");
      }
      if (element.crossSection) {
        const values = element.crossSection.trim().split(/ +/).map((v) => parseFloat(v));
        const numpoints = Math.trunc(values.length / 2);
        const points = [];
        for (let i = 0; i < numpoints; i++) {
          const vi = i * 2;
          points.push([values[vi], values[vi + 1]]);
        }
        obj.ccw = maths.utils.area(points) < 0;
        obj.crossSection = points;
      }
      if (element.orientation) {
        const values = element.orientation.trim().split(/ +/).map((v) => parseFloat(v));
        const numpoints = Math.trunc(values.length / 4);
        const points = [];
        for (let i = 0; i < numpoints; i++) {
          const vi = i * 4;
          points.push([values[vi], values[vi + 1], values[vi + 2], values[vi + 3]]);
        }
        obj.orientations = points;
      }
      if (element.scale) {
        const values = element.scale.trim().split(/ +/).map((v) => parseFloat(v));
        const numpoints = Math.trunc(values.length / 2);
        const points = [];
        for (let i = 0; i < numpoints; i++) {
          const vi = i * 2;
          if (values[vi] === 0)
            values[vi] = 1e-6;
          if (values[vi + 1] === 0)
            values[vi + 1] = 1e-6;
          points.push([values[vi], values[vi + 1]]);
        }
        obj.scales = points;
      }
      if (element.spine) {
        const values = element.spine.trim().split(/ +/).map((v) => parseFloat(v));
        const numpoints = Math.trunc(values.length / 3);
        const points = [];
        for (let i = 0; i < numpoints; i++) {
          const vi = i * 3;
          points.push([values[vi], values[vi + 1], values[vi + 2]]);
        }
        obj.spine = points;
      }
      return obj;
    };
    var x3dArc2D = (element) => {
      const obj = { definition: x3dTypes.ARC2D, endAngle: Math.PI / 2, radius: 1, startAngle: 0, subdivision: 32 };
      if (element.endAngle) {
        obj.endAngle = parseFloat(element.endAngle);
      }
      if (element.radius) {
        obj.radius = parseFloat(element.radius);
      }
      if (element.startAngle) {
        obj.startAngle = parseFloat(element.startAngle);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      return obj;
    };
    var x3dArcClose2D = (element) => {
      const obj = { definition: x3dTypes.ARCCLOSE2D, closureType: "PIE", endAngle: Math.PI / 2, radius: 1, startAngle: 0, subdivision: 32 };
      if (element.closureType) {
        obj.closureType = element.closureType;
      }
      if (element.endAngle) {
        obj.endAngle = parseFloat(element.endAngle);
      }
      if (element.radius) {
        obj.radius = parseFloat(element.radius);
      }
      if (element.startAngle) {
        obj.startAngle = parseFloat(element.startAngle);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      return obj;
    };
    var x3dCircle2D = (element) => {
      const obj = { definition: x3dTypes.CIRCLE2D, radius: 1, subdivision: 32 };
      if (element.radius) {
        obj.radius = parseFloat(element.radius);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      return obj;
    };
    var x3dDisk2D = (element) => {
      const obj = { definition: x3dTypes.DISK2D, innerRadius: 0, outerRadius: 1, subdivision: 32 };
      if (element.innerRadius) {
        obj.innerRadius = parseFloat(element.innerRadius);
      }
      if (element.outerRadius) {
        obj.outerRadius = parseFloat(element.outerRadius);
      }
      if (element.subdivision) {
        obj.subdivision = parseFloat(element.subdivision);
      }
      return obj;
    };
    var x3dPolyline2D = (element) => {
      const obj = { definition: x3dTypes.POLYLINE2D, lineSegments: [] };
      if (element.lineSegments) {
        const values = element.lineSegments.trim().split(/ +/).map((v) => parseFloat(v));
        for (let i = 0; i < values.length; i = i + 2) {
          const point = [values[i], values[i + 1]];
          obj.lineSegments.push(point);
        }
      }
      return obj;
    };
    var x3dRectangle2D = (element) => {
      const obj = { definition: x3dTypes.RECTANGLE2D, size: [2, 2] };
      if (element.size) {
        const values = element.size.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 1) {
          obj.size = values;
        }
      }
      return obj;
    };
    var x3dTriangleSet2D = (element) => {
      const obj = { definition: x3dTypes.TRIANGLESET2D, vertices: [] };
      if (element.vertices) {
        const values = element.vertices.trim().split(/ +/).map((v) => parseFloat(v));
        for (let i = 0; i < values.length; i = i + 2) {
          const point = [values[i], values[i + 1]];
          obj.vertices.push(point);
        }
      }
      return obj;
    };
    var x3dLineSet = (element) => {
      const obj = { definition: x3dTypes.LINESET, vertexCount: [], colorPerVertex: true };
      if (element.vertexCount) {
        obj.vertexCount = element.vertexCount.trim().split(/ +/).map((v) => parseFloat(v));
      }
      if (element.colorPerVertex) {
        obj.colorPerVertex = element.colorPerVertex.includes("TRUE") || element.colorPerVertex.includes("true");
      }
      obj.objects = [];
      return obj;
    };
    var x3dIndexedLineSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDLINESET, indexes: [], colorPerVertex: true };
      if (element.coordIndex) {
        const indexes = element.coordIndex.trim().split(/ -1/);
        obj.indexes = indexes.map((index) => index.trim().split(/ +/).map((v) => parseFloat(v)));
        obj.indexes = obj.indexes.filter((index) => index.length > 1);
      }
      if (element.colorPerVertex) {
        obj.colorPerVertex = element.colorPerVertex.includes("TRUE") || element.colorPerVertex.includes("true");
      }
      obj.objects = [];
      return obj;
    };
    var x3dColor = (element) => {
      const obj = { definition: x3dTypes.COLOR, colors: [] };
      if (element.color) {
        const values = element.color.trim().split(/ +/).map((v) => parseFloat(v));
        const numvalues = values.length;
        const numcolors = Math.trunc(numvalues / 3);
        for (let i = 0; i < numcolors; i++) {
          const vi = i * 3;
          obj.colors.push([values[vi], values[vi + 1], values[vi + 2]]);
        }
      }
      return obj;
    };
    var x3dCoordinate = (element) => {
      const obj = { definition: x3dTypes.COORDINATE, points: [] };
      if (element.point) {
        const values = element.point.trim().split(/ +/).map((v) => parseFloat(v));
        const numvalues = values.length;
        const numpoints = Math.trunc(numvalues / 3);
        for (let i = 0; i < numpoints; i++) {
          const vi = i * 3;
          obj.points.push([values[vi], values[vi + 1], values[vi + 2]]);
        }
      }
      return obj;
    };
    var x3dTriangleSet = (element) => {
      const obj = { definition: x3dTypes.TRIANGLESET, ccw: true, colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      obj.objects = [];
      return obj;
    };
    var x3dTriangleFanSet = (element) => {
      const obj = { definition: x3dTypes.TRIANGLEFANSET, ccw: true, fanCount: [], colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.fanCount) {
        obj.fanCount = element.fanCount.trim().split(/ +/).map((v) => parseFloat(v));
      }
      obj.objects = [];
      return obj;
    };
    var x3dTriangleStripSet = (element) => {
      const obj = { definition: x3dTypes.TRIANGLESTRIPSET, ccw: true, stripCount: [], colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.stripCount) {
        obj.stripCount = element.stripCount.trim().split(/ +/).map((v) => parseFloat(v));
      }
      obj.objects = [];
      return obj;
    };
    var x3dQuadSet = (element) => {
      const obj = { definition: x3dTypes.QUADSET, ccw: true, colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      obj.objects = [];
      return obj;
    };
    var x3dIndexedTriangleSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDTRIANGLESET, ccw: true, index: [], colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.index) {
        obj.index = element.index.trim().split(/ +/).map((v) => parseFloat(v));
      }
      obj.objects = [];
      return obj;
    };
    var x3dIndexedTriangleFanSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDTRIANGLEFANSET, ccw: true, fans: [], colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.index) {
        const indexes = element.index.trim().split(/ -1/);
        obj.fans = indexes.map((index) => index.trim().split(/ +/).map((v) => parseFloat(v))).filter((index) => index.length > 2);
      }
      obj.objects = [];
      return obj;
    };
    var x3dIndexedTriangleStripSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDTRIANGLESTRIPSET, ccw: true, strips: [], colorPerVertex: true };
      obj.objects = [];
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.index) {
        const indexes = element.index.trim().split(/ -1/);
        obj.strips = indexes.map((index) => index.trim().split(/ +/).map((v) => parseFloat(v))).filter((index) => index.length > 2);
      }
      return obj;
    };
    var x3dIndexedQuadSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDQUADSET, ccw: true, index: [], colorPerVertex: true };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.index) {
        obj.index = element.index.trim().split(/ +/).map((v) => parseFloat(v));
      }
      obj.objects = [];
      return obj;
    };
    var x3dIndexedFaceSet = (element) => {
      const obj = { definition: x3dTypes.INDEXEDFACESET, ccw: true, convex: true, faces: [], colorPerVertex: true, colorIndex: null };
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.convex) {
        obj.convex = element.convex.includes("TRUE") || element.convex.includes("true");
      }
      if (element.coordIndex) {
        const indexes = element.coordIndex.trim().split(/ -1/);
        obj.faces = indexes.map((index) => index.trim().split(/ +/).map((v) => parseFloat(v))).filter((index) => index.length > 2);
      }
      if (element.colorPerVertex) {
        obj.colorPerVertex = element.colorPerVertex.includes("TRUE") || element.colorPerVertex.includes("true");
      }
      if (element.colorIndex) {
        if (obj.colorPerVertex) {
          const indexes = element.colorIndex.trim().split(/ -1/);
          obj.colorIndex = indexes.map((index) => index.trim().split(/ +/).map((v) => parseFloat(v))).filter((index) => index.length > 2);
        } else {
          obj.colorIndex = element.colorIndex.trim().split(/ +/).map((v) => parseFloat(v));
        }
      } else {
        obj.colorIndex = obj.faces;
      }
      obj.objects = [];
      return obj;
    };
    var x3dElevationGrid = (element) => {
      const obj = { definition: x3dTypes.ELEVATIONGRID, xDimension: 2, zDimension: 2, xSpacing: 1, zSpacing: 1, height: [0, 0, 0, 0], ccw: true, solid: false, colorPerVertex: true };
      if (element.xDimension) {
        obj.xDimension = parseFloat(element.xDimension);
      }
      if (element.zDimension) {
        obj.zDimension = parseFloat(element.zDimension);
      }
      if (element.xSpacing) {
        obj.xSpacing = parseFloat(element.xSpacing);
      }
      if (element.zSpacing) {
        obj.zSpacing = parseFloat(element.zSpacing);
      }
      if (element.height) {
        obj.height = element.height.trim().split(/ +/).map((v) => parseFloat(v));
      }
      if (element.ccw) {
        obj.ccw = element.ccw.includes("TRUE") || element.ccw.includes("true");
      }
      if (element.solid) {
        obj.solid = element.solid.includes("TRUE") || element.solid.includes("true");
      }
      if (element.colorPerVertex) {
        obj.colorPerVertex = element.colorPerVertex.includes("TRUE") || element.colorPerVertex.includes("true");
      }
      obj.objects = [];
      return obj;
    };
    var x3dAppearance = (element) => {
      const obj = { definition: x3dTypes.APPEARANCE };
      obj.objects = [];
      return obj;
    };
    var x3dMaterial = (element) => {
      const obj = { definition: x3dTypes.MATERIAL, color: [0.8, 0.8, 0.8, 1] };
      let alpha = 1;
      if (element.transparency) {
        alpha = 1 - element.transparency;
      }
      if (element.diffuseColor) {
        const values = element.diffuseColor.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          if (values.length < 4)
            values.push(alpha);
          obj.color = values;
        }
      }
      if (element.emissiveColor) {
        const values = element.emissiveColor.trim().split(/ +/).map((v) => parseFloat(v));
        if (values.length > 2) {
          if (values.length < 4)
            values.push(alpha);
          obj.color = values;
        }
      }
      return obj;
    };
    var x3dGroup = (element) => {
      const obj = { definition: x3dTypes.GROUP };
      obj.objects = [];
      return obj;
    };
    module.exports = {
      x3dTypes,
      x3dX3D,
      x3dUnit,
      x3dMeta,
      x3dScene,
      x3dTransform,
      x3dShape,
      x3dGroup,
      x3dBox,
      x3dCone,
      x3dCylinder,
      x3dSphere,
      x3dExtrusion,
      x3dArc2D,
      x3dArcClose2D,
      x3dCircle2D,
      x3dDisk2D,
      x3dPolyline2D,
      x3dRectangle2D,
      x3dTriangleSet2D,
      x3dColor,
      x3dCoordinate,
      x3dTriangleSet,
      x3dTriangleFanSet,
      x3dTriangleStripSet,
      x3dQuadSet,
      x3dIndexedTriangleSet,
      x3dIndexedTriangleFanSet,
      x3dIndexedTriangleStripSet,
      x3dIndexedQuadSet,
      x3dIndexedFaceSet,
      x3dElevationGrid,
      x3dLineSet,
      x3dIndexedLineSet,
      x3dAppearance,
      x3dMaterial
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/extrudeX3D.js
var require_extrudeX3D = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/extrudeX3D.js"(exports, module) {
    var { extrusions, geometries, maths } = require_src();
    var { mat4, vec3, utils } = maths;
    var { extrudeFromSlices, slice } = extrusions;
    var calculateYaxes = (spine) => {
      const slength = spine.length;
      const closed = vec3.equals(spine[0], spine[slength - 1]);
      const yaxes = [];
      for (let i = 0; i < slength; i++) {
        const yaxis = vec3.create();
        if (i === 0) {
          if (closed) {
            vec3.normalize(yaxis, vec3.subtract(yaxis, spine[1], spine[slength - 2]));
          } else {
            vec3.normalize(yaxis, vec3.subtract(yaxis, spine[1], spine[0]));
          }
        } else if (i === slength - 1) {
          if (closed) {
            vec3.normalize(yaxis, vec3.subtract(yaxis, spine[1], spine[slength - 2]));
          } else {
            vec3.normalize(yaxis, vec3.subtract(yaxis, spine[slength - 1], spine[slength - 2]));
          }
        } else {
          vec3.normalize(yaxis, vec3.subtract(yaxis, spine[i + 1], spine[i - 1]));
        }
        yaxes.push(yaxis);
      }
      return yaxes;
    };
    var isZeroVector = (vector) => {
      if (vector[0] + 0 === 0) {
        if (vector[1] + 0 === 0) {
          if (vector[2] + 0 === 0) {
            return true;
          }
        }
      }
      return false;
    };
    var calculateZaxis = (z, p, i, n) => {
      const a = vec3.subtract(vec3.create(), n, i);
      const b = vec3.subtract(vec3.create(), p, i);
      return vec3.normalize(z, vec3.cross(z, a, b));
    };
    var calculateZaxes = (spine) => {
      const slength = spine.length;
      const closed = vec3.equals(spine[0], spine[slength - 1]);
      const zaxes = [];
      let previousZaxis;
      for (let i = 0; i < slength; i++) {
        const zaxis = vec3.create();
        if (i === 0) {
          if (closed) {
            calculateZaxis(zaxis, spine[slength - 2], spine[0], spine[1]);
          } else {
            if (slength > 2)
              calculateZaxis(zaxis, spine[0], spine[1], spine[2]);
          }
        } else if (i === slength - 1) {
          if (closed) {
            calculateZaxis(zaxis, spine[slength - 2], spine[0], spine[1]);
          } else {
            if (slength > 2)
              calculateZaxis(zaxis, spine[slength - 3], spine[slength - 2], spine[slength - 1]);
          }
        } else {
          calculateZaxis(zaxis, spine[i - 1], spine[i], spine[i + 1]);
        }
        if (previousZaxis && vec3.dot(previousZaxis, zaxis) < 0)
          vec3.negate(zaxis, zaxis);
        zaxes.push(zaxis);
        previousZaxis = zaxis;
      }
      if (isZeroVector(zaxes[0])) {
        for (let i = 1; i < zaxes.length; i++) {
          if (!isZeroVector(zaxes[i])) {
            zaxes[0] = zaxes[i];
            break;
          }
        }
      }
      for (let i = 1; i < zaxes.length; i++) {
        if (isZeroVector(zaxes[i]) && !isZeroVector(zaxes[i - 1]))
          vec3.clone(zaxes[i], zaxes[i - 1]);
      }
      return zaxes;
    };
    var calculateXaxes = (yaxes, zaxes) => {
      const xaxes = [];
      for (let i = 0; i < yaxes.length; i++) {
        const xaxis = vec3.create();
        xaxes.push(vec3.normalize(xaxis, vec3.cross(xaxis, yaxes[i], zaxes[i])));
      }
      return xaxes;
    };
    var rotationMatrixFromSCP = (out, xaxis, yaxis, zaxis) => {
      out[0] = xaxis[0];
      out[1] = yaxis[0];
      out[2] = zaxis[0];
      out[3] = 0;
      out[4] = xaxis[1];
      out[5] = yaxis[1];
      out[6] = zaxis[1];
      out[7] = 0;
      out[8] = xaxis[2];
      out[9] = yaxis[2];
      out[10] = zaxis[2];
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    var extrudeX3D = (x3dshape) => {
      let { beginCap, endCap, crossSection, orientations, scales, spine } = Object.assign({}, x3dshape);
      if (utils.area(crossSection) < 0)
        crossSection.reverse();
      if (scales.length === 1) {
        scales = spine.map((s) => scales[0]);
      }
      if (orientations.length === 1) {
        orientations = spine.map((s) => orientations[0]);
      }
      if (spine.length !== scales.length || spine.length !== orientations.length) {
        throw new Error(`invalid X3D specification; spine scale orientaion length must be the same; ${spine.length}`);
      }
      const initialShape = geometries.geom2.fromPoints(crossSection);
      const initialSlice = slice.fromSides(geometries.geom2.toSides(initialShape));
      let yaxes = calculateYaxes(spine);
      let zaxes = calculateZaxes(spine);
      let xaxes = calculateXaxes(yaxes, zaxes);
      const y0direction = [0, 1, 0];
      const y0matrix = mat4.fromVectorRotation(mat4.create(), vec3.fromValues(0, 0, 1), y0direction);
      const allZero = zaxes.reduce((acc, axis) => acc && isZeroVector(axis), true);
      if (allZero) {
        vec3.subtract(y0direction, spine[1], spine[0]);
        mat4.fromVectorRotation(y0matrix, vec3.fromValues(0, 0, 1), y0direction);
        xaxes = xaxes.map((axis) => [1, 0, 0]);
        yaxes = yaxes.map((axis) => [0, 1, 0]);
        zaxes = zaxes.map((axis) => [0, 0, 1]);
      }
      return extrudeFromSlices({
        numberOfSlices: spine.length,
        capStart: beginCap,
        capEnd: endCap,
        callback: function(progress, count, base) {
          const position = spine[count];
          const scale = vec3.fromVec2(vec3.create(), scales[count], 1);
          const orientation = orientations[count];
          const xaxis = xaxes[count];
          const yaxis = yaxes[count];
          const zaxis = zaxes[count];
          const translationMatrix = mat4.fromTranslation(mat4.create(), position);
          const scaleMatrix = mat4.fromScaling(mat4.create(), scale);
          const scpMatrix = rotationMatrixFromSCP(mat4.create(), xaxis, yaxis, zaxis);
          const orientationMatrix = mat4.fromRotation(mat4.create(), orientation[3], orientation);
          const rotationMatrix = mat4.create();
          mat4.multiply(rotationMatrix, y0matrix, rotationMatrix);
          mat4.multiply(rotationMatrix, scpMatrix, rotationMatrix);
          mat4.multiply(rotationMatrix, orientationMatrix, rotationMatrix);
          mat4.multiply(rotationMatrix, translationMatrix, rotationMatrix);
          let newslice = base;
          newslice = slice.transform(scaleMatrix, newslice);
          newslice = slice.transform(rotationMatrix, newslice);
          return newslice;
        }
      }, initialSlice);
    };
    module.exports = extrudeX3D;
  }
});

// node_modules/@jscad/x3d-deserializer/src/translateHelpers.js
var require_translateHelpers = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translateHelpers.js"(exports, module) {
    var { x3dTypes } = require_objects();
    var findNode = (x3dtype, objects) => objects.find((object) => object.definition === x3dtype);
    var findColor = (objects, options) => {
      const appearance = findNode(x3dTypes.APPEARANCE, objects);
      let material;
      if (appearance) {
        material = findNode(x3dTypes.MATERIAL, appearance.objects);
        if (material) {
          return material.color ? material.color : null;
        }
      }
      material = findNode(x3dTypes.MATERIAL, objects);
      if (material) {
        return material.color ? material.color : null;
      }
      return null;
    };
    var pointToString = (point) => `[${point}]`;
    var pointsToString = (triangle) => {
      const strings = triangle.map((point) => pointToString(point));
      return `[
    ${strings.join(",\n    ")}
  ]`;
    };
    var createColorsFromVertexColors = (colorIndex, vertexColors) => {
      if (!(Array.isArray(colorIndex) && Array.isArray(vertexColors)))
        return null;
      if (colorIndex.length < 0 || !Array.isArray(colorIndex[0])) {
        console.log("ERROR: WRONG FORMAT FOR VERTEXCOLORS");
        return null;
      }
      const colors = [];
      for (let i = 0; i < colorIndex.length; i++) {
        const indexes = colorIndex[i];
        let r = 0;
        let g = 0;
        let b = 0;
        const a = 1;
        for (let j = 0; j < indexes.length; j++) {
          const vertexColor = vertexColors[indexes[j]];
          if (vertexColor) {
            r += vertexColor[0];
            g += vertexColor[1];
            b += vertexColor[2];
          }
        }
        const color = [r / indexes.length, g / indexes.length, b / indexes.length, a];
        colors.push(color);
      }
      return colors;
    };
    var createColorsFromFaceColors = (colorIndex, faceColors) => {
      if (!(Array.isArray(colorIndex) && Array.isArray(faceColors)))
        return null;
      const colors = colorIndex.map((index) => faceColors[index] ? faceColors[index] : null);
      return colors;
    };
    var createColors = (shape, color) => {
      if (!color)
        return null;
      if (!Array.isArray(shape.colorIndex))
        return null;
      let colors = null;
      if (shape.colorPerVertex === true) {
        colors = createColorsFromVertexColors(shape.colorIndex, color.colors);
      } else {
        colors = createColorsFromFaceColors(shape.colorIndex, color.colors);
      }
      return colors;
    };
    module.exports = {
      findNode,
      findColor,
      createColors,
      pointToString,
      pointsToString
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/instantiateLine.js
var require_instantiateLine = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/instantiateLine.js"(exports, module) {
    var jscad = require_src();
    var { createColors, findNode } = require_translateHelpers();
    var { x3dTypes } = require_objects();
    var convertLine = (options, objects) => {
      let shape = findNode(x3dTypes.INDEXEDLINESET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const indexes = shape.indexes;
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate && indexes) {
          const pointsSet = indexes.map((index) => {
            let points = index.map((i) => coordinate.points[i]);
            const is3D = points.findIndex((p) => p[2] !== 0);
            if (is3D >= 0) {
              console.warn("WARNING: unsupported 3D indexed line set was ignored");
              points = [];
            }
            return points;
          });
          if (shape.colorPerVertex === true) {
            shape.colorIndex = indexes;
          } else {
            shape.colorIndex = indexes.map((index, i) => i);
          }
          const colors = createColors(shape, color);
          return { pointsSet, colors };
        }
      }
      shape = findNode(x3dTypes.LINESET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        const counts = shape.vertexCount;
        if (coordinate && counts) {
          let vi = 0;
          const pointsSet = counts.map((count) => {
            let points = [];
            for (let i = 0; i < count; i++) {
              points.push(coordinate.points[vi]);
              vi++;
            }
            const is3D = points.findIndex((p) => p[2] !== 0);
            if (is3D >= 0) {
              console.warn("WARNING: unsupported 3D line set was ignored");
              points = [];
            }
            return points;
          });
          if (shape.colorPerVertex === true) {
            let ci = 0;
            shape.colorIndex = counts.map((count) => {
              const index = [];
              for (let i = 0; i < count; i++) {
                index.push(ci);
                ci++;
              }
              return index;
            });
          } else {
            shape.colorIndex = pointsSet.map((ps, i) => i);
          }
          const colors = createColors(shape, color);
          return { pointsSet, colors };
        }
      }
      return null;
    };
    var instantiateLine = (options, objects) => {
      let geometry;
      const components = convertLine(options, objects);
      if (components) {
        const { pointsSet, colors } = components;
        geometry = pointsSet.map((points, i) => {
          let line;
          if (colors) {
            line = jscad.colors.colorize(colors[i], jscad.primitives.line(points));
          } else {
            line = jscad.primitives.line(points);
          }
          return line;
        });
      }
      return geometry;
    };
    module.exports = {
      convertLine,
      instantiateLine
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/translateLine.js
var require_translateLine = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translateLine.js"(exports, module) {
    var { pointsToString } = require_translateHelpers();
    var { convertLine } = require_instantiateLine();
    var translateLine = (options, objects) => {
      const components = convertLine(options, objects);
      if (components) {
        const { pointsSet, colors } = components;
        let code = "  let lines = []\n";
        pointsSet.forEach((points, i) => {
          if (colors) {
            const lineColor = colors[i];
            code += `  const line${i} = colorize([${lineColor}], primitives.line(${pointsToString(points)}))
  lines.push(line${i})
`;
          } else {
            code += `  const line${i} = primitives.line(${pointsToString(points)})
  lines.push(line${i})
`;
          }
        });
        const primitive = "...lines";
        return { primitive, code };
      }
      return null;
    };
    module.exports = translateLine;
  }
});

// node_modules/@jscad/x3d-deserializer/src/instantiateMesh.js
var require_instantiateMesh = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/instantiateMesh.js"(exports, module) {
    var { primitives } = require_src();
    var { x3dTypes } = require_objects();
    var { findNode, createColors } = require_translateHelpers();
    var convertMesh = (options, objects) => {
      let shape = findNode(x3dTypes.TRIANGLESET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate) {
          const points = coordinate.points;
          const numpoints = points.length;
          const numfaces = Math.trunc(numpoints / 3);
          const faces = [];
          for (let ti = 0; ti < numfaces; ti++) {
            const pi = ti * 3;
            faces.push([pi, pi + 1, pi + 2]);
          }
          const orientation = shape.ccw ? "outward" : "inward";
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const type = "triangles";
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.TRIANGLEFANSET, objects);
      if (shape) {
        const fanCount = shape.fanCount;
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate) {
          const points = coordinate.points;
          const numfans = fanCount.length;
          const faces = [];
          let fo = 0;
          for (let fi = 0; fi < numfans; fi++) {
            const numvertices = Math.trunc(fanCount[fi]);
            for (let vi = 1; vi < numvertices - 1; vi++) {
              faces.push([fo, fo + vi, fo + vi + 1]);
            }
            fo += numvertices;
          }
          const orientation = shape.ccw ? "outward" : "inward";
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const type = `triangle fans (${numfans})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.TRIANGLESTRIPSET, objects);
      if (shape) {
        const stripCount = shape.stripCount;
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate) {
          const points = coordinate.points;
          const numstrips = stripCount.length;
          const faces = [];
          let so = 0;
          for (let si = 0; si < numstrips; si++) {
            const numvertices = Math.trunc(stripCount[si]);
            for (let vi = 0; vi < numvertices - 2; vi++) {
              const face = [so + vi, so + vi + 1, so + vi + 2];
              if (vi % 2 === 1)
                face.reverse();
              faces.push(face);
            }
            so += numvertices;
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `triangle strip (${numstrips})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.QUADSET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate) {
          const points = coordinate.points;
          const numpoints = points.length;
          const numquads = Math.trunc(numpoints / 4);
          const faces = [];
          for (let qi = 0; qi < numquads; qi++) {
            const pi = qi * 4;
            faces.push([pi, pi + 1, pi + 2, pi + 3]);
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `quad (${numquads})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.INDEXEDTRIANGLESET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        const index = shape.index;
        if (coordinate && index && index.length > 2) {
          const points = coordinate.points;
          const numfaces = Math.trunc(index.length / 3);
          const faces = [];
          for (let fi = 0; fi < numfaces; fi++) {
            const pi = fi * 3;
            faces.push([index[pi], index[pi + 1], index[pi + 2]]);
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = "indexed triangle";
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.INDEXEDTRIANGLEFANSET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        const fans = shape.fans;
        if (coordinate && fans && fans.length > 0) {
          const points = coordinate.points;
          const numfans = fans.length;
          const faces = [];
          for (let fi = 0; fi < numfans; fi++) {
            const fan = fans[fi];
            const numvertices = fan.length;
            for (let vi = 1; vi < numvertices - 1; vi++) {
              faces.push([fan[0], fan[vi], fan[vi + 1]]);
            }
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `indexed triangle fan (${numfans})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.INDEXEDTRIANGLESTRIPSET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        const strips = shape.strips;
        if (coordinate && strips && strips.length > 0) {
          const points = coordinate.points;
          const numstrips = strips.length;
          const faces = [];
          for (let si = 0; si < numstrips; si++) {
            const strip = strips[si];
            const numvertices = strip.length;
            for (let vi = 0; vi < numvertices - 2; vi++) {
              const face = [strip[vi], strip[vi + 1], strip[vi + 2]];
              if (vi % 2 === 1)
                face.reverse();
              faces.push(face);
            }
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `indexed triangle strip (${numstrips})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.INDEXEDQUADSET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const color = findNode(x3dTypes.COLOR, shape.objects);
        const index = shape.index;
        if (coordinate && index && index.length > 3) {
          const points = coordinate.points;
          const numquads = Math.trunc(index.length / 4);
          const faces = [];
          for (let qi = 0; qi < numquads; qi++) {
            const ii = qi * 4;
            faces.push([index[ii], index[ii + 1], index[ii + 2], index[ii + 3]]);
          }
          shape.colorIndex = faces;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `indexed quad (${numquads})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.INDEXEDFACESET, objects);
      if (shape) {
        const coordinate = findNode(x3dTypes.COORDINATE, shape.objects);
        const faces = shape.faces;
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (coordinate && faces && faces.length > 0) {
          const points = coordinate.points;
          const numfaces = faces.length;
          const colors = createColors(shape, color);
          const orientation = shape.ccw ? "outward" : "inward";
          const type = `indexed faces (${numfaces})`;
          return { type, points, faces, colors, orientation };
        }
      }
      shape = findNode(x3dTypes.ELEVATIONGRID, objects);
      if (shape) {
        const height = shape.height;
        const color = findNode(x3dTypes.COLOR, shape.objects);
        if (height && height.length > 0) {
          const xDimension = shape.xDimension;
          const xSpacing = shape.xSpacing;
          const zDimension = shape.zDimension;
          const zSpacing = shape.zSpacing;
          const points = [];
          let vi = 0;
          for (let z0 = 0; z0 < zDimension; ++z0) {
            for (let x0 = 0; x0 < xDimension; ++x0) {
              const x = x0 * xSpacing;
              const z = z0 * zSpacing;
              const y = height[vi];
              vi++;
              points.push([x, y, z]);
            }
          }
          const faces = [];
          for (let z0 = 0; z0 < zDimension - 1; ++z0) {
            for (let x0 = 0; x0 < xDimension - 1; ++x0) {
              const iTL = x0 + z0 * xDimension;
              const iTR = x0 + 1 + z0 * xDimension;
              const iBL = x0 + (z0 + 1) * xDimension;
              const iBR = x0 + 1 + (z0 + 1) * xDimension;
              const distances = [Math.abs(height[iTL]), Math.abs(height[iTR]), Math.abs(height[iBL]), Math.abs(height[iBR])];
              let apexi = 0;
              if (distances[1] >= distances[0] && distances[1] >= distances[2] && distances[1] >= distances[3])
                apexi = 1;
              if (distances[2] >= distances[0] && distances[2] >= distances[1] && distances[2] >= distances[3])
                apexi = 2;
              if (distances[3] >= distances[0] && distances[3] >= distances[1] && distances[3] >= distances[2])
                apexi = 3;
              if (apexi === 0)
                faces.push([iTL, iBR, iTR], [iTL, iBL, iBR]);
              if (apexi === 1)
                faces.push([iTR, iBL, iBR], [iTR, iTL, iBL]);
              if (apexi === 2)
                faces.push([iBL, iTR, iTL], [iBL, iBR, iTR]);
              if (apexi === 3)
                faces.push([iBR, iTL, iBL], [iBR, iTR, iTL]);
            }
          }
          const orientation = shape.ccw ? "outward" : "inward";
          if (shape.colorPerVertex === true) {
            shape.colorIndex = faces;
          } else {
          }
          const colors = createColors(shape, color);
          const type = `elevation grid (${xDimension} X ${zDimension})`;
          return { type, points, faces, colors, orientation };
        }
      }
      return null;
    };
    var instantiateMesh = (options, objects) => {
      let geometry;
      const components = convertMesh(options, objects);
      if (components) {
        geometry = primitives.polyhedron(components);
      }
      return geometry;
    };
    module.exports = {
      convertMesh,
      instantiateMesh
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/translateMesh.js
var require_translateMesh = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translateMesh.js"(exports, module) {
    var { pointsToString } = require_translateHelpers();
    var { convertMesh } = require_instantiateMesh();
    var translateToPolyhedron = (type, points, faces, colors, orientation) => {
      const colorsCode = Array.isArray(colors) ? pointsToString(colors) : "null";
      const primitive = "primitives.polyhedron({points, faces, colors, orientation})";
      const code = `
  // 3D ${type} set: ${points.length} points, ${faces.length} faces
  const points = ${pointsToString(points)}
  const faces = ${pointsToString(faces)}
  const colors = ${colorsCode}
  const orientation = '${orientation}'
`;
      return { primitive, code };
    };
    var translateMesh = (options, objects) => {
      const components = convertMesh(options, objects);
      if (components) {
        const { type, points, faces, colors, orientation } = components;
        return translateToPolyhedron(type, points, faces, colors, orientation);
      }
      return null;
    };
    module.exports = translateMesh;
  }
});

// node_modules/@jscad/x3d-deserializer/src/translateShape.js
var require_translateShape = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translateShape.js"(exports, module) {
    var { geometries } = require_src();
    var { geom3, poly3 } = geometries;
    var extrudeX3D = require_extrudeX3D();
    var { x3dTypes } = require_objects();
    var { findNode, findColor, pointsToString } = require_translateHelpers();
    var translateLine = require_translateLine();
    var translateMesh = require_translateMesh();
    var translateShape = (options, object) => {
      let code = `
// shape
const createObjects${object.id} = (options) => {
  let objects = []
`;
      const objects = object.objects;
      const color = findColor(objects, options);
      let primitive;
      let shape = findNode(x3dTypes.BOX, objects);
      if (shape) {
        primitive = `primitives.cuboid({size: [${shape.size}]})`;
      } else {
        shape = findNode(x3dTypes.CONE, objects);
        if (shape) {
          code += `  const shape = transforms.rotateX(-Math.PI/2, primitives.cylinderElliptic({startRadius: [${shape.bottomRadius},${shape.bottomRadius}], height: ${shape.height}, segments: ${shape.subdivision}, endRadius: [${shape.topRadius}, ${shape.topRadius}]}))
`;
          primitive = "shape";
        } else {
          shape = findNode(x3dTypes.CYLINDER, objects);
          if (shape) {
            code += `  const shape = transforms.rotateX(-Math.PI/2, primitives.cylinder({radius: ${shape.radius}, height: ${shape.height}, segments: ${shape.subdivision}}))
`;
            primitive = "shape";
          } else {
            shape = findNode(x3dTypes.SPHERE, objects);
            if (shape) {
              primitive = `primitives.sphere({radius: ${shape.radius}, segments: ${shape.subdivision}})`;
            } else {
              shape = findNode(x3dTypes.EXTRUSION, objects);
              if (shape) {
                const geometry = extrudeX3D(shape);
                const polygons = geom3.toPolygons(geometry);
                const polysAsStrings = polygons.map((polygon) => pointsToString(poly3.toPoints(polygon)));
                code += `  const polygons = [
  ${polysAsStrings.join(",\n  ")}
]
`;
                primitive = "geometries.geom3.fromPoints(polygons)";
              }
            }
          }
        }
      }
      if (!primitive) {
        shape = findNode(x3dTypes.ARC2D, objects);
        if (shape) {
          primitive = `primitives.arc({radius: ${shape.radius}, startAngle: ${shape.startAngle}, endAngle: ${shape.endAngle}, segments: ${shape.subdivision}})`;
        } else {
          shape = findNode(x3dTypes.ARCCLOSE2D, objects);
          if (shape) {
            if (shape.closureType === "PIE") {
              primitive = `primitives.circle({radius: ${shape.radius}, startAngle: ${shape.startAngle}, endAngle: ${shape.endAngle}, segments: ${shape.subdivision}})`;
            } else {
              primitive = `geometries.geom2.fromPoints(geometries.path2.toPoints(geometries.path2.close(primitives.arc({radius: ${shape.radius}, startAngle: ${shape.startAngle}, endAngle: ${shape.endAngle}, segments: ${shape.subdivision}}))))`;
            }
          } else {
            shape = findNode(x3dTypes.CIRCLE2D, objects);
            if (shape) {
              primitive = `primitives.arc({radius: ${shape.radius}, segments: ${shape.subdivision}})`;
            } else {
              shape = findNode(x3dTypes.DISK2D, objects);
              if (shape) {
                if (shape.innerRadius === shape.outerRadius) {
                  primitive = `primitives.arc({radius: ${shape.outerRadius}, segments: ${shape.subdivision}})`;
                } else {
                  if (shape.innerRadius === 0) {
                    primitive = `primitives.circle({radius: ${shape.outerRadius}, segments: ${shape.subdivision}})`;
                  } else {
                    primitive = `booleans.subtract(primitives.circle({radius: ${shape.outerRadius}, segments: ${shape.subdivision}}), primitives.circle({radius: ${shape.innerRadius}, segments: ${shape.subdivision}}))`;
                  }
                }
              } else {
                shape = findNode(x3dTypes.POLYLINE2D, objects);
                if (shape) {
                  const lineSegments = shape.lineSegments.join("], [");
                  primitive = `primitives.line([[${lineSegments}]])`;
                } else {
                  shape = findNode(x3dTypes.RECTANGLE2D, objects);
                  if (shape) {
                    primitive = `primitives.rectangle({size: [${shape.size}]})`;
                  } else {
                    shape = findNode(x3dTypes.TRIANGLESET2D, objects);
                    if (shape) {
                      const numpoints = shape.vertices.length;
                      const numfaces = Math.trunc(numpoints / 3);
                      code += `
  // 2D triangle set: ${numpoints} points, ${numfaces} faces
  const vertices = ${pointsToString(shape.vertices)}
  const triangles = []
  for (let i = 0; i < ${numfaces}; i = i + 3) {
    triangles.push(geometries.geom2.fromPoints([vertices[i], vertices[i + 1], vertices[i + 2]]))
  }
`;
                      primitive = "triangles";
                    }
                  }
                }
              }
            }
          }
        }
      }
      let results = translateMesh(options, objects);
      if (results) {
        primitive = results.primitive;
        code += results.code;
      }
      results = translateLine(options, objects);
      if (results) {
        primitive = results.primitive;
        code += results.code;
      }
      if (primitive) {
        if (color) {
          code += `  objects.push(colorize([${color}], ${primitive}))`;
        } else {
          code += `  objects.push(${primitive})`;
        }
      }
      code += `
  return objects
}
`;
      return code;
    };
    module.exports = translateShape;
  }
});

// node_modules/@jscad/x3d-deserializer/src/translateDefinitions.js
var require_translateDefinitions = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translateDefinitions.js"(exports, module) {
    var createTransform = require_createTransform();
    var { x3dTypes } = require_objects();
    var translateShape = require_translateShape();
    var translateTransform = (options, object) => {
      let code = `
// transform
const createObjects${object.id} = (options) => {
  let objects = []
`;
      const objects = object.objects;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        code += `  objects.push(...createObjects${obj.id}(options))
`;
      }
      const matrix = createTransform(object.center, object.rotation, object.scale, object.scaleOrientation, object.translation);
      code += `
  const matrix = [${matrix}]
  return applyTransform(matrix, objects)
}
`;
      code += translateDefinitions(options, objects);
      return code;
    };
    var translateGroup = (options, object) => {
      let code = `
// group
const createObjects${object.id} = (options) => {
  let objects = []
`;
      const objects = object.objects;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        code += `  objects.push(...createObjects${obj.id}(options))
`;
      }
      code += `
  return objects
}
`;
      code += translateDefinitions(options, objects);
      return code;
    };
    var translatedList = [];
    var translateDefinition = (options, object) => {
      if (translatedList.includes(object.id))
        return "";
      translatedList.push(object.id);
      let code = "";
      switch (object.definition) {
        case x3dTypes.TRANSFORM:
          code += translateTransform(options, object);
          break;
        case x3dTypes.SHAPE:
          code += translateShape(options, object);
          break;
        case x3dTypes.GROUP:
          code += translateGroup(options, object);
          break;
        default:
          console.log("WARNING: unknown definition: " + object.definition);
          break;
      }
      return code;
    };
    var translateDefinitions = (options, objects) => objects.reduce((code, object, index) => code += translateDefinition(options, object), "");
    module.exports = translateDefinitions;
  }
});

// node_modules/@jscad/x3d-deserializer/src/parse.js
var require_parse2 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/parse.js"(exports, module) {
    var saxes = require_saxes();
    var {
      x3dTypes,
      x3dX3D,
      x3dUnit,
      x3dMeta,
      x3dScene,
      x3dTransform,
      x3dShape,
      x3dGroup,
      x3dBox,
      x3dCone,
      x3dCylinder,
      x3dSphere,
      x3dExtrusion,
      x3dArc2D,
      x3dArcClose2D,
      x3dCircle2D,
      x3dDisk2D,
      x3dPolyline2D,
      x3dRectangle2D,
      x3dTriangleSet2D,
      x3dColor,
      x3dCoordinate,
      x3dTriangleSet,
      x3dTriangleFanSet,
      x3dTriangleStripSet,
      x3dQuadSet,
      x3dIndexedTriangleSet,
      x3dIndexedTriangleFanSet,
      x3dIndexedTriangleStripSet,
      x3dIndexedQuadSet,
      x3dIndexedFaceSet,
      x3dElevationGrid,
      x3dLineSet,
      x3dIndexedLineSet,
      x3dAppearance,
      x3dMaterial
    } = require_objects();
    var x3dLast = null;
    var x3dDefinition = x3dTypes.X3D;
    var x3dObjects = [];
    var x3dDefs = /* @__PURE__ */ new Map();
    var x3dMaterials = [];
    var x3dTextures = [];
    var x3dLength = { factor: 1, name: "meters" };
    var x3dAngle = { factor: 1, name: "radians" };
    var x3dObj = null;
    var nodeToObjectMap = {
      X3D: x3dX3D,
      UNIT: x3dUnit,
      META: x3dMeta,
      SCENE: x3dScene,
      TRANSFORM: x3dTransform,
      SHAPE: x3dShape,
      GROUP: x3dGroup,
      STATICGROUP: x3dGroup,
      BOX: x3dBox,
      CONE: x3dCone,
      CYLINDER: x3dCylinder,
      SPHERE: x3dSphere,
      EXTRUSION: x3dExtrusion,
      ARC2D: x3dArc2D,
      ARCCLOSE2D: x3dArcClose2D,
      CIRCLE2D: x3dCircle2D,
      DISK2D: x3dDisk2D,
      POLYLINE2D: x3dPolyline2D,
      RECTANGLE2D: x3dRectangle2D,
      TRIANGLESET2D: x3dTriangleSet2D,
      COLOR: x3dColor,
      COORDINATE: x3dCoordinate,
      TRIANGLESET: x3dTriangleSet,
      TRIANGLEFANSET: x3dTriangleFanSet,
      TRIANGLESTRIPSET: x3dTriangleStripSet,
      QUADSET: x3dQuadSet,
      INDEXEDTRIANGLESET: x3dIndexedTriangleSet,
      INDEXEDTRIANGLEFANSET: x3dIndexedTriangleFanSet,
      INDEXEDTRIANGLESTRIPSET: x3dIndexedTriangleStripSet,
      INDEXEDQUADSET: x3dIndexedQuadSet,
      INDEXEDFACESET: x3dIndexedFaceSet,
      ELEVATIONGRID: x3dElevationGrid,
      LINESET: x3dLineSet,
      INDEXEDLINESET: x3dIndexedLineSet,
      APPEARANCE: x3dAppearance,
      MATERIAL: x3dMaterial
    };
    var objectId = 1;
    var getObjectId = () => ("0000" + objectId++).slice(-4);
    var createX3DParser = (src, pxPmm) => {
      const parser = new saxes.SaxesParser();
      parser.on("error", (e) => {
        console.log(`error: line ${e.line}, column ${e.column}, bad character [${e.c}]`);
      });
      parser.on("opentag", (node) => {
        const elementname = node.name.toUpperCase();
        let obj = nodeToObjectMap[elementname] ? nodeToObjectMap[elementname](node.attributes, { x3dObjects }) : null;
        if (obj) {
          obj.id = getObjectId();
          if (node.attributes.USE) {
            const objectname = node.attributes.USE;
            if (x3dDefs.has(objectname)) {
              const def = x3dDefs.get(objectname);
              if (def.definition !== obj.definition) {
                console.log(`WARNING: using a definition "${objectname}" of a different type; ${obj.definition} vs ${def.definition}`);
              }
              obj = def;
            } else {
              console.log(`WARNING: definition "${objectname}" does not exist, using default for ${obj.definition}`);
            }
          } else {
            if (node.attributes.DEF) {
              const objectname = node.attributes.DEF;
              if (x3dDefs.has(objectname)) {
                console.log(`WARNING: redefintion of ${objectname} has been ignored`);
              } else {
                x3dDefs.set(objectname, obj);
              }
            }
          }
          switch (obj.definition) {
            case x3dTypes.SCENE:
            case x3dTypes.TRANSFORM:
            case x3dTypes.SHAPE:
            case x3dTypes.APPEARANCE:
            case x3dTypes.TRIANGLESET:
            case x3dTypes.TRIANGLEFANSET:
            case x3dTypes.TRIANGLESTRIPSET:
            case x3dTypes.QUADSET:
            case x3dTypes.INDEXEDTRIANGLESET:
            case x3dTypes.INDEXEDTRIANGLEFANSET:
            case x3dTypes.INDEXEDTRIANGLESTRIPSET:
            case x3dTypes.INDEXEDQUADSET:
            case x3dTypes.INDEXEDFACESET:
            case x3dTypes.ELEVATIONGRID:
            case x3dTypes.LINESET:
            case x3dTypes.INDEXEDLINESET:
            case x3dTypes.GROUP:
              x3dDefinition = obj.definition;
              break;
            default:
              break;
          }
          switch (x3dDefinition) {
            case x3dTypes.X3D:
              if ("objects" in obj) {
                x3dObjects.push(obj);
              }
              if (obj.definition === x3dTypes.UNIT) {
                if (obj.category === "length") {
                  x3dLength.factor = obj.conversionFactor;
                  x3dLength.name = obj.name;
                }
                if (obj.category === "angle") {
                  x3dAngle.factor = obj.conversionFactor;
                  x3dAngle.name = obj.name;
                }
              }
              break;
            case x3dTypes.SCENE:
            case x3dTypes.TRANSFORM:
            case x3dTypes.SHAPE:
            case x3dTypes.GROUP:
            case x3dTypes.APPEARANCE:
            case x3dTypes.TRIANGLESET:
            case x3dTypes.TRIANGLEFANSET:
            case x3dTypes.TRIANGLESTRIPSET:
            case x3dTypes.QUADSET:
            case x3dTypes.INDEXEDTRIANGLESET:
            case x3dTypes.INDEXEDTRIANGLEFANSET:
            case x3dTypes.INDEXEDTRIANGLESTRIPSET:
            case x3dTypes.INDEXEDQUADSET:
            case x3dTypes.INDEXEDFACESET:
            case x3dTypes.ELEVATIONGRID:
            case x3dTypes.LINESET:
            case x3dTypes.INDEXEDLINESET:
              if (x3dObjects.length > 0) {
                const group = x3dObjects.pop();
                if ("objects" in group) {
                  group.objects.push(obj);
                }
                x3dObjects.push(group);
                if ("objects" in obj) {
                  x3dObjects.push(obj);
                }
              }
              break;
            default:
              console.log("WARNING: invalid X3D definition");
              break;
          }
          x3dLast = obj;
        }
      });
      parser.on("closetag", (node) => {
        const elementname = node.name.toUpperCase();
        switch (elementname) {
          case "X3D":
          case "SCENE":
          case "TRANSFORM":
          case "SHAPE":
          case "GROUP":
          case "STATICGROUP":
          case "APPEARANCE":
          case "TRIANGLESET":
          case "TRIANGLEFANSET":
          case "TRIANGLESTRIPSET":
          case "QUADSET":
          case "INDEXEDTRIANGLESET":
          case "INDEXEDTRIANGLEFANSET":
          case "INDEXEDTRIANGLESTRIPSET":
          case "INDEXEDQUADSET":
          case "INDEXEDFACESET":
          case "ELEVATIONGRID":
          case "LINESET":
          case "INDEXEDLINESET":
            break;
          default:
            return;
        }
        const popDefinition = () => {
          if (x3dObjects.length > 0) {
            x3dDefinition = x3dObjects[x3dObjects.length - 1].definition;
          }
        };
        let obj = null;
        switch (x3dDefinition) {
          case x3dTypes.X3D:
            if (x3dObjects.length > 0) {
              obj = x3dObjects.pop();
              popDefinition();
            }
            if (x3dObjects.length === 0) {
              obj.length = x3dLength;
              obj.angle = x3dAngle;
              x3dObj = obj;
            }
            break;
          case x3dTypes.SCENE:
          case x3dTypes.TRANSFORM:
          case x3dTypes.SHAPE:
          case x3dTypes.GROUP:
          case x3dTypes.APPEARANCE:
          case x3dTypes.TRIANGLESET:
          case x3dTypes.TRIANGLEFANSET:
          case x3dTypes.TRIANGLESTRIPSET:
          case x3dTypes.QUADSET:
          case x3dTypes.INDEXEDTRIANGLESET:
          case x3dTypes.INDEXEDTRIANGLEFANSET:
          case x3dTypes.INDEXEDTRIANGLESTRIPSET:
          case x3dTypes.INDEXEDQUADSET:
          case x3dTypes.INDEXEDFACESET:
          case x3dTypes.ELEVATIONGRID:
          case x3dTypes.LINESET:
          case x3dTypes.INDEXEDLINESET:
            if (x3dObjects.length > 0) {
              obj = x3dObjects.pop();
              popDefinition();
            }
            break;
          default:
            console.log("WARNING: unhandled definition", x3dDefinition);
            break;
        }
      });
      parser.on("text", (value) => {
        if (value !== null) {
          value = value.trim();
          if (value.length > 0 && x3dLast && x3dDefinition !== 0) {
            x3dLast.value = value;
          }
        }
      });
      parser.on("end", () => {
      });
      parser.write(src).close();
    };
    var parse = (src, pxPmm) => {
      createX3DParser(src, pxPmm);
      return { x3dObj, x3dMaterials, x3dTextures };
    };
    module.exports = parse;
  }
});

// node_modules/@jscad/x3d-deserializer/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/constants.js"(exports, module) {
    var inchMM = 1 / 0.03937;
    module.exports = {
      inchMM
    };
  }
});

// node_modules/@jscad/x3d-deserializer/src/translate.js
var require_translate3 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/translate.js"(exports, module) {
    var translateDefinitions = require_translateDefinitions();
    var { x3dTypes } = require_objects();
    var parse = require_parse2();
    var translate = (options, src) => {
      const defaults = {
        pxPmm: require_constants3().pxPmm
      };
      options = Object.assign({}, defaults, options);
      const { version, pxPmm, addMetaData, filename } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      const { x3dObj, x3dMaterials, x3dTextures } = parse(src, pxPmm);
      let code = addMetaData ? `//
// Produced by JSCAD IO Library : X3D Deserializer (${version})
// date: ${/* @__PURE__ */ new Date()}
// source: ${filename}
//
` : "";
      if (!x3dObj) {
        throw new Error("X3D parsing failed, no valid X3D data retrieved");
      }
      options && options.statusCallback && options.statusCallback({ progress: 50 });
      code += codify(x3dObj, { x3dMaterials, x3dTextures });
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return code;
    };
    var codify = (x3d, data) => {
      if (x3d.definition !== x3dTypes.X3D || !x3d.objects)
        throw new Error("X3D malformed");
      if (x3d.objects.length < 1 || x3d.objects[0].definition !== x3dTypes.SCENE)
        throw new Error("X3D did not define a SCENE");
      const scene = x3d.objects[0];
      const objects = scene.objects;
      const length = x3d.length;
      const angle = x3d.angle;
      let code = "";
      code = `// Objects  : ${objects.length}
// Units : ${length.name} (${length.factor})
// Angles : ${angle.name} (${angle.factor})

const {booleans, extrusions, geometries, maths, primitives, transforms, utils} = require('@jscad/modeling')
const { colorize } =  require('@jscad/modeling').colors

const applyTransform = (matrix, ...objects) => {
  objects = utils.flatten(objects)
  if (objects.length === 0) return objects

  return objects.map((object) => {
    const color = object.color
    object = transforms.transform(matrix, object)
    if (color) object.color = color
    return object
  })
}

const main = () => {
  let options = {}
  let objects = []
`;
      for (let i = 0; i < objects.length; i++) {
        const obj = objects[i];
        code += `  objects.push(...createObjects${obj.id}(options))
`;
      }
      code += "  return objects\n}\n";
      code += translateDefinitions({}, objects);
      code += "module.exports = {main}\n";
      return code;
    };
    module.exports = translate;
  }
});

// node_modules/@jscad/x3d-deserializer/src/instantiatePrimitive.js
var require_instantiatePrimitive = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/instantiatePrimitive.js"(exports, module) {
    var { booleans, geometries, primitives, transforms } = require_src();
    var { x3dTypes } = require_objects();
    var { findNode } = require_translateHelpers();
    var extrudeX3D = require_extrudeX3D();
    var instantiatePrimitive = (options, objects) => {
      let geometry;
      let object = findNode(x3dTypes.BOX, objects);
      if (object) {
        geometry = primitives.cuboid({ size: object.size });
        return geometry;
      }
      object = findNode(x3dTypes.CONE, objects);
      if (object) {
        geometry = transforms.rotateX(-Math.PI / 2, primitives.cylinderElliptic({
          startRadius: [object.bottomRadius, object.bottomRadius],
          height: object.height,
          segments: object.subdivision,
          endRadius: [object.topRadius, object.topRadius]
        }));
        return geometry;
      }
      object = findNode(x3dTypes.CYLINDER, objects);
      if (object) {
        geometry = transforms.rotateX(-Math.PI / 2, primitives.cylinder({
          radius: object.radius,
          height: object.height,
          segments: object.subdivision
        }));
        return geometry;
      }
      object = findNode(x3dTypes.SPHERE, objects);
      if (object) {
        geometry = primitives.sphere({ radius: object.radius, segments: object.subdivision });
        return geometry;
      }
      object = findNode(x3dTypes.EXTRUSION, objects);
      if (object) {
        geometry = extrudeX3D(object);
        return geometry;
      }
      object = findNode(x3dTypes.ARC2D, objects);
      if (object) {
        geometry = primitives.arc({ radius: object.radius, startAngle: object.startAngle, endAngle: object.endAngle, segments: object.subdivision });
        return geometry;
      }
      object = findNode(x3dTypes.ARCCLOSE2D, objects);
      if (object) {
        if (object.closureType === "PIE") {
          geometry = primitives.circle({ radius: object.radius, startAngle: object.startAngle, endAngle: object.endAngle, segments: object.subdivision });
        } else {
          geometry = geometries.geom2.fromPoints(geometries.path2.toPoints(geometries.path2.close(
            primitives.arc({ radius: object.radius, startAngle: object.startAngle, endAngle: object.endAngle, segments: object.subdivision })
          )));
        }
        return geometry;
      }
      object = findNode(x3dTypes.CIRCLE2D, objects);
      if (object) {
        geometry = primitives.arc({ radius: object.radius, segments: object.subdivision });
        return geometry;
      }
      object = findNode(x3dTypes.DISK2D, objects);
      if (object) {
        if (object.innerRadius === object.outerRadius) {
          geometry = primitives.arc({ radius: object.outerRadius, segments: object.subdivision });
        } else {
          if (object.innerRadius === 0) {
            geometry = primitives.circle({ radius: object.outerRadius, segments: object.subdivision });
          } else {
            geometry = booleans.subtract(primitives.circle({ radius: object.outerRadius, segments: object.subdivision }), primitives.circle({ radius: object.innerRadius, segments: object.subdivision }));
          }
        }
        return geometry;
      }
      object = findNode(x3dTypes.POLYLINE2D, objects);
      if (object) {
        geometry = primitives.line([object.lineSegments]);
        return geometry;
      }
      object = findNode(x3dTypes.RECTANGLE2D, objects);
      if (object) {
        geometry = primitives.rectangle({ size: object.size });
        return geometry;
      }
      object = findNode(x3dTypes.TRIANGLESET2D, objects);
      if (object) {
        const vertices = object.vertices;
        const numpoints = vertices.length;
        const numfaces = Math.trunc(numpoints / 3);
        geometry = [];
        for (let i = 0; i < numfaces; i = i + 3) {
          geometry.push(geometries.geom2.fromPoints([vertices[i], vertices[i + 1], vertices[i + 2]]));
        }
        return geometry;
      }
      return geometry;
    };
    module.exports = instantiatePrimitive;
  }
});

// node_modules/@jscad/x3d-deserializer/src/instantiateDefinitions.js
var require_instantiateDefinitions = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/instantiateDefinitions.js"(exports, module) {
    var { colors, transforms } = require_src();
    var createTransform = require_createTransform();
    var { x3dTypes } = require_objects();
    var { findColor } = require_translateHelpers();
    var instantiatePrimitive = require_instantiatePrimitive();
    var { instantiateLine } = require_instantiateLine();
    var { instantiateMesh } = require_instantiateMesh();
    var instantiatedList = /* @__PURE__ */ new Map();
    var instantiateTransform = (options, object) => {
      const geometries = object.objects.map((object2) => instantiateDefinition(options, object2)).filter((g) => g != null);
      if (geometries.length === 0)
        return null;
      const matrix = createTransform(object.center, object.rotation, object.scale, object.scaleOrientation, object.translation);
      return geometries.map((geometry) => {
        const color = geometry.color;
        geometry = transforms.transform(matrix, geometry);
        if (color)
          geometry.color = color;
        return geometry;
      });
    };
    var instantiateShape = (options, object) => {
      const objects = object.objects;
      const color = findColor(objects, options);
      let geometry = instantiatePrimitive(options, objects);
      if (!geometry)
        geometry = instantiateMesh(options, objects);
      if (!geometry)
        geometry = instantiateLine(options, objects);
      if (!geometry)
        geometry = null;
      if (geometry && color) {
        geometry = colors.colorize(color, geometry);
      }
      return geometry;
    };
    var instantiateGroup = (options, object) => {
      const geometries = object.objects.map((object2) => instantiateDefinition(options, object2)).filter((g) => g != null);
      if (geometries.length === 0)
        return null;
      return geometries;
    };
    var instantiateDefinition = (options, object) => {
      let geometry;
      switch (object.definition) {
        case x3dTypes.TRANSFORM:
          geometry = instantiateTransform(options, object);
          break;
        case x3dTypes.SHAPE:
          geometry = instantiateShape(options, object);
          break;
        case x3dTypes.GROUP:
          geometry = instantiateGroup(options, object);
          break;
        default:
          console.log("WARNING: unknown definition: " + object.definition);
          break;
      }
      return geometry;
    };
    var instantiateDefinitions = (options, objects) => {
      const geometries = objects.map((object) => instantiateDefinition(options, object)).filter((g) => g != null);
      instantiatedList.clear();
      return geometries;
    };
    module.exports = instantiateDefinitions;
  }
});

// node_modules/@jscad/x3d-deserializer/src/instantiate.js
var require_instantiate2 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/instantiate.js"(exports, module) {
    var { flatten } = require_src2();
    var parse = require_parse2();
    var instantiateDefinitions = require_instantiateDefinitions();
    var { x3dTypes } = require_objects();
    var instantiate = (options, src) => {
      const defaults = {
        pxPmm: require_constants3().pxPmm
      };
      options = Object.assign({}, defaults, options);
      const { pxPmm } = options;
      options && options.statusCallback && options.statusCallback({ progress: 0 });
      const { x3dObj } = parse(src, pxPmm);
      if (x3dObj.definition !== x3dTypes.X3D || !x3dObj.objects)
        throw new Error("X3D malformed");
      if (x3dObj.objects.length < 1 || x3dObj.objects[0].definition !== x3dTypes.SCENE)
        throw new Error("X3D did not define a SCENE");
      options && options.statusCallback && options.statusCallback({ progress: 50 });
      const scene = x3dObj.objects[0];
      const objects = scene.objects;
      let geometries = instantiateDefinitions(options, objects);
      if (options.flatten)
        geometries = flatten(geometries);
      options && options.statusCallback && options.statusCallback({ progress: 100 });
      return geometries;
    };
    module.exports = instantiate;
  }
});

// node_modules/@jscad/x3d-deserializer/src/index.js
var require_src7 = __commonJS({
  "node_modules/@jscad/x3d-deserializer/src/index.js"(exports, module) {
    var version = require_package8().version;
    var translate = require_translate3();
    var instantiate = require_instantiate2();
    var deserialize = (options, input) => {
      const defaults = {
        filename: "x3d",
        output: "script",
        version,
        flatten: true,
        addMetaData: true
      };
      options = Object.assign({}, defaults, options);
      return options.output === "script" ? translate(options, input) : instantiate(options, input);
    };
    var extension = "x3d";
    module.exports = {
      deserialize,
      extension
    };
  }
});

// node_modules/@jscad/io/deserializers.js
var require_deserializers = __commonJS({
  "node_modules/@jscad/io/deserializers.js"(exports, module) {
    var amfDeSerializer = require_src5();
    var dxfDeSerializer = require_dxf_deserializer();
    var jsonDeSerializer = require_json_deserializer();
    var objDeSerializer = require_obj_deserializer();
    var stlDeSerializer = require_stl_deserializer();
    var svgDeSerializer = require_src6();
    var x3dDeSerializer = require_src7();
    var deserializers = {};
    deserializers[amfDeSerializer.extension] = amfDeSerializer.deserialize;
    deserializers[dxfDeSerializer.extension] = dxfDeSerializer.deserialize;
    deserializers[jsonDeSerializer.extension] = jsonDeSerializer.deserialize;
    deserializers[objDeSerializer.extension] = objDeSerializer.deserialize;
    deserializers[stlDeSerializer.extension] = stlDeSerializer.deserialize;
    deserializers[svgDeSerializer.extension] = svgDeSerializer.deserialize;
    deserializers[x3dDeSerializer.extension] = x3dDeSerializer.deserialize;
    module.exports = deserializers;
  }
});

// node_modules/@jscad/io/index.js
var require_io = __commonJS({
  "node_modules/@jscad/io/index.js"(exports, module) {
    var { makeBlob, convertToBlob } = require_io_utils();
    var amfSerializer = require_amf_serializer();
    var dxfSerializer = require_dxf_serializer();
    var jsonSerializer = require_json_serializer();
    var objSerializer = require_obj_serializer();
    var stlSerializer = require_stl_serializer();
    var svgSerializer = require_svg_serializer();
    var x3dSerializer = require_src3();
    var m3fSerializer = require_src4();
    var prepareOutput = require_prepareOutput();
    var deserializers = require_deserializers();
    var solidsAsBlob = (solids, params) => convertToBlob(prepareOutput(solids, params));
    module.exports = {
      makeBlob,
      solidsAsBlob,
      amfSerializer,
      dxfSerializer,
      jsonSerializer,
      objSerializer,
      stlSerializer,
      svgSerializer,
      x3dSerializer,
      m3fSerializer,
      // UG javascript doesn't allow names with leading digit
      deserializers
    };
  }
});
export default require_io();
/*! Bundled license information:

xmlchars/xml/1.0/ed5.js:
  (**
   * Character classes and associated utilities for the 5th edition of XML 1.0.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)

xmlchars/xml/1.1/ed2.js:
  (**
   * Character classes and associated utilities for the 2nd edition of XML 1.1.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)

xmlchars/xmlns/1.0/ed3.js:
  (**
   * Character class utilities for XML NS 1.0 edition 3.
   *
   * @author Louis-Dominique Dubeau
   * @license MIT
   * @copyright Louis-Dominique Dubeau
   *)
*/
//# sourceMappingURL=@jscad_io.js.map
