{
  "version": 3,
  "sources": ["../../@jscad/modeling/src/curves/bezier/valueAt.js", "../../@jscad/modeling/src/curves/bezier/tangentAt.js", "../../@jscad/modeling/src/curves/bezier/lengths.js", "../../@jscad/modeling/src/curves/bezier/length.js", "../../@jscad/modeling/src/curves/bezier/arcLengthToT.js", "../../@jscad/modeling/src/curves/bezier/index.js"],
  "sourcesContent": ["/**\n * Calculates the value at a specific position along a bezier easing curve.\n * For multidimensional curves, the tangent is the slope of each dimension at that point.\n * See the example called extrudeAlongPath.js to see this in use.\n * Math and explanation comes from {@link https://www.freecodecamp.org/news/nerding-out-with-bezier-curves-6e3c0bc48e2f/}\n *\n * @example\n * const b = bezier.create([0,0,0], [0,5,10], [10,0,-5], [10,10,10]]) // a cubic 3 dimensional easing curve that can generate position arrays for modelling\n * let position = bezier.valueAt(t,b) // where 0 < t < 1\n *\n * @param {number} t : the position of which to calculate the value; 0 < t < 1\n * @param {Object} bezier : a bezier curve created with bezier.create().\n * @returns {array | number} the value at the requested position.\n * @alias module:modeling/curves/bezier.valueAt\n */\nconst valueAt = (t, bezier) => {\n  if (t < 0 || t > 1) {\n    throw new Error('Bezier valueAt() input must be between 0 and 1')\n  }\n  if (bezier.pointType === 'float_single') {\n    return bezierFunction(bezier, bezier.points, t)\n  } else {\n    const result = []\n    for (let i = 0; i < bezier.dimensions; i++) {\n      const singleDimensionPoints = []\n      for (let j = 0; j < bezier.points.length; j++) {\n        singleDimensionPoints.push(bezier.points[j][i])\n      }\n      result.push(bezierFunction(bezier, singleDimensionPoints, t))\n    }\n    return result\n  }\n}\n\nconst bezierFunction = function (bezier, p, t) {\n  const n = p.length - 1\n  let result = 0\n  for (let i = 0; i <= n; i++) {\n    result += bezier.permutations[i] * Math.pow(1 - t, n - i) * Math.pow(t, i) * p[i]\n  }\n  return result\n}\n\nmodule.exports = valueAt\n", "/**\n * Calculates the tangent at a specific position along a bezier easing curve.\n * For multidimensional curves, the tangent is the slope of each dimension at that point.\n * See the example called extrudeAlongPath.js\n *\n * @example\n * const b = bezier.create([[0,0,0], [0,5,10], [10,0,-5], [10,10,10]]) // a cubic 3 dimensional easing curve that can generate position arrays for modelling\n * let tangent = bezier.tangentAt(t, b)\n *\n * @param {number} t : the position of which to calculate the bezier's tangent value; 0 < t < 1\n * @param {Object} bezier : an array with at least 2 elements of either all numbers, or all arrays of numbers that are the same size.\n * @return {array | number} the tangent at the requested position.\n * @alias module:modeling/curves/bezier.tangentAt\n */\nconst tangentAt = (t, bezier) => {\n  if (t < 0 || t > 1) {\n    throw new Error('Bezier tangentAt() input must be between 0 and 1')\n  }\n  if (bezier.pointType === 'float_single') {\n    return bezierTangent(bezier, bezier.points, t)\n  } else {\n    const result = []\n    for (let i = 0; i < bezier.dimensions; i++) {\n      const singleDimensionPoints = []\n      for (let j = 0; j < bezier.points.length; j++) {\n        singleDimensionPoints.push(bezier.points[j][i])\n      }\n      result.push(bezierTangent(bezier, singleDimensionPoints, t))\n    }\n    return result\n  }\n}\n\nconst bezierTangent = function (bezier, p, t) {\n  // from https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-der.html\n  const n = p.length - 1\n  let result = 0\n  for (let i = 0; i < n; i++) {\n    const q = n * (p[i + 1] - p[i])\n    result += bezier.tangentPermutations[i] * Math.pow(1 - t, n - 1 - i) * Math.pow(t, i) * q\n  }\n  return result\n}\n\nmodule.exports = tangentAt\n", "const valueAt = require('./valueAt')\n\n/**\n * Divides the bezier curve into line segments and returns the cumulative length of those segments as an array.\n * Utility function used to calculate the curve's approximate length and determine the equivalence between arc length and time.\n *\n * @example\n * const b = bezier.create([[0, 0], [0, 10]]);\n * const totalLength = lengths(100, b).pop(); // the last element of the array is the curve's approximate length\n *\n * @param {Number} segments the number of segments to use when approximating the curve length.\n * @param {Object} bezier a bezier curve.\n * @returns an array containing the cumulative length of the segments.\n */\nconst lengths = (segments, bezier) => {\n  let sum = 0\n  const lengths = [0]\n  let previous = valueAt(0, bezier)\n  for (let index = 1; index <= segments; index++) {\n    const current = valueAt(index / segments, bezier)\n    sum += distanceBetween(current, previous)\n    lengths.push(sum)\n    previous = current\n  }\n  return lengths\n}\n\n/**\n * Calculates the Euclidean distance between two n-dimensional points.\n *\n * @example\n * const distance = distanceBetween([0, 0], [0, 10]); // calculate distance between 2D points\n * console.log(distance); // output 10\n *\n * @param {Array} a - first operand.\n * @param {Array} b - second operand.\n * @returns {Number} - distance.\n */\nconst distanceBetween = (a, b) => {\n  if (Number.isFinite(a) && Number.isFinite(b)) {\n    return Math.abs(a - b)\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      throw new Error('The operands must have the same number of dimensions.')\n    }\n    let sum = 0\n    for (let i = 0; i < a.length; i++) {\n      sum += (b[i] - a[i]) * (b[i] - a[i])\n    }\n    return Math.sqrt(sum)\n  } else {\n    throw new Error('The operands must be of the same type, either number or array.')\n  }\n}\n\nmodule.exports = lengths\n", "const lengths = require('./lengths')\n\n/**\n * Approximates the length of the bezier curve by sampling it at a sequence of points, then adding up all the distances.\n * This is equivalent to flattening the curve into lines and adding up all the line lengths.\n *\n * @example\n * const b = bezier.create([[0, 0], [0, 10]]);\n * console.log(length(100, b)) // output 10\n *\n * @param {Number} segments the number of segments to use when approximating the curve length.\n * @param {Object} bezier a bezier curve.\n * @returns an approximation of the curve's length.\n * @alias module:modeling/curves/bezier.length\n */\nconst length = (segments, bezier) => lengths(segments, bezier)[segments]\n\nmodule.exports = length\n", "const lengths = require('./lengths')\n\n/**\n * Convert a given arc length along a bezier curve to a t value.\n * Useful for generating equally spaced points along a bezier curve.\n *\n * @example\n * const points = [];\n * const segments = 9; // this will generate 10 equally spaced points\n * const increment = bezier.length(100, bezierCurve) / segments;\n * for(let i = 0; i <= segments; i++) {\n *   const t = bezier.arcLengthToT({distance: i * increment}, bezierCurve);\n *   const point = bezier.valueAt(t, bezierCurve);\n *   points.push(point);\n * }\n * return points;\n *\n * @param {Object} [options] options for construction\n * @param {Number} [options.distance=0] the distance along the bezier curve for which we want to find the corresponding t value.\n * @param {Number} [options.segments=100] the number of segments to use when approximating the curve length.\n * @param {Object} bezier a bezier curve.\n * @returns a number in the [0, 1] interval or NaN if the arcLength is negative or greater than the total length of the curve.\n * @alias module:modeling/curves/bezier.arcLengthToT\n */\nconst arcLengthToT = (options, bezier) => {\n  const defaults = {\n    distance: 0,\n    segments: 100\n  }\n  const { distance, segments } = Object.assign({}, defaults, options)\n\n  const arcLengths = lengths(segments, bezier)\n  // binary search for the index with largest value smaller than target arcLength\n  let startIndex = 0\n  let endIndex = segments\n  while (startIndex <= endIndex) {\n    const middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2)\n    const diff = arcLengths[middleIndex] - distance\n    if (diff < 0) {\n      startIndex = middleIndex + 1\n    } else if (diff > 0) {\n      endIndex = middleIndex - 1\n    } else {\n      endIndex = middleIndex\n      break\n    }\n  }\n  // if we have an exact match, return it\n  const targetIndex = endIndex\n  if (arcLengths[targetIndex] === distance) {\n    return targetIndex / segments\n  }\n  // we could get finer grain at lengths, or use simple interpolation between two points\n  const lengthBefore = arcLengths[targetIndex]\n  const lengthAfter = arcLengths[targetIndex + 1]\n  const segmentLength = lengthAfter - lengthBefore\n  // determine where we are between the 'before' and 'after' points\n  const segmentFraction = (distance - lengthBefore) / segmentLength\n  // add that fractional amount and return\n  return (targetIndex + segmentFraction) / segments\n}\n\nmodule.exports = arcLengthToT\n", "/**\n * Represents a bezier easing function.\n * @see {@link bezier} for data structure information.\n * @module modeling/curves/bezier\n */\nmodule.exports = {\n  create: require('./create'),\n  valueAt: require('./valueAt'),\n  tangentAt: require('./tangentAt'),\n  lengths: require('./lengths'),\n  length: require('./length'),\n  arcLengthToT: require('./arcLengthToT')\n}\n"],
  "mappings": "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",
  "names": ["lengths"]
}
